package gov.fnal.controls.servers.dpm.acnetlib;

public interface AcnetErrors {

    /**
     * ACNET facility
     */
    public final static int FACILITY_ACNET = 1;
    public final static int ACNET_OK = 0;
    public final static int ACNET_SUCCESS = 0;

    /**
     * The request was successful, but used a deprecated feature. Contact the
     * author to update their application to use the latest API.
     */
    public final static int ACNET_DEPRECATED = FACILITY_ACNET + (4*256);

    /**
     * A reply wasn't received within a given amount of time. This is not a
     * fatal error, as the reply may still being coming, but it is taking
     * longer than expected.
     */
    public final static int ACNET_REPLY_TIMEOUT = FACILITY_ACNET + (3*256);

    /**
     * End multiple replies (on final reply).
     */
    public final static int ACNET_ENDMULT = FACILITY_ACNET + (2*256);

    /**
     * Operation is pending completion
     */
    public final static int ACNET_PEND = FACILITY_ACNET + (1*256);

    /**
     * Retryable I/O error.
     */
    public final static int ACNET_RETRY = FACILITY_ACNET + (-1*256);

    /**
     * No local memory or table space available.
     */
    public final static int ACNET_NOLCLMEM = FACILITY_ACNET + (-2*256);

    /**
     * No remote system memory or table space available.
     */
    public final static int ACNET_NOREMMEM = FACILITY_ACNET + (-3*256);

    /**
     * Reply message packet assembly error.
     */
    public final static int ACNET_RPLYPACK = FACILITY_ACNET + (-4*256);

    /**
     * Request message packet assembly error.
     */
    public final static int ACNET_REQPACK = FACILITY_ACNET + (-5*256);

    /**
     * Request timeout with queued at destination.  This error is generated by
     * acnetd in the event that there is no reply to a request in 6 1/2
     * minutes.
     */
    public final static int ACNET_REQTMO = FACILITY_ACNET + (-6*256);

    /**
     * Request failed, destination queue full.
     */
    public final static int ACNET_QUEFULL = FACILITY_ACNET + (-7*256);

    /**
     * Request failed, destination task busy.
     */
    public final static int ACNET_BUSY = FACILITY_ACNET + (-8*256);

    /**
     * Not connected to network.
     */
    public final static int ACNET_NOT_CONNECTED = FACILITY_ACNET + (-21*256);

    /**
     * Missing argument(s).
     */
    public final static int ACNET_ARG = FACILITY_ACNET + (-22*256);

    /**
     * Invalid message length or buffer address.
     */
    public final static int ACNET_IVM = FACILITY_ACNET + (-23*256);

    /**
     * No such request or reply.
     */
    public final static int ACNET_NO_SUCH = FACILITY_ACNET + (-24*256);

    /**
     * The request has been rejected. This generally means the client isn't
     * allowed to send requests to the target task.
     */
    public final static int ACNET_REQREJ = FACILITY_ACNET + (-25*256);

    /**
     * Request has been cancelled.
     */
    public final static int ACNET_CANCELLED = FACILITY_ACNET + (-26*256);

    /**
     * Network task name already in use.
     */
    public final static int ACNET_NAME_IN_USE = FACILITY_ACNET + (-27*256);

    /**
     * Not connected as a RUM task.
     */
    public final static int ACNET_NCR = FACILITY_ACNET + (-28*256);

    /**
     * No such logical node Note that pseudo-nodes on trunk 230 are not
     * considered real ACNET nodes for communication purposes.
     */
    public final static int ACNET_NO_NODE = FACILITY_ACNET + (-30*256);

    /**
     * Truncated request message.
     */
    public final static int ACNET_TRUNC_REQUEST = FACILITY_ACNET + (-31*256);

    /**
     * Truncated reply message.
     */
    public final static int ACNET_TRUNC_REPLY = FACILITY_ACNET + (-32*256);

    /**
     * No such destination task.
     */
    public final static int ACNET_NO_TASK = FACILITY_ACNET + (-33*256);

    /**
     * Replier task being disconnected.
     */
    public final static int ACNET_DISCONNECTED = FACILITY_ACNET + (-34*256);

    /**
     * ACNET Level II function error.
     */
    public final static int ACNET_LEVEL2 = FACILITY_ACNET + (-35*256);

    /**
     * Hard I/O error.
     */
    public final static int ACNET_HARD_IO = FACILITY_ACNET + (-41*256);

    /**
     * Logical node down or offline. Java DAQ pings nodes via their guarnateed
     * readable devices.   If a node's guaranteed readable fails Java marks the
     * node down until it again responds to Java's pings.  While in the down
     * state Java DAQ will not attempt DAQ from a nodw but will instead return
     * this error for any attempt.  If one is looking at data that was not
     * acquired via Java DAQ, e.g., Linux DAQ, a different error is possible,
     * e.g., DPM_PEND.
     */
    public final static int ACNET_NODE_DOWN = FACILITY_ACNET + (-42*256);

    /**
     * System service error.
     */
    public final static int ACNET_SYS = FACILITY_ACNET + (-43*256);

    /**
     * Untranslatable error.
     */
    public final static int ACNET_NXE = FACILITY_ACNET + (-44*256);

    /**
     * Network internal error.
     */
    public final static int ACNET_BUG = FACILITY_ACNET + (-45*256);

    /**
     * Network error #1. VAX/VMS: exceeded some quota or limit (i.e., AST
     * limit).
     */
    public final static int ACNET_NE1 = FACILITY_ACNET + (-46*256);

    /**
     * Network error #2. VAX/VMS: no address for request/reply id word.
     */
    public final static int ACNET_NE2 = FACILITY_ACNET + (-47*256);

    /**
     * Network error #3. VAX/VMS: buffer/control block vector in use, or block
     * already locked for modification.
     */
    public final static int ACNET_NE3 = FACILITY_ACNET + (-48*256);

    /**
     * User-generated network reply timeout. The program has sent an ACNET
     * request to another task. No reply has been received within a timeout
     * period.
     */
    public final static int ACNET_UTIME = FACILITY_ACNET + (-49*256);

    /**
     * Invalid argument was passed.
     */
    public final static int ACNET_INVARG = FACILITY_ACNET + (-50*256);

    /**
     * Dynamic memory allocation failed.
     */
    public final static int ACNET_MEMFAIL = FACILITY_ACNET + (-51*256);

    /**
     * Requested ACNET handle does not exist.
     */
    public final static int ACNET_NO_HANDLE = FACILITY_ACNET + (-52*256);

    /**
     * FSHARE facility
     */
    public final static int FACILITY_FSHARE = 2;
    public final static int FSHARE_OK = 0;
    public final static int FSHARE_SUCCESS = 0;

    /**
     * Retrieved record exceeds specified key value.
     */
    public final static int FSHARE_EXCKEY = FACILITY_FSHARE + (126*256);

    /**
     * Record inserted but error on index update.
     */
    public final static int FSHARE_INDXERR = FACILITY_FSHARE + (125*256);

    /**
     * Record inserted has duplicate.
     */
    public final static int FSHARE_DUPKEY = FACILITY_FSHARE + (124*256);

    /**
     * Deleted record accessed successfully, Non-existent record accessed
     * successfully.
     */
    public final static int FSHARE_DRAS = FACILITY_FSHARE + (123*256);

    /**
     * Record already locked.
     */
    public final static int FSHARE_ALRDYLCK = FACILITY_FSHARE + (122*256);

    /**
     * Known file found.
     */
    public final static int FSHARE_FOUND = FACILITY_FSHARE + (121*256);

    /**
     * Record not locked.
     */
    public final static int FSHARE_NOTLOCK = FACILITY_FSHARE + (120*256);

    /**
     * Beginning of file.
     */
    public final static int FSHARE_BOF = FACILITY_FSHARE + (119*256);

    /**
     * Record locked but can be read anyway.
     */
    public final static int FSHARE_LOCKREAD = FACILITY_FSHARE + (118*256);

    /**
     * Record locked after wait operation.
     */
    public final static int FSHARE_LOCKWAIT = FACILITY_FSHARE + (117*256);

    /**
     * No working buffer for FSWADC call.
     */
    public final static int FSHARE_NOWBUF = FACILITY_FSHARE + (2*256);

    /**
     * A Filesharing UTI AST service routine did not execute.  You could be
     * calling Filesharing at AST level which is not allowed.
     */
    public final static int FSHARE_NOASTSERVICE = FACILITY_FSHARE + (-1*256);

    /**
     * Filesharing busy (asynch operation in progress).
     */
    public final static int FSHARE_BUSY = FACILITY_FSHARE + (-2*256);

    /**
     * Working buffer too small.
     */
    public final static int FSHARE_TOOSML = FACILITY_FSHARE + (-3*256);

    /**
     * Working buffer already allocated.
     */
    public final static int FSHARE_ALLOCD = FACILITY_FSHARE + (-4*256);

    /**
     * Maximum record length exceeded (3930 bytes).
     */
    public final static int FSHARE_TOOLONG = FACILITY_FSHARE + (-5*256);

    /**
     * Network I/O timed out
     */
    public final static int FSHARE_TMO = FACILITY_FSHARE + (-6*256);

    /**
     * The filesharing write user lock is locked.  This lock may be set by the
     * application program or more commonly by the script record or playback
     * utility.
     */
    public final static int FSHARE_USERLOCK = FACILITY_FSHARE + (-7*256);

    /**
     * This console class is not privileged to write to files from this
     * program. Index page entries colored cyan are always privileged to write.
     * Index page entries colored blue are only privileged if the application's
     * FSwriteOk class definition is cyan.  Contact Operations or Controls for
     * more information.
     */
    public final static int FSHARE_NOPRIV = FACILITY_FSHARE + (-8*256);

    /**
     * Virtual Unit Number assign error (no table room).
     */
    public final static int FSHARE_VUNERR = FACILITY_FSHARE + (-67*256);

    /**
     * Virtual Unit Number already assigned.
     */
    public final static int FSHARE_VUNASSGN = FACILITY_FSHARE + (-68*256);

    /**
     * Virtual Unit Number never assigned.
     */
    public final static int FSHARE_NOVUN = FACILITY_FSHARE + (-69*256);

    /**
     * File Sharing operation type code error.
     */
    public final static int FSHARE_TCERR = FACILITY_FSHARE + (-70*256);

    /**
     * Open argument error detected after receiving FSOPEN request.(Possible
     * network transmission error)
     */
    public final static int FSHARE_FSOAER = FACILITY_FSHARE + (-71*256);

    /**
     * Record size error detected after receiving File Sharing request. This
     * can be a possible network transmission error, however this is very rare.
     * Another possiblity is that the File Sharing procedures are not checking
     * for the current maximum record size andallowing a record size that is
     * larger than the current maximum. File Sharing procedures should return a
     * -5 if the maximum record size has been exceeded. The current maximum
     * record size is 3930 bytes or 1965 words. Programs should ask for no more
     * than themaximum record size.
     */
    public final static int FSHARE_FSRSER = FACILITY_FSHARE + (-72*256);

    /**
     * File Sharing network request buffer size error.
     */
    public final static int FSHARE_FSREQE = FACILITY_FSHARE + (-79*256);

    /**
     * Invalid record size.
     */
    public final static int FSHARE_INVRCSIZ = FACILITY_FSHARE + (-85*256);

    /**
     * Record already exists.
     */
    public final static int FSHARE_EXISTS = FACILITY_FSHARE + (-86*256);

    /**
     * End of file.
     */
    public final static int FSHARE_EOF = FACILITY_FSHARE + (-87*256);

    /**
     * Device full, File extend error.
     */
    public final static int FSHARE_DEVFUL = FACILITY_FSHARE + (-88*256);

    /**
     * Invalid record operation, Record not found, Invalid RFA, Record deleted,
     * No current record.
     */
    public final static int FSHARE_NOREC = FACILITY_FSHARE + (-89*256);

    /**
     * Operation not sequential.
     */
    public final static int FSHARE_NOTSEQ = FACILITY_FSHARE + (-90*256);

    /**
     * Record locked by another process.
     */
    public final static int FSHARE_LOCKED = FACILITY_FSHARE + (-92*256);

    /**
     * Invalid value for maximum record number.
     */
    public final static int FSHARE_IVMAXR = FACILITY_FSHARE + (-93*256);

    /**
     * Invalid operation.
     */
    public final static int FSHARE_INVOP = FACILITY_FSHARE + (-94*256);

    /**
     * Key sequence error, Key size too large (read or write), Invalid key of
     * reference, Invalid key record, Duplicate keys not allowed, Key value
     * change not allowed.
     */
    public final static int FSHARE_KEYERR = FACILITY_FSHARE + (-95*256);

    /**
     * Index tree error, Error while updating RRV, Invalid RRV record
     * encountered, Invalid bucket format, Index bucket check byte error.
     */
    public final static int FSHARE_IDXERR = FACILITY_FSHARE + (-96*256);

    /**
     * File is locked.
     */
    public final static int FSHARE_FILOCK = FACILITY_FSHARE + (-100*256);

    /**
     * Submit or spool failed.
     */
    public final static int FSHARE_SUBFAIL = FACILITY_FSHARE + (-101*256);

    /**
     * File deaccess error, Can not close file.
     */
    public final static int FSHARE_CLSERR = FACILITY_FSHARE + (-102*256);

    /**
     * Error in file type.
     */
    public final static int FSHARE_TYPERR = FACILITY_FSHARE + (-103*256);

    /**
     * Invalid related file.
     */
    public final static int FSHARE_IVRFIL = FACILITY_FSHARE + (-105*256);

    /**
     * Key size too large (open).
     */
    public final static int FSHARE_KEYSIZ = FACILITY_FSHARE + (-106*256);

    /**
     * Invalid file attributes.
     */
    public final static int FSHARE_IVATTR = FACILITY_FSHARE + (-107*256);

    /**
     * Invalid file processing options.
     */
    public final static int FSHARE_IVFOP = FACILITY_FSHARE + (-108*256);

    /**
     * File not found, Directory not found.
     */
    public final static int FSHARE_NOFILE = FACILITY_FSHARE + (-109*256);

    /**
     * Logical name error, Syntax error in file name, Error in directory name.
     */
    public final static int FSHARE_FSYNTX = FACILITY_FSHARE + (-110*256);

    /**
     * Bad device type, Channel assignment failure.
     */
    public final static int FSHARE_BADDEV = FACILITY_FSHARE + (-111*256);

    /**
     * File access error.
     */
    public final static int FSHARE_FILACC = FACILITY_FSHARE + (-112*256);

    /**
     * Lock manager finds deadlock.
     */
    public final static int FSHARE_DEADLK = FACILITY_FSHARE + (-118*256);

    /**
     * Device is write locked.
     */
    public final static int FSHARE_LOCKWRIT = FACILITY_FSHARE + (-119*256);

    /**
     * System error (QIO).
     */
    public final static int FSHARE_QIOERR = FACILITY_FSHARE + (-120*256);

    /**
     * Operation not supported.
     */
    public final static int FSHARE_BADOP = FACILITY_FSHARE + (-121*256);

    /**
     * File protect violation or write to file opened READONLY.
     */
    public final static int FSHARE_NOWRIT = FACILITY_FSHARE + (-122*256);

    /**
     * Device not ready.
     */
    public final static int FSHARE_NOTREADY = FACILITY_FSHARE + (-123*256);

    /**
     * Can not deliver AST.
     */
    public final static int FSHARE_NOAST = FACILITY_FSHARE + (-124*256);

    /**
     * File header write error.
     */
    public final static int FSHARE_FHWERR = FACILITY_FSHARE + (-125*256);

    /**
     * File header read error.
     */
    public final static int FSHARE_FHRERR = FACILITY_FSHARE + (-126*256);

    /**
     * No file sharing specific error available.
     */
    public final static int FSHARE_OTHER = FACILITY_FSHARE + (-128*256);

    /**
     * APM facility
     */
    public final static int FACILITY_APM = 3;
    public final static int APM_OK = 0;
    public final static int APM_SUCCESS = 0;

    /**
     * APM stopped task on abort request, see extended status.
     */
    public final static int APM_TSKSTP = FACILITY_APM + (3*256);

    /**
     * Support task has exited, see extended status.
     */
    public final static int APM_SLVXIT = FACILITY_APM + (2*256);

    /**
     * Single user task is already active.
     */
    public final static int APM_SUTACT = FACILITY_APM + (-1*256);

    /**
     * No such task is known by APM.
     */
    public final static int APM_UNKTSK = FACILITY_APM + (-2*256);

    /**
     * Error in request frame, see system programmer.
     */
    public final static int APM_REQFRE = FACILITY_APM + (-3*256);

    /**
     * Create process directive failed, see extended status.
     */
    public final static int APM_CRPRER = FACILITY_APM + (-4*256);

    /**
     * Already connected to this task.
     */
    public final static int APM_CNCTED = FACILITY_APM + (-5*256);

    /**
     * No privilege.  Settings are locked out on this console.
     */
    public final static int APM_NOPRIV = FACILITY_APM + (-6*256);

    /**
     * LJ facility
     */
    public final static int FACILITY_LJ = 4;
    public final static int LJ_OK = 0;
    public final static int LJ_SUCCESS = 0;

    /**
     * An illegal length was specified.  Contact the programmer.
     */
    public final static int LJ_INVLEN = FACILITY_LJ + (-1*256);

    /**
     * Unsupported typecode.  Contact the programmer.
     */
    public final static int LJ_INVTC = FACILITY_LJ + (-2*256);

    /**
     * Unable to allocate memory.  Contact the programmer.
     */
    public final static int LJ_MEMFAIL = FACILITY_LJ + (-3*256);

    /**
     * Network communication error.  Specified Lumberjack does not seem to be
     * up.
     */
    public final static int LJ_COMM = FACILITY_LJ + (-4*256);

    /**
     * Error reading the datalogger specification file. Contact the programmer.
     */
    public final static int LJ_DLREAD = FACILITY_LJ + (-5*256);

    /**
     * Error reading the device specification file. Contact the programmer.
     */
    public final static int LJ_DVREAD = FACILITY_LJ + (-6*256);

    /**
     * Error writing the device specification file. Contact the programmer.
     */
    public final static int LJ_DVWRITE = FACILITY_LJ + (-7*256);

    /**
     * Invalid argument passed.
     */
    public final static int LJ_INVARG = FACILITY_LJ + (-8*256);

    /**
     * Object of request does not exist.  If redirecting, then data was not
     * logged from this data source within the time data accuracy specified.
     */
    public final static int LJ_NO_SUCH = FACILITY_LJ + (-9*256);

    /**
     * Invalid time window selected.
     */
    public final static int LJ_INV_TIMES = FACILITY_LJ + (-10*256);

    /**
     * The front end is not responding.  Multiple, successive datapool pendings
     * imply the front end is not reachable.
     */
    public final static int LJ_NODEDOWN = FACILITY_LJ + (-11*256);

    /**
     * The time accuracy specified cannot be satisfied.  If you are redirected
     * and have asked for data beginning at time T1 with an accuracy of n
     * seconds, then the logged value's timestamp was greater than n seconds
     * after T1.  Choose another data source, increase the accuracy window, or
     * change T1 and try again.
     */
    public final static int LJ_TIME = FACILITY_LJ + (-12*256);

    /**
     * User abort detected.
     */
    public final static int LJ_ABORT = FACILITY_LJ + (-21*256);

    /**
     * An invalid SDA case was requested.
     */
    public final static int LJ_INVALID_SDA_CASE = FACILITY_LJ + (-22*256);

    /**
     * An invalid SDA set was requested.
     */
    public final static int LJ_INVALID_SDA_SET = FACILITY_LJ + (-23*256);

    /**
     * A math exception occurred while processing data.
     */
    public final static int LJ_MATH_EXCEPTION = FACILITY_LJ + (-25*256);

    /**
     * CBS facility
     */
    public final static int FACILITY_CBS = 5;
    public final static int CBS_OK = 0;
    public final static int CBS_SUCCESS = 0;

    /**
     * More data is available than what was returned.  This may be due to
     * process memory limits.
     */
    public final static int CBS_MORE_DATA = FACILITY_CBS + (11*256);

    /**
     * The end of file was reached.
     */
    public final static int CBS_END_OF_FILE = FACILITY_CBS + (10*256);

    /**
     * The data that was previously entered is not acceptable.  New data must
     * be entered.
     */
    public final static int CBS_REENTER_DATA = FACILITY_CBS + (9*256);

    /**
     * Some, but not all requested data was returned.
     */
    public final static int CBS_INCOMPLETE_DATA = FACILITY_CBS + (8*256);

    /**
     * The returned data set contains inconsistent timestamps.  Perhaps some of
     * the data us not related to the rest (taken on other machine cycles).
     */
    public final static int CBS_INCONSISTENT_TIMES = FACILITY_CBS + (7*256);

    /**
     * The requested data has not changed.
     */
    public final static int CBS_NO_CHANGE = FACILITY_CBS + (6*256);

    /**
     * Additional values are available.
     */
    public final static int CBS_MORE_VALUES = FACILITY_CBS + (5*256);

    /**
     * Operation is pending.
     */
    public final static int CBS_PEND = FACILITY_CBS + (3*256);

    /**
     * Setup done: ready to go.
     */
    public final static int CBS_READY = FACILITY_CBS + (2*256);

    /**
     * Too many arguments were passed.
     */
    public final static int CBS_TOO_MANY_ARGS = FACILITY_CBS + (1*256);

    /**
     * Invalid argument was passed.
     */
    public final static int CBS_INVARG = FACILITY_CBS + (-1*256);

    /**
     * Dynamic memory allocation failed.
     */
    public final static int CBS_MEMFAIL = FACILITY_CBS + (-2*256);

    /**
     * Requested feature has not been implemented yet.
     */
    public final static int CBS_NOTYET = FACILITY_CBS + (-3*256);

    /**
     * No initialization has been done.
     */
    public final static int CBS_NOINIT = FACILITY_CBS + (-4*256);

    /**
     * Invalid ID used.
     */
    public final static int CBS_INVID = FACILITY_CBS + (-5*256);

    /**
     * Function call timed out.
     */
    public final static int CBS_TIMEOUT = FACILITY_CBS + (-6*256);

    /**
     * Duplicate request received.
     */
    public final static int CBS_DUPREQ = FACILITY_CBS + (-7*256);

    /**
     * Invalid name used.
     */
    public final static int CBS_INVNAME = FACILITY_CBS + (-8*256);

    /**
     * Read-only allowed.
     */
    public final static int CBS_READONLY = FACILITY_CBS + (-9*256);

    /**
     * Process or utility gone -- terminated.
     */
    public final static int CBS_GONE = FACILITY_CBS + (-10*256);

    /**
     * Request limit has been reached.
     */
    public final static int CBS_REQLIMIT = FACILITY_CBS + (-11*256);

    /**
     * Busy on previous request.
     */
    public final static int CBS_BUSY = FACILITY_CBS + (-12*256);

    /**
     * No data exists for this request.
     */
    public final static int CBS_NODAT = FACILITY_CBS + (-13*256);

    /**
     * Invalid process slot.
     */
    public final static int CBS_INVSLOT = FACILITY_CBS + (-14*256);

    /**
     * Required file is not open.
     */
    public final static int CBS_NOT_OPEN = FACILITY_CBS + (-15*256);

    /**
     * Requested featured is not enabled.
     */
    public final static int CBS_NOT_ENABLED = FACILITY_CBS + (-16*256);

    /**
     * Stale data returned.
     */
    public final static int CBS_STALE = FACILITY_CBS + (-17*256);

    /**
     * Required setup call needs to be done first.
     */
    public final static int CBS_NOSETUP = FACILITY_CBS + (-18*256);

    /**
     * Change program request failed.
     */
    public final static int CBS_CHGPGM_FAIL = FACILITY_CBS + (-19*256);

    /**
     * Specified value is out of range.
     */
    public final static int CBS_RANGE = FACILITY_CBS + (-20*256);

    /**
     * User abort detected.
     */
    public final static int CBS_ABORT = FACILITY_CBS + (-21*256);

    /**
     * No such window exists.
     */
    public final static int CBS_NO_WINDOW = FACILITY_CBS + (-22*256);

    /**
     * Window is occluded.
     */
    public final static int CBS_WINDOW_OCCLUDED = FACILITY_CBS + (-23*256);

    /**
     * The cursor is not in the requested window.  This error can also occur if
     * an attempt is made to create a window object that lies partially or
     * entirely outside of the visible window.
     */
    public final static int CBS_NOT_IN_WINDOW = FACILITY_CBS + (-24*256);

    /**
     * The window is partially off the background window.
     */
    public final static int CBS_WINDOW_OFF_SCRN = FACILITY_CBS + (-25*256);

    /**
     * The window is too big to fit on the background window.
     */
    public final static int CBS_WINDOW_TOO_BIG = FACILITY_CBS + (-26*256);

    /**
     * The requested object does not exist.
     */
    public final static int CBS_NO_SUCH = FACILITY_CBS + (-27*256);

    /**
     * There are already too many objects to create another.
     */
    public final static int CBS_TOO_MANY = FACILITY_CBS + (-28*256);

    /**
     * Generic error -- no other error applies.
     */
    public final static int CBS_GENERIC_ERROR = FACILITY_CBS + (-29*256);

    /**
     * Invalid size or length requested.
     */
    public final static int CBS_INVSIZ = FACILITY_CBS + (-30*256);

    /**
     * Invalid type for requested operation.
     */
    public final static int CBS_INVTYP = FACILITY_CBS + (-31*256);

    /**
     * Internal program bug -- contact programmer.
     */
    public final static int CBS_BUGCHK = FACILITY_CBS + (-32*256);

    /**
     * Corrupted file or data -- contact programmer.
     */
    public final static int CBS_CORRUPT = FACILITY_CBS + (-33*256);

    /**
     * Not enough arguments were passed to a function -- contact programmer.
     */
    public final static int CBS_INSUFFICIENT_ARGS = FACILITY_CBS + (-34*256);

    /**
     * Invalid data encountered.
     */
    public final static int CBS_INVALID_DATA = FACILITY_CBS + (-36*256);

    /**
     * The result has been truncated.
     */
    public final static int CBS_TRUNCATED = FACILITY_CBS + (-38*256);

    /**
     * A syntax error was encountered.
     */
    public final static int CBS_SYNTAX = FACILITY_CBS + (-39*256);

    /**
     * Request was too big.
     */
    public final static int CBS_TOO_BIG = FACILITY_CBS + (-40*256);

    /**
     * The requested item has been deleted.
     */
    public final static int CBS_DELETED = FACILITY_CBS + (-41*256);

    /**
     * An invalid data conversion was requested.
     */
    public final static int CBS_INVALID_CONVERSION = FACILITY_CBS + (-42*256);

    /**
     * Data conversion failed.
     */
    public final static int CBS_CONVERSION_ERROR = FACILITY_CBS + (-43*256);

    /**
     * Null value supplied.
     */
    public final static int CBS_NULL_VALUE = FACILITY_CBS + (-44*256);

    /**
     * Data does not match request.
     */
    public final static int CBS_MISMATCH = FACILITY_CBS + (-45*256);

    /**
     * A math exception occurred during a calculation.
     */
    public final static int CBS_MATH_EXCEPTION = FACILITY_CBS + (-46*256);

    /**
     * Collimator size parameter not specified.
     */
    public final static int CBS_COL_NOSIZE = FACILITY_CBS + (-47*256);

    /**
     * Collimator frequency parameter not specified.
     */
    public final static int CBS_COL_NOFREQ = FACILITY_CBS + (-48*256);

    /**
     * Collimator size or frequency mismatch.
     */
    public final static int CBS_COL_MISMCH = FACILITY_CBS + (-49*256);

    /**
     * Collimator positive limit switch hit.
     */
    public final static int CBS_COL_LIMPOS = FACILITY_CBS + (-50*256);

    /**
     * Collimator negative limit switch hit.
     */
    public final static int CBS_COL_LIMNEG = FACILITY_CBS + (-51*256);

    /**
     * Collimator loss monitor limit parameter not specified.
     */
    public final static int CBS_COL_NOLOSS = FACILITY_CBS + (-52*256);

    /**
     * Collimator percent removal parameter not specified.
     */
    public final static int CBS_COL_NOPRCT = FACILITY_CBS + (-53*256);

    /**
     * Collimator stations not in locked mode.
     */
    public final static int CBS_COL_NOLOCK = FACILITY_CBS + (-54*256);

    /**
     * x0 or xi parameter outside the positive and negative limits set by the
     * user.
     */
    public final static int CBS_COL_BADX = FACILITY_CBS + (-55*256);

    /**
     * MDAT frames at this front end appear to be invalid.
     */
    public final static int CBS_COL_BADMDAT = FACILITY_CBS + (-56*256);

    /**
     * No event has been specified for loss monitor feedback.
     */
    public final static int CBS_COL_NO_EVENT = FACILITY_CBS + (-57*256);

    /**
     * No timeout period has been specified for loss monitor feedback.
     */
    public final static int CBS_COL_NO_TIMEOUT = FACILITY_CBS + (-58*256);

    /**
     * No privilege for the requested action
     */
    public final static int CBS_NOPRIV = FACILITY_CBS + (-59*256);

    /**
     * An expected value was missing.
     */
    public final static int CBS_MISSING_VALUE = FACILITY_CBS + (-61*256);

    /**
     * A value was found when none was expected.
     */
    public final static int CBS_EXTRANEOUS_VALUE = FACILITY_CBS + (-62*256);

    /**
     * A parameter (usually an array index) was out of bounds.
     */
    public final static int CBS_OUT_OF_BOUNDS = FACILITY_CBS + (-63*256);

    /**
     * A requested setting was not permitted.
     */
    public final static int CBS_SETLOCK = FACILITY_CBS + (-64*256);

    /**
     * An empty request was made.
     */
    public final static int CBS_EMPTY = FACILITY_CBS + (-65*256);

    /**
     * A calculation error occurred.
     */
    public final static int CBS_CALC_ERROR = FACILITY_CBS + (-66*256);

    /**
     * Too few values were supplied.
     */
    public final static int CBS_TOO_FEW_VALUES = FACILITY_CBS + (-67*256);

    /**
     * The requested object or service is unavailable.
     */
    public final static int CBS_UNAVAILABLE = FACILITY_CBS + (-68*256);

    /**
     * The requested operation is not supported.
     */
    public final static int CBS_NOT_SUPPORTED = FACILITY_CBS + (-69*256);

    /**
     * The requested operation is ambiguous.
     */
    public final static int CBS_AMBIGUOUS = FACILITY_CBS + (-70*256);

    /**
     * An invalid state (condition) was detected.
     */
    public final static int CBS_INVALID_STATE = FACILITY_CBS + (-82*256);

    /**
     * CMU facility
     */
    public final static int FACILITY_CMU = 6;
    public final static int CMU_OK = 0;
    public final static int CMU_SUCCESS = 0;

    /**
     * No mailbox with the specified name exists.
     */
    public final static int CMU_NO_MB = FACILITY_CMU + (-1*256);

    /**
     * An attempt to allocate dynamic memory failed.
     */
    public final static int CMU_MEMFAIL = FACILITY_CMU + (-2*256);

    /**
     * A message length of less than or equal to zero bytes was specified.
     */
    public final static int CMU_ILLEN = FACILITY_CMU + (-3*256);

    /**
     * The message length in the message header was not equal to the number of
     * bytes actually received.
     */
    public final static int CMU_BADHEAD = FACILITY_CMU + (-4*256);

    /**
     * Read access is not allowed for this mailbox.
     */
    public final static int CMU_NOACC = FACILITY_CMU + (-5*256);

    /**
     * An attempt was made to connect to a mailbox that was already connected.
     */
    public final static int CMU_DUPCON = FACILITY_CMU + (-6*256);

    /**
     * The received message message was truncated by the receiving program.
     */
    public final static int CMU_TRUNC = FACILITY_CMU + (-7*256);

    /**
     * A miscellaneous error was received from the QIO facility.
     */
    public final static int CMU_SYSERR = FACILITY_CMU + (-8*256);

    /**
     * An attempt was made to read from an empty mailbox.
     */
    public final static int CMU_NOMESS = FACILITY_CMU + (-9*256);

    /**
     * CMU has exceeded the process' byte limit quota.
     */
    public final static int CMU_EXQUO = FACILITY_CMU + (-10*256);

    /**
     * An attempt was made to write a full mailbox.
     */
    public final static int CMU_MB_FULL = FACILITY_CMU + (-11*256);

    /**
     * An attempt was made to send a message that was too large for CMU to
     * handle.
     */
    public final static int CMU_MB_TOO_SML = FACILITY_CMU + (-12*256);

    /**
     * CLIB facility
     */
    public final static int FACILITY_CLIB = 7;
    public final static int CLIB_OK = 0;
    public final static int CLIB_SUCCESS = 0;

    /**
     * Not running in a console environment.
     */
    public final static int CLIB_NOTCNSINST = FACILITY_CLIB + (127*256);

    /**
     * More data is available than what was returned.  This may be due to
     * process memory limits.
     */
    public final static int CLIB_MORE_DATA = FACILITY_CLIB + (11*256);

    /**
     * The end of file was reached.
     */
    public final static int CLIB_END_OF_FILE = FACILITY_CLIB + (10*256);

    /**
     * The data that was previously entered is not acceptable.  New data must
     * be entered.
     */
    public final static int CLIB_REENTER_DATA = FACILITY_CLIB + (9*256);

    /**
     * Some, but not all requested data was returned.
     */
    public final static int CLIB_INCOMPLETE_DATA = FACILITY_CLIB + (8*256);

    /**
     * The returned data set contains inconsistent timestamps.  Perhaps some of
     * the data us not related to the rest (taken on other machine cycles).
     */
    public final static int CLIB_INCONSISTENT_TIMES = FACILITY_CLIB + (7*256);

    /**
     * The requested data has not changed.
     */
    public final static int CLIB_NO_CHANGE = FACILITY_CLIB + (6*256);

    /**
     * Additional values are available.
     */
    public final static int CLIB_MORE_VALUES = FACILITY_CLIB + (5*256);

    /**
     * Operation is pending.
     */
    public final static int CLIB_PEND = FACILITY_CLIB + (3*256);

    /**
     * This facility or object is now empty.
     */
    public final static int CLIB_NOW_EMPTY = FACILITY_CLIB + (2*256);

    /**
     * Too many arguments were passed.
     */
    public final static int CLIB_TOO_MANY_ARGS = FACILITY_CLIB + (1*256);

    /**
     * Invalid slot number.  Valid slot numbers are in the range one through
     * six.
     */
    public final static int CLIB_CHGPGM_BADSLOT = FACILITY_CLIB + (-1*256);

    /**
     * No command line buffer is queued.
     */
    public final static int CLIB_GETCMD_NOBUFFER = FACILITY_CLIB + (-2*256);

    /**
     * System error.  An error was detected getting or releasing a VMS lock.
     * This lock is used to wake PLD to process a CHGPGM request.
     */
    public final static int CLIB_CHGPGM_ENQLOCK = FACILITY_CLIB + (-3*256);

    /**
     * Command line buffer locked.  This CHGPGM request cannot be granted
     * because there is either another task waiting to be loaded by PLD for
     * this slot or the command line buffer for the previous program load has
     * not been released.
     */
    public final static int CLIB_CHGPGM_BUFLOCK = FACILITY_CLIB + (-4*256);

    /**
     * The passed page number does not consist of a valid alphabetic index page
     * character and numeric page characters.
     */
    public final static int CLIB_IPP_BADCHAR = FACILITY_CLIB + (-5*256);

    /**
     * Network errors were encountered in the communication with CPLD.
     */
    public final static int CLIB_IPP_NETERR = FACILITY_CLIB + (-6*256);

    /**
     * Remote Procedure Call settings are refused because your console is not a
     * member of the class of consoles allowed to issue an RPC from this
     * program or your setting's lock is locked.  Or, some data acquistion
     * redirection is enabled for this slot.  While data acquisition
     * redirection is enabled, other settings are not allowed.
     */
    public final static int CLIB_PRIV_NORPC = FACILITY_CLIB + (-7*256);

    /**
     * Data is the same as returned by a previous call.
     */
    public final static int CLIB_STALE = FACILITY_CLIB + (-8*256);

    /**
     * No initialization has been done.
     */
    public final static int CLIB_NOINIT = FACILITY_CLIB + (-9*256);

    /**
     * Task does not match.
     */
    public final static int CLIB_PUTCMD_NOTTASK = FACILITY_CLIB + (-10*256);

    /**
     * Invalid argument was passed.
     */
    public final static int CLIB_INVARG = FACILITY_CLIB + (-11*256);

    /**
     * Invalid ID used.
     */
    public final static int CLIB_INVID = FACILITY_CLIB + (-12*256);

    /**
     * Dynamic memory allocation failed.
     */
    public final static int CLIB_MEMFAIL = FACILITY_CLIB + (-13*256);

    /**
     * Requested feature has not been implemented yet.
     */
    public final static int CLIB_NOTYET = FACILITY_CLIB + (-14*256);

    /**
     * Function call timed out.
     */
    public final static int CLIB_TIMEOUT = FACILITY_CLIB + (-15*256);

    /**
     * Duplicate request received.
     */
    public final static int CLIB_DUPREQ = FACILITY_CLIB + (-16*256);

    /**
     * Busy on previous request.
     */
    public final static int CLIB_BUSY = FACILITY_CLIB + (-17*256);

    /**
     * No data exists for this request.
     */
    public final static int CLIB_NO_DATA = FACILITY_CLIB + (-18*256);

    /**
     * Requested featured is not enabled.
     */
    public final static int CLIB_NOT_ENABLED = FACILITY_CLIB + (-19*256);

    /**
     * Required setup call needs to be done first.
     */
    public final static int CLIB_NOSETUP = FACILITY_CLIB + (-20*256);

    /**
     * User abort detected.
     */
    public final static int CLIB_ABORT = FACILITY_CLIB + (-21*256);

    /**
     * The requested object does not exist.
     */
    public final static int CLIB_NO_SUCH = FACILITY_CLIB + (-27*256);

    /**
     * There are already too many objects to create another.
     */
    public final static int CLIB_TOO_MANY = FACILITY_CLIB + (-28*256);

    /**
     * Generic error -- no other error applies.
     */
    public final static int CLIB_GENERIC_ERROR = FACILITY_CLIB + (-29*256);

    /**
     * Invalid size or length requested.
     */
    public final static int CLIB_INVSIZ = FACILITY_CLIB + (-30*256);

    /**
     * Invalid type for requested operation.
     */
    public final static int CLIB_INVTYP = FACILITY_CLIB + (-31*256);

    /**
     * Internal program bug -- contact programmer.
     */
    public final static int CLIB_BUGCHK = FACILITY_CLIB + (-32*256);

    /**
     * Corrupted file or data -- contact programmer.
     */
    public final static int CLIB_CORRUPT = FACILITY_CLIB + (-33*256);

    /**
     * Not enough arguments were passed to a function -- contact programmer.
     */
    public final static int CLIB_INSUFFICIENT_ARGS = FACILITY_CLIB + (-34*256);

    /**
     * This operation is not permitted while some data acquisition and control
     * redirection exists.  Typically, this is an operation that cannot be
     * redirected, i.e. a GAS call, IOMAC call, etc.  Remove all redirection
     * requests for this slot, and retry the operation.
     */
    public final static int CLIB_REDIRECT = FACILITY_CLIB + (-35*256);

    /**
     * Invalid data encountered.
     */
    public final static int CLIB_INVALID_DATA = FACILITY_CLIB + (-36*256);

    /**
     * A required file is not open.
     */
    public final static int CLIB_NOT_OPEN = FACILITY_CLIB + (-37*256);

    /**
     * The result has been truncated.
     */
    public final static int CLIB_TRUNCATED = FACILITY_CLIB + (-38*256);

    /**
     * A syntax error was encountered.
     */
    public final static int CLIB_SYNTAX = FACILITY_CLIB + (-39*256);

    /**
     * Request was too big.
     */
    public final static int CLIB_TOO_BIG = FACILITY_CLIB + (-40*256);

    /**
     * The requested item has been deleted.
     */
    public final static int CLIB_DELETED = FACILITY_CLIB + (-41*256);

    /**
     * An invalid data conversion was requested.
     */
    public final static int CLIB_INVALID_CONVERSION = FACILITY_CLIB + (-42*256);

    /**
     * Data conversion failed.
     */
    public final static int CLIB_CONVERSION_ERROR = FACILITY_CLIB + (-43*256);

    /**
     * Null value supplied.
     */
    public final static int CLIB_NULL_VALUE = FACILITY_CLIB + (-44*256);

    /**
     * Data does not match request.
     */
    public final static int CLIB_MISMATCH = FACILITY_CLIB + (-45*256);

    /**
     * A math exception occurred during a calculation.
     */
    public final static int CLIB_MATH_EXCEPTION = FACILITY_CLIB + (-46*256);

    /**
     * The supplied buffer is too small for the data requested.
     */
    public final static int CLIB_TOO_SMALL = FACILITY_CLIB + (-56*256);

    /**
     * Your request was made in an inappropriate context.
     */
    public final static int CLIB_WRONG_CONTEXT = FACILITY_CLIB + (-57*256);

    /**
     * Specified value is out of range.
     */
    public final static int CLIB_RANGE = FACILITY_CLIB + (-58*256);

    /**
     * No privilege for the requested action
     */
    public final static int CLIB_NOPRIV = FACILITY_CLIB + (-59*256);

    /**
     * Read-only allowed.
     */
    public final static int CLIB_READONLY = FACILITY_CLIB + (-60*256);

    /**
     * An expected value was missing.
     */
    public final static int CLIB_MISSING_VALUE = FACILITY_CLIB + (-61*256);

    /**
     * A value was found when none was expected.
     */
    public final static int CLIB_EXTRANEOUS_VALUE = FACILITY_CLIB + (-62*256);

    /**
     * A parameter (usually an array index) was out of bounds.
     */
    public final static int CLIB_OUT_OF_BOUNDS = FACILITY_CLIB + (-63*256);

    /**
     * A requested setting was not permitted.
     */
    public final static int CLIB_SETLOCK = FACILITY_CLIB + (-64*256);

    /**
     * An empty request was made.
     */
    public final static int CLIB_EMPTY = FACILITY_CLIB + (-65*256);

    /**
     * A calculation error occurred.
     */
    public final static int CLIB_CALC_ERROR = FACILITY_CLIB + (-66*256);

    /**
     * Too few values were supplied.
     */
    public final static int CLIB_TOO_FEW_VALUES = FACILITY_CLIB + (-67*256);

    /**
     * The requested object or service is unavailable.
     */
    public final static int CLIB_UNAVAILABLE = FACILITY_CLIB + (-68*256);

    /**
     * The requested operation is not supported.
     */
    public final static int CLIB_NOT_SUPPORTED = FACILITY_CLIB + (-69*256);

    /**
     * The requested operation is ambiguous.
     */
    public final static int CLIB_AMBIGUOUS = FACILITY_CLIB + (-70*256);

    /**
     * Argument 1 is bad.
     */
    public final static int CLIB_BAD_ARG1 = FACILITY_CLIB + (-71*256);

    /**
     * Argument 2 is bad.
     */
    public final static int CLIB_BAD_ARG2 = FACILITY_CLIB + (-72*256);

    /**
     * Argument 3 is bad.
     */
    public final static int CLIB_BAD_ARG3 = FACILITY_CLIB + (-73*256);

    /**
     * Argument 4 is bad.
     */
    public final static int CLIB_BAD_ARG4 = FACILITY_CLIB + (-74*256);

    /**
     * Argument 5 is bad.
     */
    public final static int CLIB_BAD_ARG5 = FACILITY_CLIB + (-75*256);

    /**
     * Argument 6 is bad.
     */
    public final static int CLIB_BAD_ARG6 = FACILITY_CLIB + (-76*256);

    /**
     * A math overflow occurred during an assignment or calculation.
     */
    public final static int CLIB_MATH_OVERFLOW = FACILITY_CLIB + (-81*256);

    /**
     * An invalid state (condition) was detected.
     */
    public final static int CLIB_INVALID_STATE = FACILITY_CLIB + (-82*256);

    /**
     * There were insufficient resources to satisfy the request.
     */
    public final static int CLIB_INSUFFICIENT_RESOURCES = FACILITY_CLIB + (-83*256);

    /**
     * Clib's 'intype' routines perform initialization tasks on their first
     * execution.   Many clib routines should not be called prior to this
     * initialization.   This error indicates that such a routine was called
     * too early, i.e., before some flavor of 'intype',e.g., window_intype, was
     * called.
     */
    public final static int CLIB_INTYPE_UNINITIALIZED = FACILITY_CLIB + (-84*256);

    /**
     * The requested object is locked.
     */
    public final static int CLIB_LOCKED = FACILITY_CLIB + (-85*256);

    /**
     * The requested object was expected to be constant but is not.
     */
    public final static int CLIB_NOT_CONSTANT = FACILITY_CLIB + (-86*256);

    /**
     * An attempt was made to modify a constant object.
     */
    public final static int CLIB_NOT_MODIFIABLE = FACILITY_CLIB + (-87*256);

    /**
     * A value overflowed its field/buffer.
     */
    public final static int CLIB_OVERFLOW = FACILITY_CLIB + (-88*256);

    /**
     * A reserved word was encountered as a variable name.
     */
    public final static int CLIB_RESERVED_WORD = FACILITY_CLIB + (-89*256);

    /**
     * LOCK facility
     */
    public final static int FACILITY_LOCK = 8;
    public final static int LOCK_OK = 0;
    public final static int LOCK_SUCCESS = 0;

    /**
     * Lock release not needed. This object is not presently locked. This is
     * most likely a programming error.
     */
    public final static int LOCK_NOT = FACILITY_LOCK + (3*256);

    /**
     * Lock request not needed. This object is already locked by you. This is
     * most likely a programming error.
     */
    public final static int LOCK_ALREADY = FACILITY_LOCK + (2*256);

    /**
     * Lock request failed. This object is locked by another task. Find out who
     * this is by using the Lock Browser.
     */
    public final static int LOCK_OTHER = FACILITY_LOCK + (1*256);

    /**
     * Lock release/request failed. An invalid argument has been passed to a
     * function. This is most likely a programming error.
     */
    public final static int LOCK_INVARG = FACILITY_LOCK + (-1*256);

    /**
     * APPDS facility
     */
    public final static int FACILITY_APPDS = 9;
    public final static int APPDS_OK = 0;
    public final static int APPDS_SUCCESS = 0;

    /**
     * Requested table does not exists.
     */
    public final static int APPDS_NOTEXIST = FACILITY_APPDS + (2*256);

    /**
     * Requested table exists.
     */
    public final static int APPDS_EXISTS = FACILITY_APPDS + (1*256);

    /**
     * Memory allocation failure.
     */
    public final static int APPDS_MEMFAIL = FACILITY_APPDS + (-1*256);

    /**
     * Failed to retrieve table information.
     */
    public final static int APPDS_GETFAIL = FACILITY_APPDS + (-2*256);

    /**
     * An invalid argument has been passed to a function.
     */
    public final static int APPDS_INVARG = FACILITY_APPDS + (-3*256);

    /**
     * Failed to set table information.
     */
    public final static int APPDS_SETFAIL = FACILITY_APPDS + (-4*256);

    /**
     * The Application Data Storage Master table has corrupt entries.
     */
    public final static int APPDS_BADMAST = FACILITY_APPDS + (-5*256);

    /**
     * Attempt to add records beyond max record limit for the table.
     */
    public final static int APPDS_MAXREC = FACILITY_APPDS + (-6*256);

    /**
     * Attempt to overwrite records when overwrites are not allowed.
     */
    public final static int APPDS_OVERWRT = FACILITY_APPDS + (-7*256);

    /**
     * Corrupt internal table structure.
     */
    public final static int APPDS_BADSTRUC = FACILITY_APPDS + (-8*256);

    /**
     * Attempt to write to a read only table.
     */
    public final static int APPDS_TBLRO = FACILITY_APPDS + (-9*256);

    /**
     * Failed to convert user data.
     */
    public final static int APPDS_CONFAIL = FACILITY_APPDS + (-10*256);

    /**
     * Attempt to access records beyond the last record entry.
     */
    public final static int APPDS_READEND = FACILITY_APPDS + (-11*256);

    /**
     * Bad record indetifier. A record identifier must be greater than one and
     * less than the maximum record limit for the table.
     */
    public final static int APPDS_BADID = FACILITY_APPDS + (-12*256);

    /**
     * Table is locked and interaction mode changes are not allowed.
     */
    public final static int APPDS_LOCK = FACILITY_APPDS + (-13*256);

    /**
     * SQL statement limit.
     */
    public final static int APPDS_SQLLIMIT = FACILITY_APPDS + (-14*256);

    /**
     * Requested record data overuns given buffer size.
     */
    public final static int APPDS_OVERRUN = FACILITY_APPDS + (-15*256);

    /**
     * DIO facility
     */
    public final static int FACILITY_DIO = 14;
    public final static int DIO_OK = 0;
    public final static int DIO_SUCCESS = 0;

    /**
     * The requested value is not scalable as a floating point number.  This
     * typically is returned if the requested value should be scaled to
     * something like a date, node, or error code string.
     */
    public final static int DIO_NOT_SCALABLE = FACILITY_DIO + (12*256);

    /**
     * The request did not have a unique result.
     */
    public final static int DIO_NOT_UNIQUE = FACILITY_DIO + (11*256);

    /**
     * This value is too high.  This typically occurs when a value is at the
     * high end of the scalable range but is not so high as to be considered
     * invalid. The value is typically clipped to the maximum possible value.
     */
    public final static int DIO_TOO_HIGH = FACILITY_DIO + (10*256);

    /**
     * This value is too low.  This typically occurs when a value is at the low
     * end of the scalable range but is not so low as to be considered invalid.
     * The value is typically clipped to the minimum possible value.
     */
    public final static int DIO_TOO_LOW = FACILITY_DIO + (9*256);

    /**
     * Some, but not all requested data was returned.
     */
    public final static int DIO_INCOMPLETE_DATA = FACILITY_DIO + (8*256);

    /**
     * The returned data set contains inconsistent timestamps.  Perhaps some of
     * the data us not related to the rest (taken on other machine cycles).
     */
    public final static int DIO_INCONSISTENT_TIMES = FACILITY_DIO + (7*256);

    /**
     * The requested data has not changed.
     */
    public final static int DIO_NO_CHANGE = FACILITY_DIO + (6*256);

    /**
     * Additional values are available.
     */
    public final static int DIO_MORE_VALUES = FACILITY_DIO + (5*256);

    /**
     * This object is now empty.
     */
    public final static int DIO_NOW_EMPTY = FACILITY_DIO + (4*256);

    /**
     * No new data is available for this request.
     */
    public final static int DIO_PEND = FACILITY_DIO + (3*256);

    /**
     * An attempt was made to set an object to its current value.  No setting
     * was made.
     */
    public final static int DIO_ALREADY_SET = FACILITY_DIO + (2*256);

    /**
     * Too many arguments were passed.
     */
    public final static int DIO_TOO_MANY_ARGS = FACILITY_DIO + (1*256);

    /**
     * Dynamic memory allocation failed.
     */
    public final static int DIO_MEMFAIL = FACILITY_DIO + (-1*256);

    /**
     * Cancel of a list or single device failed.
     */
    public final static int DIO_CANFAIL = FACILITY_DIO + (-2*256);

    /**
     * Attempted to use a nonexistent list in a list operation.
     */
    public final static int DIO_NOLIST = FACILITY_DIO + (-3*256);

    /**
     * Successful return of data, but it's same as data returned on the
     * previous call. This is because the front-end has not returned new data
     * since the last call. This could be because the front-end is tardy or
     * absent in its reply or that the client is making calls more often than
     * the periodic rate requested from the front-end.  This error is for
     * periodic DAQ not event DAQ.
     */
    public final static int DIO_STALE = FACILITY_DIO + (-4*256);

    /**
     * Requested device attribute does not exist.
     */
    public final static int DIO_INVATT = FACILITY_DIO + (-5*256);

    /**
     * Requested device attribute does not exist for this device.
     */
    public final static int DIO_NOATT = FACILITY_DIO + (-6*256);

    /**
     * No scaling information exists for this device property.
     */
    public final static int DIO_NOSCALE = FACILITY_DIO + (-7*256);

    /**
     * Invalid argument passed to a function.
     */
    public final static int DIO_BADARG = FACILITY_DIO + (-8*256);

    /**
     * Invalid PDB (scaling) data found for this device.
     */
    public final static int DIO_BADSCALE = FACILITY_DIO + (-9*256);

    /**
     * This is not a family device.
     */
    public final static int DIO_NOFAMILY = FACILITY_DIO + (-10*256);

    /**
     * No database-information DIO node found for this device.
     */
    public final static int DIO_NOINFO = FACILITY_DIO + (-11*256);

    /**
     * DBM error occurred for this device.
     */
    public final static int DIO_INVDBDAT = FACILITY_DIO + (-12*256);

    /**
     * Invalid raw data length.
     */
    public final static int DIO_INVLEN = FACILITY_DIO + (-13*256);

    /**
     * Setting attempted with DIO setting inhibited.
     */
    public final static int DIO_SETDIS = FACILITY_DIO + (-14*256);

    /**
     * This stepping motor is off.
     */
    public final static int DIO_SMOFF = FACILITY_DIO + (-15*256);

    /**
     * The number of iterations allowed for setting this stepping motor has
     * been reached.
     */
    public final static int DIO_SMITER = FACILITY_DIO + (-16*256);

    /**
     * The requested object does not exist.
     */
    public final static int DIO_NO_SUCH = FACILITY_DIO + (-17*256);

    /**
     * Desired service is unavailable
     */
    public final static int DIO_UNAVAIL = FACILITY_DIO + (-18*256);

    /**
     * Invalid device specified.
     */
    public final static int DIO_INVDEV = FACILITY_DIO + (-19*256);

    /**
     * Scaling failed.
     */
    public final static int DIO_SCALEFAIL = FACILITY_DIO + (-20*256);

    /**
     * Feature has not been implemented yet.
     */
    public final static int DIO_NOTYET = FACILITY_DIO + (-21*256);

    /**
     * Data does not match request.
     */
    public final static int DIO_MISMATCH = FACILITY_DIO + (-22*256);

    /**
     * There are already too many objects to create another.
     */
    public final static int DIO_TOO_MANY = FACILITY_DIO + (-28*256);

    /**
     * Generic error -- no other error applies.
     */
    public final static int DIO_GENERIC_ERROR = FACILITY_DIO + (-29*256);

    /**
     * Internal program bug -- contact programmer.
     */
    public final static int DIO_BUGCHK = FACILITY_DIO + (-32*256);

    /**
     * Data is corrupted or inconsistent.  If this is returned by the scaling
     * services, it indicates that there was a math exception in scaling the
     * data.  Either the raw data is invalid or the database scaling
     * information is incorrect.
     */
    public final static int DIO_CORRUPT = FACILITY_DIO + (-33*256);

    /**
     * Not enough arguments were passed to a function -- contact programmer.
     */
    public final static int DIO_INSUFFICIENT_ARGS = FACILITY_DIO + (-34*256);

    /**
     * Present data is invalid in this context.
     */
    public final static int DIO_INVDATA = FACILITY_DIO + (-35*256);

    /**
     * Invalid raw data offset.
     */
    public final static int DIO_INVOFF = FACILITY_DIO + (-36*256);

    /**
     * Duplicate request received.
     */
    public final static int DIO_DUPREQ = FACILITY_DIO + (-37*256);

    /**
     * The result has been truncated.
     */
    public final static int DIO_TRUNCATED = FACILITY_DIO + (-38*256);

    /**
     * Syntax error encountered.
     */
    public final static int DIO_SYNTAX = FACILITY_DIO + (-39*256);

    /**
     * A request was made that was too large.
     */
    public final static int DIO_TOO_BIG = FACILITY_DIO + (-40*256);

    /**
     * The requested feature is not enabled.
     */
    public final static int DIO_NOT_ENABLED = FACILITY_DIO + (-41*256);

    /**
     * Requested property is invalid in this context.
     */
    public final static int DIO_INVPROP = FACILITY_DIO + (-42*256);

    /**
     * The request timed out.
     */
    public final static int DIO_TIMEOUT = FACILITY_DIO + (-43*256);

    /**
     * A math exception occurred during a calculation.
     */
    public final static int DIO_MATH_EXCEPTION = FACILITY_DIO + (-46*256);

    /**
     * This entry was not processed.  This can typically happen when a list of
     * devices is being set and there are scaling errors with some of the
     * devices.  This error will be returned for the devices which were
     * otherwise fine but were not set because the entirelist could not be set.
     */
    public final static int DIO_NOT_PROCESSED = FACILITY_DIO + (-47*256);

    /**
     * The service you have requested has been retired.  Please, contact the
     * Accelerator Controls Department to find out about its replacement. You
     * can contact Kevin Cahill (x4669) or Brian Hendricks (x2448) for this
     * information.
     */
    public final static int DIO_RETIRED = FACILITY_DIO + (-48*256);

    /**
     * An invalid data rate was requested.
     */
    public final static int DIO_INVALID_RATE = FACILITY_DIO + (-49*256);

    /**
     * Specified value is out of range.
     */
    public final static int DIO_RANGE = FACILITY_DIO + (-58*256);

    /**
     * No privilege for the requested action
     */
    public final static int DIO_NOPRIV = FACILITY_DIO + (-59*256);

    /**
     * Read-only allowed.
     */
    public final static int DIO_READONLY = FACILITY_DIO + (-60*256);

    /**
     * An empty request was made.
     */
    public final static int DIO_EMPTY = FACILITY_DIO + (-65*256);

    /**
     * The requested operation is not supported.
     */
    public final static int DIO_NOT_SUPPORTED = FACILITY_DIO + (-69*256);

    /**
     * Request was ambiguous
     */
    public final static int DIO_AMBIGUOUS = FACILITY_DIO + (-70*256);

    /**
     * Data value is not a number. (NaN)
     */
    public final static int DIO_NOT_A_NUMBER = FACILITY_DIO + (-71*256);

    /**
     * Recursion limit reached
     */
    public final static int DIO_RECURSION_LIMIT = FACILITY_DIO + (-72*256);

    /**
     * Invalid device type for the requested action
     */
    public final static int DIO_INVALID_DEVICE_TYPE = FACILITY_DIO + (-73*256);

    /**
     * Request is too small
     */
    public final static int DIO_TOO_SMALL = FACILITY_DIO + (-74*256);

    /**
     * Invalid database request was made (possibly includes characters that
     * will cause a SQL syntax error)
     */
    public final static int DIO_INVALID_DB_REQUEST = FACILITY_DIO + (-76*256);

    /**
     * Untranslatable low level error encountered
     */
    public final static int DIO_UNTRANSLATABLE_ERROR = FACILITY_DIO + (-77*256);

    /**
     * Device is not a regular device, i.e., it is a family device.  A regular
     * device is required.
     */
    public final static int DIO_NOREGULAR = FACILITY_DIO + (-78*256);

    /**
     * Unreadable property used in context requiring readable property
     */
    public final static int DIO_SETONLY = FACILITY_DIO + (-79*256);

    /**
     * A parameter (usually an array index) was out of bounds.
     */
    public final static int DIO_OUT_OF_BOUNDS = FACILITY_DIO + (-80*256);

    /**
     * An attempt to set a controlled settable property, e.g., setting or
     * control, from a generic program was made.
     */
    public final static int DIO_CONTROLLED_SET = FACILITY_DIO + (-81*256);

    /**
     * No data exists for this request.
     */
    public final static int DIO_NO_DATA = FACILITY_DIO + (-82*256);

    /**
     * Feature has not been implemented yet.
     */
    public final static int DIO_TD_NOTYET = FACILITY_DIO + (-100*256);

    /**
     * Invalid card type specified.
     */
    public final static int DIO_TD_INVTYP = FACILITY_DIO + (-101*256);

    /**
     * Invalid table number specified.
     */
    public final static int DIO_TD_INVTAB = FACILITY_DIO + (-102*256);

    /**
     * Invalid slot number specified.
     */
    public final static int DIO_TD_INVSLT = FACILITY_DIO + (-103*256);

    /**
     * Invalid number of slots specified.
     */
    public final static int DIO_TD_INVNSL = FACILITY_DIO + (-104*256);

    /**
     * Invalid table device specified.
     */
    public final static int DIO_TD_INVDEV = FACILITY_DIO + (-105*256);

    /**
     * Invalid table size specified.
     */
    public final static int DIO_TD_INVTSZ = FACILITY_DIO + (-106*256);

    /**
     * TD parser returned errors.
     */
    public final static int DIO_TD_PARERR = FACILITY_DIO + (-107*256);

    /**
     * Invalid slot use specified.
     */
    public final static int DIO_TD_INVSUS = FACILITY_DIO + (-108*256);

    /**
     * The requested table type is not supported for the requested device type.
     */
    public final static int DIO_TD_UNSUPPORTED = FACILITY_DIO + (-109*256);

    /**
     * FTP facility
     */
    public final static int FACILITY_FTP = 15;
    public final static int FTP_OK = 0;
    public final static int FTP_SUCCESS = 0;

    /**
     * Snapshot pending, collecting data
     */
    public final static int FTP_COLLECTING = FACILITY_FTP + (4*256);

    /**
     * Snapshot pending, waiting for time delay
     */
    public final static int FTP_WAIT_DELAY = FACILITY_FTP + (3*256);

    /**
     * Snapshot pending, waiting for arm event
     */
    public final static int FTP_WAIT_EVENT = FACILITY_FTP + (2*256);

    /**
     * Snapshot pending
     */
    public final static int FTP_PEND = FACILITY_FTP + (1*256);

    /**
     * Invalid request type code: The request from the console fast time plot
     * manager to the front end can not be decoded.  This is a software problem
     * which should never happen.
     */
    public final static int FTP_INVTYP = FACILITY_FTP + (-1*256);

    /**
     * Invalid SSDN: The SSDN (from the database entry) of one of your
     * requested devices has been rejected by the front end.  You are not going
     * to be able to fast time plot this device.  If you think that this is a
     * mistake somehow, bring it to the attention of an appropriate programmer.
     */
    public final static int FTP_INVSSDN = FACILITY_FTP + (-2*256);

    /**
     * Front end ran out of memory for fast time plots.
     */
    public final static int FTP_FE_OUTOFMEM = FACILITY_FTP + (-5*256);

    /**
     * No more 190/290 card plot channels: Every CAMAC 190 MADC controller is
     * able to fast time plot up to 6 analog channels simultaneously. CAMAC
     * C290 MADC controllers can plot up to 16 channels.  You may have to
     * cancel another competing plot, which might be running on another
     * console.  If you reboot the front end, all plot channels are freed up.
     */
    public final static int FTP_NOCHAN = FACILITY_FTP + (-6*256);

    /**
     * No more 190 card clock decoders: Every CAMAC 190 MADC controller has
     * only 7 decoders for the Tevatron clock.  Various functions on the 190,
     * including certain alarms, data collection, and plotting functions,
     * compete for the 7 clock decoders.  If you reboot the front end, all
     * clock decoders are freed up.
     */
    public final static int FTP_NO_DECODER = FACILITY_FTP + (-7*256);

    /**
     * Front end plot limit exceeded: The particular front end that services
     * the devices you want to plot has reached some limit or other. You may
     * have to stop somebody else's plot.
     */
    public final static int FTP_FE_PLOTLIM = FACILITY_FTP + (-8*256);

    /**
     * Too many, or too few, devices were requested by the console fast time
     * plot manager in its request to the front end.  The front end
     * (ultimately) rejected your plot.  This is a software bug.
     */
    public final static int FTP_INVNUMDEV = FACILITY_FTP + (-9*256);

    /**
     * End of data
     */
    public final static int FTP_ENDOFDATA = FACILITY_FTP + (-10*256);

    /**
     * Front end fast time plot length computation error: The front end, in its
     * attempts to compute the various buffer lengths needed to serve your fast
     * time plot requests, got lost.  It is a bug.
     */
    public final static int FTP_FE_PLOTLEN = FACILITY_FTP + (-11*256);

    /**
     * Invalid request length: The request from the fast time plot manager on
     * the console to the front end got rejected by the front end. This is a
     * bug.
     */
    public final static int FTP_INVREQLEN = FACILITY_FTP + (-12*256);

    /**
     * No data: For CAMAC 190/290 MADC controllers, this means that when the
     * front end tried to read the plot data from the 190/290 controller no
     * data was available.  The front end tries to read this data every 2/15 -
     * 4/15 second.  If the error is transient, the worst that will happen is
     * that you may miss a few points.  If the error is hard, then you probably
     * have a sick 190/290 card. .b This error is expected to happen
     * occasionally on X vs Y plots. Because of a certain amount of buffering
     * in the system, you will usually not even lose any data points.  In order
     * to prevent unnecessary error messages, device data errors are only
     * displayed if they happen twice in succession for a given device.
     */
    public final static int FTP_NO_DATA = FACILITY_FTP + (-13*256);

    /**
     * Invalid snapshot data collection request: The typecode 8 (or 4) snapshot
     * data collection request did not match up with any currently running
     * (typecode 7 or 3) snapshot.  This is a software bug which should never
     * happen.  Bring it to the attention of the applications programmer.  In
     * the case of the detached snapshot manager, this error can result from a
     * front end reboot or a higher priority request replacing the detached
     * snapshot request.
     */
    public final static int FTP_INVREQ = FACILITY_FTP + (-14*256);

    /**
     * Wrong set of events.
     */
    public final static int FTP_BADEV = FACILITY_FTP + (-15*256);

    /**
     * Channel was bumped away by a higher priority channel: We are now running
     * a prioritized version of the FTPMAN process on the front end, and this
     * error is produced if a higher priority plot needs the resources.
     */
    public final static int FTP_BUMPED = FACILITY_FTP + (-16*256);

    /**
     * Reroute problem: This is an error from the inner front end software that
     * shouldn't normally happen. If it does, it means that something is wrong
     * with the front end.
     */
    public final static int FTP_REROUTE = FACILITY_FTP + (-17*256);

    /**
     * Unsupported frequency: This error is produced by the FRIG front end if
     * the desired frequency is not equal to 1 KHz, the only frequency
     * supported by the FRIG snapshot facility.
     */
    public final static int FTP_UNSFREQ = FACILITY_FTP + (-19*256);

    /**
     * Too long of a delay: This error is produced by the FRIG front end if the
     * desired delay is greater then 16.384 seconds.
     */
    public final static int FTP_BIGDLY = FACILITY_FTP + (-20*256);

    /**
     * Unsupported device: This error is produced by the FRIG front end if you
     * try to plot something besides an ADC.
     */
    public final static int FTP_UNSDEV = FACILITY_FTP + (-21*256);

    /**
     * 386 software problems: This error is produced by the FRIG front end in
     * the case of inner software problems.
     */
    public final static int FTP_SOFTWARE = FACILITY_FTP + (-22*256);

    /**
     * Data is not ready: Due to the nature of the FRIG version of the FTPMAN
     * process, one can not access snapshot data if it is not completely
     * collected.
     */
    public final static int FTP_NOTRDY = FACILITY_FTP + (-23*256);

    /**
     * Arcnet communication problem: FRIG system is in fact an ARCNET network,
     * and this error means network communication problems within the the
     * system.
     */
    public final static int FTP_ARCNET = FACILITY_FTP + (-24*256);

    /**
     * Bad arm value: Front end can't translate the arm word received from the
     * console.
     */
    public final static int FTP_BADARM = FACILITY_FTP + (-25*256);

    /**
     * Unsupported frequency: Due to the nature of the hardware used, the front
     * end does not support the requested data collection frequency.
     */
    public final static int FTP_INVFREQ_FOR_HARDWARE = FACILITY_FTP + (-26*256);

    /**
     * Bad plot mode value.
     */
    public final static int FTP_BAD_PLOT_MODE = FACILITY_FTP + (-27*256);

    /**
     * Retrieval device does not exist: The front end can't find the device
     * that was requested for data retrieval.
     */
    public final static int FTP_NO_SUCH_DEVICE = FACILITY_FTP + (-28*256);

    /**
     * Previous rtetrieve request for this device is not done: The front end
     * does not allow more then 1 active retrieval request per device. It means
     * that data for the current retrieval request has to be returned before
     * another one can be issued.
     */
    public final static int FTP_DEVICE_IN_USE = FACILITY_FTP + (-29*256);

    /**
     * Request for data collection with too high of a frequency: The data
     * collection frequency specified in an FTPMAN request is significantly
     * higher than the front end can support.
     */
    public final static int FTP_FREQ_TOO_HIGH = FACILITY_FTP + (-30*256);

    /**
     * Can't find original request: For snapshot retrieval or snapshot restart
     * requests the front end can't find the original snapshot set up request.
     * This can be due to a bookkeeping problem on either the front end or the
     * requestor.
     */
    public final static int FTP_NO_SETUP = FACILITY_FTP + (-31*256);

    /**
     * Unsupported property or undocumented error from MOOC: The code indicates
     * in comments unsupported property.
     */
    public final static int FTP_UNSUPPORTED_PROP = FACILITY_FTP + (-32*256);

    /**
     * Unsupported channel: This error is returned if the channel specified in
     * the SSDN does not exist on the device. Most often this is a database
     * problem
     */
    public final static int FTP_INVALID_CHANNEL = FACILITY_FTP + (-33*256);

    /**
     * No FIFO board: Frig hardware can't support a snapshot plot if the FIFO
     * board is missing.
     */
    public final static int FTP_NO_FIFO = FACILITY_FTP + (-34*256);

    /**
     * Bad data length: The internal length of the data collection in the front
     * end is not equal to 2 or 4. This is usually a bug in the class creation.
     * Call the programmer who maintains this front end.
     */
    public final static int FTP_BAD_DATA_LENGTH = FACILITY_FTP + (-35*256);

    /**
     * Buffer overflow during data collection: This error can occur if the
     * front end is starving out the FTPMAN process. Bring this to the
     * attention of the front end programmer.
     */
    public final static int FTP_BUFFER_OVERFLOW = FACILITY_FTP + (-36*256);

    /**
     * Data collection on event is not supported: The front end does not
     * support data sampling on events for snapshots.
     */
    public final static int FTP_NO_EVENT_SUPPORT = FACILITY_FTP + (-37*256);

    /**
     * Trigger defining problem: There was a problem defining an internal
     * trigger. This should never happen.
     */
    public final static int FTP_TRIGGER_ERROR = FACILITY_FTP + (-38*256);

    /**
     * Wrong internal definition of the continious or snapshot plot class This
     * should never happen.  It is most likely a software bug.
     */
    public final static int FTP_INV_CLASS_DEF = FACILITY_FTP + (-39*256);

    /**
     * Random access to data not yet supported: An attempt has been made to
     * retrieve a block of data using the random access feature, but the front
     * end does not yet support this feature.  This is most likely a software
     * bug.
     */
    public final static int FTP_NO_RANDOM_ACCESS = FACILITY_FTP + (-40*256);

    /**
     * Invalid offset specified: The frontend does not yet support non-zero
     * offsets to data.  This is most likely a software bug.
     */
    public final static int FTP_INVALID_OFFSET = FACILITY_FTP + (-41*256);

    /**
     * This device does not support snapshot plots.
     */
    public final static int FTP_NO_SNAPSHOT = FACILITY_FTP + (-42*256);

    /**
     * The requested clock event is not available.  Some front ends do not
     * decode all clock events.  Contact the front end programmer for the
     * requested device for more information.
     */
    public final static int FTP_EVENT_UNAVAILABLE = FACILITY_FTP + (-43*256);

    /**
     * FTPMAN has not been properly initialized.  Some front ends (ex. LabView)
     * require an initial plot class code request to initialize.
     */
    public final static int FTP_NO_FTPMAN_INIT = FACILITY_FTP + (-44*256);

    /**
     * Bad console UCD module timestamps: The timestamp as read from THIS
     * CONSOLE's UCD module does not agree with the 15 Hz tick count since the
     * last occurence of clock event 02.  Plot timing  may be screwed up.  This
     * error is displayed a maximum of once per plot startup.  Try doing a
     * 'Reset UCD FIFO' on page D48 or boot the console. The UCD module may be
     * in a strange mode. If that doesn't work, replace the UCD module. If this
     * error occurs on all consoles, it is probably due to clock event 02 not
     * being generated properly.  Clock event 02 should occur every 5 seconds.
     */
    public final static int FTP_BADTIMES = FACILITY_FTP + (-100*256);

    /**
     * Bad timestamp reset for device: The timestamp for a device did not go to
     * zero when it was supposed to. Plot timing may be screwed up for this
     * device.  This problem is known to occur on some C190 modules.  If it
     * happens a lot, you may want to replace the C190 module.  You can find
     * out which crate and slot the C190 module for a device is in by starting
     * a plot on page D48 with the 'Display Device Summary' diagnostic turned
     * 'ON' or by looking at the reading property information on page D80.
     */
    public final static int FTP_BADRESETS = FACILITY_FTP + (-101*256);

    /**
     * Bad argument in message to fast time plot application: The FTP SA
     * (SA1002) has received an invalid argument in an ACNET request.
     */
    public final static int FTP_BADARG = FACILITY_FTP + (-102*256);

    /**
     * Bad reply from a front end: The reply from a front end which should
     * contain device plot data does not look like a valid reply.  For example
     * error codes may be wrong or it may claim there are more points than will
     * fit in the reply.
     */
    public final static int FTP_BADRPY = FACILITY_FTP + (-103*256);

    /**
     * DBM facility
     */
    public final static int FACILITY_DBM = 16;
    public final static int DBM_OK = 0;
    public final static int DBM_SUCCESS = 0;

    /**
     * This device is being retained for documentation purposes only.  This is
     * done to allow access to data logger and save file data for otherwise
     * obsolete devices.  This is sometimes done to handle devices for portions
     * of the accelerator complex that have been retired.
     */
    public final static int DBM_DOCDEV = FACILITY_DBM + (4*256);

    /**
     * No data returned for this request packet (maybe a result of DBSET).
     */
    public final static int DBM_NODATA = FACILITY_DBM + (2*256);

    /**
     * DBM operation pending. (asynchronous operation)
     */
    public final static int DBM_PEND = FACILITY_DBM + (1*256);

    /**
     * General DBM error.
     */
    public final static int DBM_GENERR = FACILITY_DBM + (-1*256);

    /**
     * RMS-detected disk error.
     */
    public final static int DBM_RMSE = FACILITY_DBM + (-2*256);

    /**
     * Attempt to access deleted device.
     */
    public final static int DBM_DELDEV = FACILITY_DBM + (-3*256);

    /**
     * Attempt to access obsolete device.
     */
    public final static int DBM_OBSDEV = FACILITY_DBM + (-4*256);

    /**
     * Not enough room in reply list.
     */
    public final static int DBM_FULL = FACILITY_DBM + (-5*256);

    /**
     * Inconsistent property and function.
     */
    public final static int DBM_INCON = FACILITY_DBM + (-6*256);

    /**
     * Illegal device index.
     */
    public final static int DBM_ILDEV = FACILITY_DBM + (-7*256);

    /**
     * Illegal function.
     */
    public final static int DBM_ILFN = FACILITY_DBM + (-8*256);

    /**
     * Illegal property code.
     */
    public final static int DBM_ILPROP = FACILITY_DBM + (-9*256);

    /**
     * Illegal request header.
     */
    public final static int DBM_ILHEAD = FACILITY_DBM + (-10*256);

    /**
     * Illegal property for compound device.
     */
    public final static int DBM_IPCD = FACILITY_DBM + (-11*256);

    /**
     * Wrong device/property record combination retrieved from database. (This
     * is a re-tryable error.)
     */
    public final static int DBM_WDPR = FACILITY_DBM + (-12*256);

    /**
     * No such property for device.
     */
    public final static int DBM_NOPROP = FACILITY_DBM + (-13*256);

    /**
     * Packet overflows request list.
     */
    public final static int DBM_RLOV = FACILITY_DBM + (-14*256);

    /**
     * Not enough arguments in UTI routine call.
     */
    public final static int DBM_NEAG = FACILITY_DBM + (-15*256);

    /**
     * Illegal IRINX specified.
     */
    public final static int DBM_ILRINX = FACILITY_DBM + (-16*256);

    /**
     * Illegal work area.
     */
    public final static int DBM_ILWORK = FACILITY_DBM + (-17*256);

    /**
     * Work area full.
     */
    public final static int DBM_WORK_FULL = FACILITY_DBM + (-18*256);

    /**
     * Attempt to call DBPROC on empty work area.
     */
    public final static int DBM_EMPTY = FACILITY_DBM + (-19*256);

    /**
     * No database record exists for this request.
     */
    public final static int DBM_NOREC = FACILITY_DBM + (-20*256);

    /**
     * This console is not a member of the classes of consoles allowed to set
     * with this application.  The index page displays run and set protections
     * of the applications by class.
     */
    public final static int DBM_NOSET = FACILITY_DBM + (-21*256);

    /**
     * Setting request too large.
     */
    public final static int DBM_SRTL = FACILITY_DBM + (-22*256);

    /**
     * Setting not forwarded.
     */
    public final static int DBM_NOFORWARD = FACILITY_DBM + (-23*256);

    /**
     * Timeout Error.
     */
    public final static int DBM_TMO = FACILITY_DBM + (-24*256);

    /**
     * Settings are currently locked out on this console.  The settings' lock
     * is unlocked using the utility window.
     */
    public final static int DBM_LOCK = FACILITY_DBM + (-25*256);

    /**
     * DPM facility
     */
    public final static int FACILITY_DPM = 17;
    public final static int DPM_OK = 0;
    public final static int DPM_SUCCESS = 0;

    /**
     * The list of devices is suspiciously large. There is, most likely, a
     * resource leak in the application.
     */
    public final static int DPM_LARGE_LIST = FACILITY_DPM + (3*256);

    /**
     * The data was returned more than a clock cycle (15Hz) late. If you are
     * trying to correlate data, this point may be suspect.
     */
    public final static int DPM_STALE = FACILITY_DPM + (2*256);

    /**
     * Request is pending.  Your request has been successfully sent to a front
     * end.  No data has come back yet from that request.
     */
    public final static int DPM_PEND = FACILITY_DPM + (1*256);

    /**
     * The application is restarting the data acquisition faster than the data
     * can be collected. This is a bug in the application.
     */
    public final static int DPM_RESTART_TOO_FAST = FACILITY_DPM + (-1*256);

    /**
     * Invalid function code.
     */
    public final static int DPM_INVFCN = FACILITY_DPM + (-2*256);

    /**
     * Invalid IRINX; does not point to a Common Request List entry.
     */
    public final static int DPM_INVRINX = FACILITY_DPM + (-3*256);

    /**
     * Invalid IRINX; Common Request List entry belongs to another task.
     */
    public final static int DPM_IVRXNM = FACILITY_DPM + (-4*256);

    /**
     * IRINX for this Common Request List entry has not been processed.
     */
    public final static int DPM_NOTPROC = FACILITY_DPM + (-5*256);

    /**
     * Common Request List entry is marked for deletion.
     */
    public final static int DPM_MARKDELET = FACILITY_DPM + (-6*256);

    /**
     * DPGET 'maxlen' is too big.
     */
    public final static int DPM_MXLBIG = FACILITY_DPM + (-7*256);

    /**
     * Error in offset or length.
     */
    public final static int DPM_OFFLEN = FACILITY_DPM + (-8*256);

    /**
     * DPM is out of memory.
     */
    public final static int DPM_OUTOMEM = FACILITY_DPM + (-9*256);

    /**
     * Timeout on setting reply from front end.
     */
    public final static int DPM_TMOSET = FACILITY_DPM + (-10*256);

    /**
     * Requested length is too small.
     */
    public final static int DPM_LENSML = FACILITY_DPM + (-11*256);

    /**
     * DPM system error; DBM or SMLDPM is down.
     */
    public final static int DPM_DPMSER = FACILITY_DPM + (-12*256);

    /**
     * Illegal Frequency Time Descriptor; faster than 15 hertz.
     */
    public final static int DPM_ILLFTD = FACILITY_DPM + (-13*256);

    /**
     * Setting is longer than one packet.
     */
    public final static int DPM_SETBIG = FACILITY_DPM + (-14*256);

    /**
     * Setting not allowed from this console.
     */
    public final static int DPM_NOSET = FACILITY_DPM + (-15*256);

    /**
     * Settings are currently locked out of this console.  Settings are often
     * disabled to prevent accidental settings.  Bring up the utility window
     * using the UTIL key and attempt to unlock the console, then try your
     * setting again.  Relock the console when you are done.
     */
    public final static int DPM_SETLOCK = FACILITY_DPM + (-16*256);

    /**
     * Settings are not allowed for this application by console class. Each
     * console is a member of one or more console classes.  Each application
     * has a mask defining what console classes may perform settings.  The
     * index page has menu entries describing console classes. If this error
     * code is used by an UPLINK program, the error could also be caused by the
     * setting's lock being locked.
     */
    public final static int DPM_PRIV = FACILITY_DPM + (-17*256);

    /**
     * Settings are not allowed for this device by a console of this class.
     * Each device has a database field specifying the classes of consoles
     * allowed to set the device.  Each console is a member of a class of
     * consoles that describe how the console is typically used.  Your console
     * is not a member of the class of consoles allowed to set this device.
     */
    public final static int DPM_DBPRIV = FACILITY_DPM + (-18*256);

    /**
     * Data acquistion and control redirection is not allowed on this console.
     * Check the 'No Redirect' and 'Redirect Ok' field on the utility window.
     * The datapool manager accepts redirection requests only when this field
     * is in the state 'Redirect Ok'.
     */
    public final static int DPM_REDIRECT = FACILITY_DPM + (-19*256);

    /**
     * Mixed redirected and unredirected settings are not allowed in a single
     * setting flush.  i.e. one cannot queue a setting to a true front end and
     * a setting to a model and flush the settings.  This error is intended to
     * prevent accidental settings and could be renegotiated.
     */
    public final static int DPM_WHACKEDSETS = FACILITY_DPM + (-20*256);

    /**
     * The datapool request for default length cannot be satisfied since this
     * device/property's default size is not one, two, or four bytes. A default
     * reading request return can only assume the user has allocated a four
     * byte memory location for the return, and returning a default size
     * greater than four bytes may cause memory corruption, hence this error
     * return.
     */
    public final static int DPM_NODEFAULT = FACILITY_DPM + (-21*256);

    /**
     * The process has several duplicate device index, property, length, offset
     * requests.  The most recent duplicate is marked for delete while
     * generating this error to prevent a single process from starving other
     * console instances and processes.
     */
    public final static int DPM_DUPLICATES = FACILITY_DPM + (-22*256);

    /**
     * The front end is not receiving TCLK events for some reason.
     */
    public final static int DPM_NO_TCLK = FACILITY_DPM + (-23*256);

    /**
     * The DPM service didn't understand the request.
     */
    public final static int DPM_BAD_REQUEST = FACILITY_DPM + (-24*256);

    /**
     * Unable to lookup device info for the given request.  This will happen if
     * no LOOKUP service can be found.
     */
    public final static int DPM_LOOKUP_FAILED = FACILITY_DPM + (-25*256);

    /**
     * The requested device was invalid.
     */
    public final static int DPM_NO_SUCH_DEVICE = FACILITY_DPM + (-26*256);

    /**
     * The requested property is not defined for the requested device.
     */
    public final static int DPM_NO_SUCH_PROP = FACILITY_DPM + (-27*256);

    /**
     * Invalid array range.
     */
    public final static int DPM_BAD_RANGE = FACILITY_DPM + (-28*256);

    /**
     * Array range is out of bounds for the given device.
     */
    public final static int DPM_OUT_OF_BOUNDS = FACILITY_DPM + (-29*256);

    /**
     * Raw data array range is not a multiple of the requested device's atomic
     * size.
     */
    public final static int DPM_BAD_FRAMING = FACILITY_DPM + (-30*256);

    /**
     * Scaling is not supported for the requested device.
     */
    public final static int DPM_NO_SCALE = FACILITY_DPM + (-31*256);

    /**
     * Invalid DRF field specifier.
     */
    public final static int DPM_NO_SUCH_FIELD = FACILITY_DPM + (-32*256);

    /**
     * Invalid DRF event format.
     */
    public final static int DPM_BAD_EVENT = FACILITY_DPM + (-33*256);

    /**
     * The requested device does not have a valid default event.
     */
    public final static int DPM_BAD_DEF_EVENT = FACILITY_DPM + (-34*256);

    /**
     * Bad data length for requested device.
     */
    public final static int DPM_BAD_LENGTH = FACILITY_DPM + (-35*256);

    /**
     * Scaling for requested device has failed.
     */
    public final static int DPM_SCALING_FAILED = FACILITY_DPM + (-36*256);

    /**
     * The given list id was not found.
     */
    public final static int DPM_NO_SUCH_LIST = FACILITY_DPM + (-37*256);

    /**
     * DPM Service Not Found.
     */
    public final static int DPM_SERVICE_NOT_FOUND = FACILITY_DPM + (-38*256);

    /**
     * The user requested data from DPM in a format for which they did not
     * provide the appropriate DPM::List callback.
     */
    public final static int DPM_CALLBACK_NOT_FOUND = FACILITY_DPM + (-39*256);

    /**
     * The user requested data from a device which has been marked as a
     * documentation device.  This type of device is useful for looking at
     * historic device information, but cannot be used to retrieve live data.
     */
    public final static int DPM_DOC_DEVICE = FACILITY_DPM + (-40*256);

    /**
     * Gets32 data acquisition is presently disabled.  Options like reading
     * devices on event plus delay or on a state transition will not be
     * possible. This functionality can presently be enabled and disabled via
     * the console utility window or through the use of system logicals.
     */
    public final static int DPM_GETS32_DISABLED = FACILITY_DPM + (-41*256);

    /**
     * The datasource provided for a request is not valid.
     */
    public final static int DPM_INVALID_DATASOURCE = FACILITY_DPM + (-42*256);

    /**
     * The fields provided with a datasource are incorrect.
     */
    public final static int DPM_BAD_DATASOURCE_FORMAT = FACILITY_DPM + (-43*256);

    /**
     * The reply for the given request is too big to be sent. Try splitting up
     * the request into smaller replies.
     */
    public final static int DPM_REPLY_OVERFLOW = FACILITY_DPM + (-44*256);

    /**
     * CAMAC_FE facility
     */
    public final static int FACILITY_CAMAC_FE = 18;
    public final static int CAMAC_FE_OK = 0;
    public final static int CAMAC_FE_SUCCESS = 0;

    /**
     * Data pending: If this error persists, something should be rebooted.
     */
    public final static int CAMAC_FE_PEND = FACILITY_CAMAC_FE + (1*256);

    /**
     * No-Q: A simple No-Q response from a CAMAC module: This error is returned
     * as a result of a failed ordinary CAMAC function when the module was
     * always supposed to return Q.  Some modules require that a command be
     * tried several times before Q is returned.  In such cases, this error is
     * generated only after the last possible retry has failed. GAS speaking
     * modules, 080 and 170 cards, sometimes use Q as a form of communication
     * with the front end communication software.  In these cases, the front
     * end has special errors -15 and -16. For some microprocessor based cards
     * (such as 190 MADC controllers and 057 stepping motor controllers), this
     * error means that the card needs to be reset.
     */
    public final static int CAMAC_FE_NOQ = FACILITY_CAMAC_FE + (-1*256);

    /**
     * No-X: The CAMAC module is not acknowledging CAMAC function codes.
     * Usually this means that you are addressing the wrong slot or the module
     * is unplugged or not installed yet.  It can also indicate that you
     * entered the wrong crate or slot in a database entry.  If you are
     * addressing a GAS speaking device the 'crates and slots' pages may fix
     * it.  If you suspect a hardware problem note that this error means that
     * the crate controller cycled successfully and the problem is likely to be
     * in the CAMAC card itself.
     */
    public final static int CAMAC_FE_NOX = FACILITY_CAMAC_FE + (-2*256);

    /**
     * Arbitration conflict: The CAMAC crate controller arbitrates between
     * several competing uses of the same crate.  This error means that a CAMAC
     * command could not be completed because of an arbitration conflict. .b
     * The competing uses are: the block transfer function, normal port-A
     * (front end) operation, and normal port-B operation.  Port-B is used by
     * the special PAUX front end.  It is also used by the ancient RLI units.
     * .b When the front end is using block transfer this error will occur
     * occasionally, and it is harmless.  Almost all CAMAC operations are
     * retried until they succeed, except that you will occasionally see this
     * error flash up on an analog reading. .b It is also possible that the
     * front end was not able to break through a port-B reserve on the
     * CAMACcrate or slot containing the card you are trying to address.  This
     * should never happen because the front end is supposed to be able to
     * break through any port-B operation.  In any case, port-B operation is
     * non-existent in most of our crates.
     */
    public final static int CAMAC_FE_ARBCON = FACILITY_CAMAC_FE + (-3*256);

    /**
     * No SRP, but not arbitration conflict: The CAMAC crate dataway did not
     * cycle, but this was not due to a port B reserve.  This error should not
     * happen.  It probably indicates a bad crate controller or a bad link
     * driver.
     */
    public final static int CAMAC_FE_NOSRP = FACILITY_CAMAC_FE + (-4*256);

    /**
     * Timeout by link driver: The link driver hardware got tired (75 us, it
     * tires quickly) of waiting for the serial CAMAC bits to go out to the
     * crate controller and back again.  Common possibilities are: 1) crate
     * power is off, 2) the power is off somewhere and the signal isn't being
     * repeated all the way, 3) a repeater (in those half high NIM bins) is
     * dead, 4) you are accessing a crate address that isn't there, 5) you are
     * talking to the wrong front end, either because the ACNET logical node
     * tables are screwed up or because your database entry is screwed up, and
     * the crate you are addressing is not attached to the computer you
     * reached.  (This is more common than it sounds, it happens after you
     * switch front end processors) 6) the cables are unplugged (or incorrectly
     * plugged) in the computer room CAMAC link patch panel.  (Also a
     * consequence of switching processors), 7) the PIOX control line has
     * become disabled.  Try re-enabling it. P.S. The easy way to recognize the
     * problem with a repeater being powered off is to look at the crate map on
     * page D20.
     */
    public final static int CAMAC_FE_TIMEOUT = FACILITY_CAMAC_FE + (-5*256);

    /**
     * CAMAC response frame protocol error: The frames returned on the serial
     * link contain framing and parity bits.  The link driver hardware
     * generates an error if they are erroneous.  The problem almost has to be
     * either: 1) a crate controller returning bad frames, 2) an arbitrary
     * crate controller placing unwanted bits on the link which collide with
     * the good frames and/or confuse the link driver (common after a power
     * outage), 3) a repeater is mangling bits, 4) somebody set the address
     * switches incorrectly on a recently installed crate controller and two
     * different crates are responding simultaneously to some commands, 5) the
     * link driver has a problem. One good thing to try, especially after a
     * power outage, is a RESET from a parameter page on one of the
     * followingdevices: T:PIOXON - Tevatron front end, S:PIOXON - Switchyard
     * front end, I:PIOXON - Main Injector front end, B:PIOXON - Booster front
     * end, A:PIOXON - P-bar front end, and Z:PIOXON - development front end.
     * Repeaters sometimes require alignment when they are installed, so it is
     * a good idea to call a controls hardware jock if you want to replace one.
     * If this error persists, call one of the CAMAC experts.
     */
    public final static int CAMAC_FE_PROTERR = FACILITY_CAMAC_FE + (-6*256);

    /**
     * Echo error in a response frame: Some bits sent out by the link driver
     * are echoed back by the responding crate controller.  If the response
     * does not match the transmitted bits, this error is signaled.  The
     * possible problems are the same as for error -006:protocol error.
     */
    public final static int CAMAC_FE_ECHOERR = FACILITY_CAMAC_FE + (-7*256);

    /**
     * Other link error: The link driver has an 'operation OK' status bit and
     * also several error status bits.  If it does not raise 'OK', but it also
     * doesn't raise any error bits, error -8 is reported.  There are several
     * obscure reasons, involving sick crate controllers or repeaters, this can
     * happen.  See error -006 for more info.
     */
    public final static int CAMAC_FE_LINKERROR = FACILITY_CAMAC_FE + (-8*256);

    /**
     * Link driver indefinitely busy: The link driver busy bit does not clear
     * in the 150 microseconds or so that the front end gives it.  It is
     * generally caused by a sick link driver.
     */
    public final static int CAMAC_FE_LINKBUSY = FACILITY_CAMAC_FE + (-9*256);

    /**
     * CAMAC link reserved for diagnostics: It is possible to turn off access
     * to the CAMAC link so that the hardware experts can debug problems
     * without a lot of link traffic.  While access is turned off, only certain
     * diagnostic pages will work (e.g. the CAMAC test page) and everybody else
     * will get this error. .b Diagnostic mode on / off control is provided on
     * any parameter page by the following devices: T:PIOXON - Tevatron front
     * end, S:PIOXON - Switchyard front end, I:PIOXON - Main Injector front
     * end, B:PIOXON - Booster front end, A:PIOXON - P-bar front end, and
     * Z:PIOXON - development front end.
     */
    public final static int CAMAC_FE_LINKRESERVED = FACILITY_CAMAC_FE + (-10*256);

    /**
     * GAS house code out of range: House codes must be between 1 and 42.
     * Either the database entry or the 'crates and slots' page is incorrect.
     * UPGAS users take note: you might well have passed a bad house code in a
     * call to a GSxxxx routine.
     */
    public final static int CAMAC_FE_INVHC = FACILITY_CAMAC_FE + (-11*256);

    /**
     * GAS module type out of range: Module types must be between 1 and 6.
     * Most likely the database entry is incorrect.  UPGAS users take note: you
     * might well have passed a bad module type in a call to a GSxxxx routine.
     */
    public final static int CAMAC_FE_INVGASTYPE = FACILITY_CAMAC_FE + (-12*256);

    /**
     * Invalid GAS function requested:  This almost has to be a bug within the
     * front end computer.  The GAS handler program has rejected a request from
     * another program within the front end.
     */
    public final static int CAMAC_FE_INVGASFUNC = FACILITY_CAMAC_FE + (-13*256);

    /**
     * Unequipped GAS module:  The 'crates and slots' table contains a zero
     * entry for the particular module you requested.  This can be fixed with
     * the crates and slots pages (although your change will only be effective
     * until the next reboot).  Permanent changesrequire a change to the
     * startup script --please see a front end programmer.
     */
    public final static int CAMAC_FE_UNEQUIPPED = FACILITY_CAMAC_FE + (-14*256);

    /**
     * No-Q on initial F(20) despite all efforts: GAS speaking modules have
     * clear down sequences that can be performed when the initial CAMAC F(20)
     * returns NO-Q. When, even after clearing down, the initial F(20) still
     * doesn't work, you get this error.  You can retry the command.  If that
     * fails, you can reboot the module.  If that fails, you can go out to the
     * service building and cycle the CAMAC crate power and, for 080 based
     * modules, the Multibus crate power.  Finally you start changing out the
     * 080 or 170 CAMACcard and/or the processor card in the Multibus crate.
     */
    public final static int CAMAC_FE_F20NOQ = FACILITY_CAMAC_FE + (-15*256);

    /**
     * No-Q after many retries on F(0), F(16), or F(22): You get this error
     * when the GAS speaking module refuses to accept or transmit data.  The
     * symptom is repeated NO-Q responses on the data transfer CAMAC commands.
     * Note that to get this error the initial F(20) must have eventually
     * succeeded.  Common causes of this error are: 1) this is a new hardware
     * installation, and it doesn't work yet, 2) the smart module software is
     * confused and needs to be rebooted, 3) you are asking for more data than
     * your STANC specified, 5) the STANC you sent is valid, but it is not what
     * you think it is. This error tends to be the one you get when you install
     * a new smart module and the cable to the 080 is screwed up, or the
     * processor card is bad, and so on. The last two possibilitiesmean that
     * your database entry may be incorrect. If all else fails, try the error
     * recovery procedures listed for error-15.
     */
    public final static int CAMAC_FE_GASNOQ = FACILITY_CAMAC_FE + (-16*256);

    /**
     * Front end internal GAS queue overflow: This is a front end bug that
     * should never happen. The GAS handler program is supposed to stop
     * accepting input when its internal queues fill up.  If the error
     * persists, contact the appropriate front end programmer. This error is a
     * relic of the old 386-based front end, and should never occur on current
     * CAMAC front ends.
     */
    public final static int CAMAC_FE_GASQUEUE = FACILITY_CAMAC_FE + (-17*256);

    /**
     * Too many lists for one GAS speaking module: Each module supports 32
     * lists of items to be collected.  The front end software restricts them
     * to 31 per module. This error occurs when the front end computer's count
     * of lists for a module exceeds 31.  Try to stop some running lists, e.g.
     * by stopping a plot or leaving a parameter page.  If that doesn't work,
     * contact the appropriate front end programmer. This error is a relic of
     * the old 386-based front end, and should never occur on current CAMAC
     * front ends.
     */
    public final static int CAMAC_FE_LISTOVF = FACILITY_CAMAC_FE + (-18*256);

    /**
     * GAS speaking module can't take it: When the front end tries to send data
     * to a GAS speaking module, or tries to set up a list for periodic data
     * collection, there is a certain amount of handshaking that goes on.  The
     * module is given the opportunity to say that it cannot accept the setting
     * or the list, usually because of space problems.  Thus this error.  The
     * solution is to cancel some running lists, such as a parameter page that
     * is talking to that module.  If the error occurs during setting
     * operations, it is likely that you are trying to send to the module too
     * much too fast.  It is also possible that you are sending too much data
     * in one chunk.  Finally, it is barely possible that there is some crud
     * hanging around taking up dynamic memory that will be cleaned up if you
     * reboot the GAS speaking module.
     */
    public final static int CAMAC_FE_OUTOMEM = FACILITY_CAMAC_FE + (-19*256);

    /**
     * Gave up trying to check for error -19: The front end and the GAS
     * speaking module go through a handshaking process on list setup and set
     * commands.  The result of this process can be either a 'go ahead' or an
     * error -19.  If the front end never makes it through the handshaking,
     * because the smart module is not responding, then you get an error -20.
     * The first thing to do is to retry. The next is to reboot the smart
     * module.  Then see the instructions for error -15.
     */
    public final static int CAMAC_FE_HANDFAIL = FACILITY_CAMAC_FE + (-20*256);

    /**
     * Trying to set or read a negative number of bytes: You are trying to send
     * or read -35 (or some other absurd number) of bytes from a GAS speaking
     * module. This is not permitted.  It is usually an application software
     * problem.  Note that a zero byte long setting is OK in some instances.
     */
    public final static int CAMAC_FE_NEGBYTCNT = FACILITY_CAMAC_FE + (-21*256);

    /**
     * No STANCS in a list setup request: The GAS handler in the front end has
     * received a request to set up a list of data to be periodically
     * collected, but there are no items in this list.  This is almost
     * certainly an applications software problem.  The problem might be within
     * front end software. This error is a relic of the old 386-based front end
     * and should never occur on the current CAMAC front ends.
     */
    public final static int CAMAC_FE_NOSTANCS = FACILITY_CAMAC_FE + (-22*256);

    /**
     * GAS speaking module returned invalid error code: Your basic choice is to
     * reboot the smart module.  If that fails, replace the 170 CAMAC card or
     * the Multibus processor card.
     */
    public final static int CAMAC_FE_INVGASERROR = FACILITY_CAMAC_FE + (-23*256);

    /**
     * GAS speaking module marked out service: The 'crates and slots' table
     * shows that this GAS-speaking module is out of service for a while.  You
     * can put it back in service on the crates and slots pages. Note that it
     * is possible for a module to be AUTOMATICALLY put out of service by the
     * front end.
     */
    public final static int CAMAC_FE_OUTOSERVICE = FACILITY_CAMAC_FE + (-24*256);

    /**
     * GAS list ID out of range: This is an error internal to the front end
     * computer. If this error persists, contact the appropriate front end
     * programmer. This error is a relic of the old 386-based front end and
     * should never occur on the current CAMAC front ends.
     */
    public final static int CAMAC_FE_OUTORANGE = FACILITY_CAMAC_FE + (-25*256);

    /**
     * There are too many GAS wild card reads at one time. This error is a
     * relic of the old 386-based front end and should never occur on the
     * current CAMAC front ends.
     */
    public final static int CAMAC_FE_TOOMANYWC = FACILITY_CAMAC_FE + (-26*256);

    /**
     * Internal error in GAS wild card read request: A serious error occurred
     * during a wild card read request.  At the present time, this error can
     * only occur because the front end timed out waiting for all houses to
     * respond to a wild card read.  To make wild card reads go faster, the
     * front end spawns a separate task for each house.  After a long time, the
     * front end gives up if one (or more) of these tasks have not responded
     * with status.  Hopefully this will never occur, because a tardy task
     * could cause corruption in the front end, which would necessitate a front
     * end reboot.
     */
    public final static int CAMAC_FE_GASWCERROR = FACILITY_CAMAC_FE + (-27*256);

    /**
     * Frig plot at 15 Hz: The front end rejects attempts to plot refrigerator
     * devices at 15 Hz.  This is because the refrigerator microprocessor
     * updates its data pool only every 2 seconds.  Since there is no
     * particular reason to combine a frig plot with a 15 Hz plot, and since
     * fast frig plots are an expensive way to examine readings that change
     * only every 2 seconds, they are not allowed. This error is a relic of the
     * old 386-based front end and should never occur on the current CAMAC
     * front ends.
     */
    public final static int CAMAC_FE_PLOTTOOFAST = FACILITY_CAMAC_FE + (-28*256);

    /**
     * 080 Transaction timeout: 080 is timing out on read or write to
     * Multibus-I crate.  Most often this is a Multibus-I problem.  It can also
     * be cabling to Multibus-I problems.  Try rebooting Multibus-I crate.
     */
    public final static int CAMAC_FE_080_TIMEOUT = FACILITY_CAMAC_FE + (-29*256);

    /**
     * STANC byte count over the limit: A GAS list setup was attempted in which
     * the total number of bytes to be returned failed a sanity check.
     */
    public final static int CAMAC_FE_GAS_TOO_LARGE = FACILITY_CAMAC_FE + (-30*256);

    /**
     * GAS setting verification error: Special code exists in the front end to
     * perform a read-back verification in certain cases.  This error is
     * generated because the verification failed, and no other error was
     * detected.  The problem almost certainly has to be in the smart module.
     * The application program may want to retry the failed operation.
     */
    public final static int CAMAC_FE_GAS_SET_VERIFY = FACILITY_CAMAC_FE + (-31*256);

    /**
     * GAS list read of an undefined list: You are trying to read a list that
     * the GAS-speaking module is unaware of.  This usually happens when you
     * set up a list for periodic data return and sometime later the list goes
     * away.  Usually this means the smart module has rebooted.   The solution
     * is to retry the list (reenter the page, restart the plot, etc.).  If
     * that doesn't work, try rebooting the GAS-speaking module, and then
     * reenter your page.  If this error still occurs, contact the appropriate
     * front end programmer.
     */
    public final static int CAMAC_FE_UNDEFINED = FACILITY_CAMAC_FE + (-40*256);

    /**
     * GAS list setup failed: For whatever the reason, the GAS-speaking module
     * is not going to give you your periodic data.  First, try cancelling a
     * few users.  The problem can be a bad STANC, which in general will mean a
     * fouled up database entry.  You might also try rebooting the GAS-speaking
     * module.  If the error persists, contact the appropriate front end
     * programmer.
     */
    public final static int CAMAC_FE_SETUPFAIL = FACILITY_CAMAC_FE + (-41*256);

    /**
     * GAS read request failed: This is probably a sick database entry. If you
     * believe that your applications software is in fact sending a good STANC,
     * try rebooting the GAS-speaking module.  If that doesn't work, contact
     * the appropriate front end programmer orthe console application
     * programmer.
     */
    public final static int CAMAC_FE_GASREQFAIL = FACILITY_CAMAC_FE + (-42*256);

    /**
     * GAS list read of a list not yet updated with data: If you were doing
     * some kind of one-shot list read, you are out of luck.  You can try it
     * again. It is possible that your database entry or your application
     * software specifies a clock event instead of a frequency for data
     * collection.  In that event you might never get your data.  Not all GAS
     * speaking modules even recognize clock events.  If in doubt, reboot the
     * GAS-speaking module.  You should never see this error with a periodic
     * list read.  You should geterror code +001 (pending) instead.
     */
    public final static int CAMAC_FE_NOTUPDATED = FACILITY_CAMAC_FE + (-43*256);

    /**
     * GAS read request unsatisfied because of insufficient memory: The
     * GAS-speaking smart module is out of memory.  Turn off some data
     * collection like a parameter page or a plot.  If that doesn't work, try
     * rebooting the GAS-speaking module.
     */
    public final static int CAMAC_FE_MODMEMFAIL = FACILITY_CAMAC_FE + (-44*256);

    /**
     * Can't update your list because of insufficient memory: The memory
     * shortage is in the GAS-speaking smart module.  The front end software
     * will delete your list if this occurs.  You need to reestablish the list
     * (by reentering the page or restarting the plotor whatever).  If the
     * problem persists, stop some ongoing data collection (stop someone else's
     * page or plot).  The next thing to try rebooting is the GAS-speaking
     * smart module.  If the problem persists, contact the appropriate front
     * end programmer.
     */
    public final static int CAMAC_FE_UPDMEMFAIL = FACILITY_CAMAC_FE + (-45*256);

    /**
     * GAS list read of a list still being set up: The front end computer will
     * wait only so long for a GAS-speaking module to get its lists set up.  If
     * you get this error, the front end computer has given up and deleted your
     * list.  See error -45 for recovery.
     */
    public final static int CAMAC_FE_SETUPTMO = FACILITY_CAMAC_FE + (-46*256);

    /**
     * GAS read encountered fatal error acquiring data: This error will not
     * clear. You have to restart your GAS lists, for instance be reentering
     * your page, restarting your plots, etc.  The error is an indication of a
     * problem within the GAS-speaking module.  You might try rebooting it if
     * the error persists.
     */
    public final static int CAMAC_FE_READERROR = FACILITY_CAMAC_FE + (-47*256);

    /**
     * GAS read pending too long: If you had a one-shot list, the front end
     * computer gave up waiting for the GAS-speaking module to collect its
     * data.  You have to retry the command.  You might try rebooting the
     * GAS-speaking module if the error persists.  If youhave a periodically
     * updating list, you should receive a code +001 (pending) until the data
     * becomes available.
     */
    public final static int CAMAC_FE_READTMO = FACILITY_CAMAC_FE + (-48*256);

    /**
     * GAS error 10 occurred (no one knows what this means).
     */
    public final static int CAMAC_FE_GAS_ERROR_10 = FACILITY_CAMAC_FE + (-49*256);

    /**
     * Invalid owner CPU returned by arbitration routine: This can occur only
     * on the new front ends. This is an internal software problem.  Please,
     * contact the appropriate front end programmer.
     */
    public final static int CAMAC_FE_INVCPU = FACILITY_CAMAC_FE + (-50*256);

    /**
     * Unimplemented module type: The database entry specifies an illegal
     * DRIVRS module type.  This field is the third byte of the SSDN.  Your
     * database entry needs to be fixed.  If you have some kind of new card, it
     * is possible that the programmer hasn't updated the front end software
     * yet or that the updated software is not installed on all computers.
     * Bring it to the attention of the front end programmer.
     */
    public final static int CAMAC_FE_INVDRIVER = FACILITY_CAMAC_FE + (-51*256);

    /**
     * Invalid property index: The front end does not recognize or does not
     * support the property index, ('PI'), that you specified in your reading
     * or setting request.  This is almost certainly a programming bug.
     */
    public final static int CAMAC_FE_INVPROP = FACILITY_CAMAC_FE + (-52*256);

    /**
     * This device does not support this property: It can happen that you have
     * created a database property that the front end does not support--for
     * example if you put an alarm property in the database on some device for
     * which the front end does not support alarms. If you are writing a new
     * application program, it may also be the result of specifying an
     * incorrect property index, ('PI'), in your reading or seting request.
     * This is almost certainly a programming bug.
     */
    public final static int CAMAC_FE_INVDEVPROP = FACILITY_CAMAC_FE + (-53*256);

    /**
     * Unrecognizable basic control word: You have tried to perform a basic
     * control operation upon some module.  The word that you sent to the front
     * end, which tells exactly what basic control option you want, is
     * unrecognizable.  This word may have been obtained from the database by
     * scaling services, in which case the database entry is incorrect.  The
     * word may have been derived by the application program itself, in which
     * case that program is buggy.
     */
    public final static int CAMAC_FE_INVBCTL = FACILITY_CAMAC_FE + (-54*256);

    /**
     * Invalid base or offset: The 'base' or 'offset' parameter in the reading
     * or setting request is incorrect.  In general, it can't be less than
     * zero.  Every type of device has limits on how big this number can be,
     * depending on how much data that device can return.  Usually the limit on
     * the offset is the total number of bytes a device yields up minus the
     * default length. This is almost certainly a programming bug, but it can
     * also be caused by specifying an invalid maximum length in a database
     * entry.
     */
    public final static int CAMAC_FE_INVOFFSET = FACILITY_CAMAC_FE + (-55*256);

    /**
     * Invalid length: The 'length' parameter in the reading or setting request
     * is incorrect.  This number specifies how many bytes of data you are
     * requesting. Every type of device has limits on how big and how small
     * this number can be. The database contains a default value for the
     * 'length' that the parameter page uses.  If you get this error on the
     * parameter page, then either the database entry is incorrect or this
     * device was never meant to be accessed from the parameter page.
     * Otherwise, it could be a programming bug.
     */
    public final static int CAMAC_FE_INVLENGTH = FACILITY_CAMAC_FE + (-56*256);

    /**
     * Length plus offset too large: When you are trying to read or set a large
     * array of data, you sometimes 'slice it up' into smaller chunks by
     * specifying that you want to read only 'length' bytes starting from some
     * 'offset'. The offsets start from zero.  If the length plus the offset
     * exceeds the number of words in the data array, i.e. you tried to read
     * off the end, then you will get this error.
     */
    public final static int CAMAC_FE_INVTOTLEN = FACILITY_CAMAC_FE + (-57*256);

    /**
     * Ad Hoc data pool slot out of range: The front end maintains an 'ad hoc
     * data pool' of locally derived values.  Some database devices access this
     * data pool. If you get this error, your database entry's SSDN is
     * malformed.
     */
    public final static int CAMAC_FE_INVDPSLOT = FACILITY_CAMAC_FE + (-58*256);

    /**
     * Unrecognizable reading: A device is returning a readback that cannot be
     * interpreted by the front end software.  Some examples: 177 timing cards
     * power up with invalid times in them.  This error implies that you have
     * to reload the time from page T64 (TimerCards Page) or type in a new time
     * from the parameter page. Multipole switches require that exactly one bit
     * be set in a whole field of bits.  If more than one bit is on, or no bits
     * are on, then it is impossible to interpret the switch position, and this
     * error is reported.
     */
    public final static int CAMAC_FE_INVREADING = FACILITY_CAMAC_FE + (-59*256);

    /**
     * Collision between several users wanting the same device: There are
     * certain devices which can be accessed by only one user at a time.  If
     * two people try to access such a device, one of them will get this error.
     * .b The periodically cleared scalers for B0 beam halo are a similar
     * example.  Several consoles can plot data from one of these scalers, but
     * all users have to use the same plot frequency.  If a newcomer wants to
     * plot a scaler with a different frequency than a current user, the
     * newcomer will get this error.
     */
    public final static int CAMAC_FE_INUSE = FACILITY_CAMAC_FE + (-60*256);

    /**
     * Setup for data collection failed: Some devices require elaborate
     * software or hardware setup before you can collect data from them.  In
     * general, the front end software tries to give a more specific error than
     * this one.
     */
    public final static int CAMAC_FE_NOSETUP = FACILITY_CAMAC_FE + (-61*256);

    /**
     * Attempted one-shot read: You have specified a one-shot FTD (the FTD
     * parameter is zero) in a reading request.  The device you are trying to
     * read cannot be read in this manner.  A good example of this is when you
     * are trying to read a scaler where only repeated read and clear
     * operations make any sense.
     */
    public final static int CAMAC_FE_NO_ONESHOT_READ = FACILITY_CAMAC_FE + (-62*256);

    /**
     * Attempted event read: You have specified an event read (the FTD
     * parameter is negative) in a reading request.  The device you are trying
     * to read cannot be read in this manner.  You will have to try either a
     * one shot or a periodic reading.
     */
    public final static int CAMAC_FE_NO_EVENT_READ = FACILITY_CAMAC_FE + (-63*256);

    /**
     * Invalid subaddress in SSDN: The 7th byte of the SSDN (counting from 1),
     * which contains either a CAMAC 'A' subaddress field or a software
     * subaddress code, is out of range.  This is all baked into the database.
     * Your database entry is fouled up. There are a few instances where this
     * error is returned and the problem is not the subaddress byte in the
     * SSDN, but in fact the problem is some other field within the SSDN.  So,
     * if you get this error, check over your SSDNs in you database entry very
     * carefully.
     */
    public final static int CAMAC_FE_INVALID_SUBADDRESS = FACILITY_CAMAC_FE + (-64*256);

    /**
     * Invalid MADC number: The MADC number, which comes out of the SSDN in
     * your database entry, does not point to a real MADC which the front end
     * computer knows about.  It is possible that the front end tables have not
     * been updated to include your MADC.  It isalso possible that your
     * database entry needs fixing. A current list of MADCs can be displayed
     * with the ACL command: 'node/madcs {node}'.
     */
    public final static int CAMAC_FE_UNKNOWN_MADC_NUM = FACILITY_CAMAC_FE + (-65*256);

    /**
     * Setting Rejected: The front end audits certain settings and rejects them
     * if they are unreasonable.  An example of this is the abort kicker delay,
     * which at the time this was written is restricted to 9.8 microseconds,
     * plus or minus .5 microsecond.  Anotherexample is a multipole switch,
     * which has only a small number of acceptable positions.
     */
    public final static int CAMAC_FE_INVALID_SET_VALUE = FACILITY_CAMAC_FE + (-66*256);

    /**
     * Device busy: Some devices will not accept new settings when they are
     * currently busy.
     */
    public final static int CAMAC_FE_DEVICE_BUSY = FACILITY_CAMAC_FE + (-67*256);

    /**
     * Internal Alarm Property I/O Error: This error indicates that the
     * software for reading and writing alarm information has a problem.  The
     * software in question resides within the front end.  Please, contact the
     * appropriate front end programmer.
     */
    public final static int CAMAC_FE_ALARM_IO_ERROR = FACILITY_CAMAC_FE + (-68*256);

    /**
     * Alarm information is unknown: When the front end reboots it receives
     * alarm parameters from the database for many devices.  If you get this
     * error, it means that the alarm parameters for this device were never
     * received by the front end. You should make sure the device in question
     * has been entered on page D52 which places it in the alarm parameter
     * download files.  The next step is to see the front end programmer.
     */
    public final static int CAMAC_FE_NOALARM = FACILITY_CAMAC_FE + (-69*256);

    /**
     * Alarm information conflicts with another device: When alarm parameters
     * are sent to the front end, several very cursory checks are performed to
     * ensure that there is no conflict such as, e.g., a vacuum alarm and a
     * power supply alarm assigned to the same CAMAC crate and slot.
     */
    public final static int CAMAC_FE_ALARM_CONFLICT = FACILITY_CAMAC_FE + (-70*256);

    /**
     * Unequipped crate: The crate address in the database entry for your
     * device is unknown to the front end.  This could be a problem with the
     * front end tables, in which case you need to see the front end
     * programmer, or it could be a problem with the database entry.  The crate
     * address is stored in the SSDN.
     */
    public final static int CAMAC_FE_INVALID_CRATE = FACILITY_CAMAC_FE + (-71*256);

    /**
     * Wrong data length of alarm parameter: Within the analog or digital alarm
     * block in the database is stored the length of the data to be checked.
     * Thus it is, for instance, that MADC channels are specified as 1 word
     * long, and 377 timing channels are specified as 2 words long.  There are
     * some instances where the front end  verifies that the data length
     * specified within the alarm block matches the correct data length for the
     * device.
     */
    public final static int CAMAC_FE_INV_ALARM_DATA_LENGTH = FACILITY_CAMAC_FE + (-72*256);

    /**
     * Timeout talking to a device, but for a valid reason: One example is a
     * multiwire paddle.  If the paddle is not properly oriented, you can't
     * read the data you want.  For instance, if you are trying to read the
     * horizontal beam width while the paddle is out of the beam, you will get
     * this error. .b The 116 card which receives safety system status from
     * CARESS maintains data refresh counters.  If the front end does not see
     * that the data is getting refreshed fast enough to satisfy your request,
     * then you will getthis error.
     */
    public final static int CAMAC_FE_NOTENB = FACILITY_CAMAC_FE + (-73*256);

    /**
     * No more delay list entries: The DRIVRS or DRIXRS task in the front end
     * has overflowed an internal queue.  Perhaps you can stop some plots or
     * application programs.  If this error persists, contact the appropriate
     * front end programmer.
     */
    public final static int CAMAC_FE_NODLYENTRY = FACILITY_CAMAC_FE + (-74*256);

    /**
     * No more 190 MADC controller clock decoders: The CAMAC 190 card MADC
     * controller has only 7 TCLK decoders, which are shared among the various
     * event-driven data collection processes, such as alarm on events,
     * snapshot plots, and event-driven parameter page devices.  When you run
     * out, you can cancel some type of data collection which is using a
     * different event (or list of events) than the one(s) you want.  If this
     * error persists, contact the appropriate front end programmer.
     */
    public final static int CAMAC_FE_NODECODERS = FACILITY_CAMAC_FE + (-75*256);

    /**
     * No more MADC controller event-driven lists: The CAMAC MADC controller
     * has several special data collection 'lists', which are dedicated to
     * event driven data collection and a few special other purposes (such as
     * alarms).  It is possible to run out of lists in a given module (8 for a
     * 190, 15 for a 290). If this error persists, contact the appropriate
     * front end programmer.
     */
    public final static int CAMAC_FE_NOEVNTLIST = FACILITY_CAMAC_FE + (-76*256);

    /**
     * Invalid MADC channel number: MADC channel number is out of range
     * (0-255).  Most likely this is a database entry problem.
     */
    public final static int CAMAC_FE_INVALID_MADC_NUM = FACILITY_CAMAC_FE + (-77*256);

    /**
     * Out of alarm tabloids memory: If this ever occurs, it means that we are
     * using more MADC alarms than was thought in the beginning.  Please,
     * contact the front end programmer, who can easily fix this.
     */
    public final static int CAMAC_FE_ALARM_MEMFAIL = FACILITY_CAMAC_FE + (-78*256);

    /**
     * Block transfer is off: You have requested data which is obtained over
     * the block transfer link, but the block transfer facility has been
     * software disabled in the  front end.  You can reenable block transfer
     * from any parameter page using the devices: 1) T:BTRON - Tevatron front
     * end, 2) S:BTRON - Switchyard front end, 3) I:BTRON - Main Injector front
     * end, 4) B:BTRON - Booster front end, 5) A:BTRON - P-bar front end, 6)
     * Z:BTRON - development front end.
     */
    public final static int CAMAC_FE_BLK_XFER_OFF = FACILITY_CAMAC_FE + (-79*256);

    /**
     * Block transfer tailer mismatch: The crate address or target slot
     * returned in the tailer of the block transfer did not match that which
     * was desired.  The problem is likely to be in the CAMAC crate controller,
     * but it could be elsewhere. .b Note to experts:The front end does not
     * operate in selective listener mode.
     */
    public final static int CAMAC_FE_BLK_XFER_MISMATCH = FACILITY_CAMAC_FE + (-80*256);

    /**
     * Block transfer no data received: The block transfer was normal in all
     * respects, except that it was shortened because the target CAMAC card
     * yielded up no data whatsoever.  Usually the problem is in the target
     * CAMAC card, although there are crate controller failures and software
     * failures which can cause this error. .b Note to experts: Error -81 is
     * entirely equivalent to error -82, except that if the received word count
     * is zero, then error -81 is reported instead.  If short blocks are
     * permitted, this error is not issued.
     */
    public final static int CAMAC_FE_BLK_XFER_NO_DATA = FACILITY_CAMAC_FE + (-81*256);

    /**
     * Block transfer unexpected No-Q termination: The block transfer was
     * normal in all respects, except that it was shortened when the target
     * CAMAC card stopped yielding up data.  Usually the problem is in the
     * target CAMAC card, although there are crate controller failures and
     * software failures that can cause this error. .b Note to experts: This
     * status bit is reported as an error only if Short Block Permitted is not
     * set.  Also the received word count must indicate that at least one word
     * was received before theNo-Q termination.  See error -81, which is
     * generated when the received word count is zero.
     */
    public final static int CAMAC_FE_BLK_XFER_NO_Q = FACILITY_CAMAC_FE + (-82*256);

    /**
     * Block transfer data consistency check: The block transfer diagnostic
     * scan reads the F(6)A(0) module number (for some selected CAMAC cards) in
     * two different ways.  This error is generated when the data received by
     * the two different methods is inconsistent. This error is generated
     * solely by the on-demand diagnostic software.
     */
    public final static int CAMAC_FE_BLK_XFER_CHKFAIL = FACILITY_CAMAC_FE + (-83*256);

    /**
     * Illegal block transfer length requested: The block transfer controller
     * imposes two constraints on the number of words you can read.  1) If you
     * are reading in 2-word mode, the number of words must be an even number.
     * 2) If you are reading in packed-byte mode, 2*N must be divisible by 3.
     * .b This error is generated by a software audit of the block transfer
     * request, and is not a hardware problem.
     */
    public final static int CAMAC_FE_BLK_XFER_INV_LEN = FACILITY_CAMAC_FE + (-84*256);

    /**
     * Block transfer request for too many words: There is a software limit of
     * 4090 words. .b This error is generated by a software audit of the block
     * transfer request and is not a hardware problem.
     */
    public final static int CAMAC_FE_BLK_XFER_TOO_BIG = FACILITY_CAMAC_FE + (-85*256);

    /**
     * Block transfer cancelled by CAMAC command: There is a special CAMAC
     * command, F(20)A(15)N(24), which will forcibly terminate a block transfer
     * in progress. The software does not usually deliberately send this
     * command.  This error indicates that the crate controller believes such a
     * command has been sent, and the block transfer was terminated.
     */
    public final static int CAMAC_FE_BLK_XFER_CANCEL = FACILITY_CAMAC_FE + (-86*256);

    /**
     * Block transfer cancelled by crate controller timeout: The CAMAC crate
     * controller times out if a block transfer has been active for more than
     * 1/2 second.  This error generally indicates that the target system was
     * not especially prompt in providing data.
     */
    public final static int CAMAC_FE_BLK_XFER_CC_TMO = FACILITY_CAMAC_FE + (-87*256);

    /**
     * Block transfer receiver timeout: The Block Transfer Receiver starts
     * timing when it receives the first frame back from the CAMAC crate
     * controller.  It then has a 1.5 ms retriggerable inter-frame timeout for
     * every subsequent frame.  This error indicates that either the transfer
     * took too long, or the tailer frame is missing. The problem is likely to
     * be in the CAMAC crate controller or possibly in the target CAMAC module.
     * Note that in order to get this error, at least one frame has to have
     * been received.  This means that the link is basically up.
     */
    public final static int CAMAC_FE_BLK_XFER_RCV_TMO = FACILITY_CAMAC_FE + (-88*256);

    /**
     * Block transfer serial frame error: Somehow the bits coming back on the
     * block transfer link are mangled: one of the frames did not pass either a
     * parity check or a protocol check.  The usual suspects are the Block
     * Transfer Link hardware and the CAMAC cratecontrollers.
     */
    public final static int CAMAC_FE_BLK_XFER_FRM_ERR = FACILITY_CAMAC_FE + (-89*256);

    /**
     * Block transfer receiver memory overflow: The memory capacity of the
     * Block Transfer Receiver is 64K words. .b This memory overflow is not
     * presently understood.
     */
    public final static int CAMAC_FE_BLK_XFER_RCV_OVF = FACILITY_CAMAC_FE + (-90*256);

    /**
     * Block transfer software timeout: If no block transfer activity was
     * observed by the block transfer receiver and controller, the software
     * will eventually (> 100 ms) time out.  This is usually a problem with a
     * CAMAC crate controller, or it could possibly bea crate turned off. .b
     * Note to experts:  In general, if the crate is off or the link is down,
     * you should get a -5 error code.  The -5 error is issued when the PIOX
     * command to set up the crate controller times out.
     */
    public final static int CAMAC_FE_BLK_XFER_SOFT_TMO = FACILITY_CAMAC_FE + (-91*256);

    /**
     * Block transfer too many words received: The number of words received is
     * greater than the number of words expected. .b This error could be caused
     * by software miscalculating the number of words expected.  It is much
     * more likely to be caused by failing CAMAC hardware. .b There is a known,
     * but unresolved, problem which will cause this error to appear on certain
     * 15Hz knob plots and other plots from CAMAC 190 MADC controllers.
     */
    public final static int CAMAC_FE_BLK_XFER_RCV_TOO_MUCH = FACILITY_CAMAC_FE + (-92*256);

    /**
     * Block transfer too few words received: The number of words received is
     * smaller than the number of words expected. .b There are several 'normal'
     * reasons why too few words may be received by a block transfer operation.
     * This error is reported if too few words were received, but there is no
     * other known explanation.  All other status bits (except the error -94
     * 'composite error' bit) are checked before this bit is checked. .b This
     * error can be caused by software miscalculating the number of words
     * expected.  This error can also be caused by a myriad of hardware
     * problems.  .b Note to experts: this error is totally independent of
     * 'short block permitted' status.
     */
    public final static int CAMAC_FE_BLK_XFER_RCV_TOO_FEW = FACILITY_CAMAC_FE + (-93*256);

    /**
     * Unknown block transfer composite error: You get this error if the
     * 'composite error' flag on the Block Transfer Controller is on, but none
     * of the other standard error bits are set.  We have observed this error
     * when there were timing problems in the UnibusBlock Transfer Controller
     * board.  It is not clear what else can cause this error to happen,
     * although it could also be the Block Transfer Receiver chassis or
     * possibly a CAMAC crate controller.
     */
    public final static int CAMAC_FE_BLK_XFER_UNKNOWN_ERR = FACILITY_CAMAC_FE + (-94*256);

    /**
     * 1553 based distributed A/D channel turned off: Since the tentacles of
     * the distributed 14 bit A/D system are located directly within the power
     * supplies being monitored, there is always the danger that the supply
     * might be off.  This error usually means that the supply is off.  .b This
     * error can also mean that the CAMAC 1553 card, which resides in the crate
     * right beside its associated 190 card, needs to be reset.  You can find
     * the card by looking at the crate picture on page D20, and send it an
     * F(9)A(0) CAMAC command on page D21.
     */
    public final static int CAMAC_FE_1553_AD_OFF = FACILITY_CAMAC_FE + (-95*256);

    /**
     * UPGAS received wrong length STANC list or setting data: This is an error
     * in either the console application or in the front end computer.  If the
     * problem doesn't clear, there is a software bug.  You should then contact
     * the front end programmer or the console application programmer.
     */
    public final static int CAMAC_FE_UPGAS_LENGTH_ERROR = FACILITY_CAMAC_FE + (-96*256);

    /**
     * Out of dynamic memory: There is not enough front end dynamic memory to
     * satisfy your request.  Try shutting off some other pages or plots.  If
     * this error persists, contact the appropriate front end programmer.
     */
    public final static int CAMAC_FE_MEMFAIL = FACILITY_CAMAC_FE + (-97*256);

    /**
     * UPGAS table filled: The UPGAS special data collection routine is trying
     * to satisfy too many requests.  This is very unusual.  Try shutting off
     * some other pages.  If this error persists, contact the appropriate front
     * end programmer.
     */
    public final static int CAMAC_FE_UPGAS_TABLE_FULL = FACILITY_CAMAC_FE + (-98*256);

    /**
     * Unrecognizable UPGAS request from console: There is a problem within
     * either the front end computer or the console application.  Try
     * restarting the console application.  If this doesn't work, you have a
     * genuine bug.  You should then contact the front end programmer or the
     * console application programmer.
     */
    public final static int CAMAC_FE_UPGAS_BAD_REQUEST = FACILITY_CAMAC_FE + (-99*256);

    /**
     * Front end node is down or has prematurely canceled list.
     */
    public final static int CAMAC_FE_FEDOWN = FACILITY_CAMAC_FE + (-101*256);

    /**
     * Single shot has an outstanding reply
     */
    public final static int CAMAC_FE_GASBUSY = FACILITY_CAMAC_FE + (-102*256);

    /**
     * No such list by buffer ID
     */
    public final static int CAMAC_FE_NOLIST = FACILITY_CAMAC_FE + (-103*256);

    /**
     * Replies are not expected: No request ID because of a previously returned
     * error.
     */
    public final static int CAMAC_FE_REQFAIL = FACILITY_CAMAC_FE + (-104*256);

    /**
     * Single shot read has already been read
     */
    public final static int CAMAC_FE_ALRDYREAD = FACILITY_CAMAC_FE + (-105*256);

    /**
     * No such logical node
     */
    public final static int CAMAC_FE_NO_SUCH_NODE = FACILITY_CAMAC_FE + (-106*256);

    /**
     * Settings are currently locked out on this console.  The utility window's
     * setting lock is locked.
     */
    public final static int CAMAC_FE_SETTINGS_LOCKED = FACILITY_CAMAC_FE + (-107*256);

    /**
     * No privilege for sets: Your console is not a member of the classes of
     * consoles allowed to perform settings from this application.  The index
     * page displays the run and set classes defined for each application.
     */
    public final static int CAMAC_FE_NO_SETTINGS_PRIV = FACILITY_CAMAC_FE + (-108*256);

    /**
     * Drivers out of shared memory: If this error is transient, don't worry.
     * If it persists, contact the appropriate front end programmer.
     */
    public final static int CAMAC_FE_DRVMEMFAIL = FACILITY_CAMAC_FE + (-109*256);

    /**
     * Drivers out of local memory: If this error is transient, don't worry.
     * If it persists, contact the appropriate front end programmer.
     */
    public final static int CAMAC_FE_DRVLCLMEM = FACILITY_CAMAC_FE + (-110*256);

    /**
     * Drivers out of reqnums: There are too many simultaneous request lists
     * running in one front end.  There could be a pathological program running
     * somewhere, which is accumulating running lists and never deleting any.
     * You might try to cancel some application programs.
     */
    public final static int CAMAC_FE_TOOMANYREQS = FACILITY_CAMAC_FE + (-111*256);

    /**
     * Drivers failed to find list to cancel: This is a front end internal
     * problem.  If the problem is reproducible, you should notify the front
     * end programmer.
     */
    public final static int CAMAC_FE_LIST_CANCEL_FAIL = FACILITY_CAMAC_FE + (-112*256);

    /**
     * Drivers received request with no devices (DI,PIs): This is a front end
     * internal problem.  If the problem is reproducible, you should notify the
     * front end programmer.
     */
    public final static int CAMAC_FE_NO_DEVICE_REQUEST = FACILITY_CAMAC_FE + (-113*256);

    /**
     * Unequipped slot (bad SSDN): The CAMAC slot ('N') in a database SSDN is
     * out of range (1-23). This is a database entry problem.
     */
    public final static int CAMAC_FE_INVALID_SLOT = FACILITY_CAMAC_FE + (-114*256);

    /**
     * Drivers seize key tables filled: Something in the front end has locked
     * up.  If you can trace the problem to a specific type of device you are
     * using, the front end programmers would greatly appreciate knowing about
     * it.
     */
    public final static int CAMAC_FE_KEY_TABLES_FULL = FACILITY_CAMAC_FE + (-115*256);

    /**
     * Driver returned too much data: This is a front end internal problem
     * where the driver is returning more data than it has been asked for. If
     * the problem is reproducible, you should notify the appropriate front end
     * programmer.
     */
    public final static int CAMAC_FE_TOO_MUCH_DATA = FACILITY_CAMAC_FE + (-116*256);

    /**
     * Slam table conflict for alarm support: Most probably an obsolete GAS
     * speaker or MADC is pointing at the slot presently used for another
     * device. Another possibility is an obsolete database device pointing at
     * the crate and slot presently used by another device.
     */
    public final static int CAMAC_FE_SLAM_CONFLICT = FACILITY_CAMAC_FE + (-117*256);

    /**
     * Scale factor is zero: To complete this operation, a device's scale
     * factor needs to be used.  Unfortunately, this value is currently zero.
     * Set the scale factor to a nonzero value and try again.
     */
    public final static int CAMAC_FE_ZERO_SCALEFACTOR = FACILITY_CAMAC_FE + (-118*256);

    /**
     * Calculation resulted in overflow: In calculating the results, an
     * overflow occurred. Whether clipped data or no data is returned depends
     * upon the driver. (The 453 driver clips the data.)
     */
    public final static int CAMAC_FE_CALC_OVERFLOW = FACILITY_CAMAC_FE + (-119*256);

    /**
     * Data is not collected yet: For slow devices like PCs and Pisa boxes
     * there exist additional asynchronous processes for data collecting. This
     * error means that said data has not been (asynchronously) collected yet.
     * Don't panic.  Data should be available later.
     */
    public final static int CAMAC_FE_NODATAYET = FACILITY_CAMAC_FE + (-124*256);

    /**
     * SCIOQ input queue error: This is a front end software problem that
     * should never happen. Please, contact the appropriate front end
     * programmer.
     */
    public final static int CAMAC_FE_QUEUERR = FACILITY_CAMAC_FE + (-125*256);

    /**
     * PAXE Port-A transmit error: This is an error in transmitting on the
     * CAMAC serial link.  You should contact one of the CAMAC experts.
     */
    public final static int CAMAC_FE_LINKERR = FACILITY_CAMAC_FE + (-126*256);

    /**
     * CAMAC link driver is not responding: This is a hardware error within the
     * CAMAC front end.  You should contact one of the front end programmers or
     * the appropriate engineer if switching to a backup front end doesn't
     * help.
     */
    public final static int CAMAC_FE_NOLINK = FACILITY_CAMAC_FE + (-127*256);

    /**
     * Too long request to MADC gathering task: An attempt has been made to
     * send a request containing more than 256 devices (DI,PIs) to the MADC
     * gathering task.
     */
    public final static int CAMAC_FE_TOO_MANY_MADC_DEVS = FACILITY_CAMAC_FE + (-128*256);

    /**
     * IOMAC facility
     */
    public final static int FACILITY_IOMAC = 21;
    public final static int IOMAC_OK = 0;
    public final static int IOMAC_SUCCESS = 0;

    /**
     * No such MAC: MAC number is negative or too large.
     */
    public final static int IOMAC_INVMAC = FACILITY_IOMAC + (-1*256);

    /**
     * Network send request status non-zero
     */
    public final static int IOMAC_SENDFAIL = FACILITY_IOMAC + (-2*256);

    /**
     * No response from MAC, watchdog timeout
     */
    public final static int IOMAC_MACTMO = FACILITY_IOMAC + (-3*256);

    /**
     * Echoed ID from front end does not match request
     */
    public final static int IOMAC_TAGFAIL = FACILITY_IOMAC + (-4*256);

    /**
     * Front end says something wrong with MAC
     */
    public final static int IOMAC_BADMAC = FACILITY_IOMAC + (-5*256);

    /**
     * Word count is larger than 1023
     */
    public final static int IOMAC_WDCERR = FACILITY_IOMAC + (-6*256);

    /**
     * Network send request for reboot failed.
     */
    public final static int IOMAC_BOOTFAIL = FACILITY_IOMAC + (-7*256);

    /**
     * There was a bad response to a check event flag request. Generally this
     * is an ACNET -008 error.
     */
    public final static int IOMAC_EVFLGERR = FACILITY_IOMAC + (-8*256);

    /**
     * Second reply to reboot never came
     */
    public final static int IOMAC_NOBOOTRPLY = FACILITY_IOMAC + (-9*256);

    /**
     * Settings disallowed for this console.
     */
    public final static int IOMAC_NOSET = FACILITY_IOMAC + (-10*256);

    /**
     * OOC facility
     */
    public final static int FACILITY_OOC = 25;
    public final static int OOC_OK = 0;
    public final static int OOC_SUCCESS = 0;

    /**
     * see the front end programmer for details
     */
    public final static int OOC_PENDING = FACILITY_OOC + (1*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NOMETHOD = FACILITY_OOC + (-1*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_METHODFAILED = FACILITY_OOC + (-2*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADDEST = FACILITY_OOC + (-3*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADPDEST = FACILITY_OOC + (-4*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NORAMSYS = FACILITY_OOC + (-5*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_OBSSTA6 = FACILITY_OOC + (-6*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADPLACE = FACILITY_OOC + (-7*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_UNWRITTEN = FACILITY_OOC + (-8*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_ISNEWFAILED = FACILITY_OOC + (-9*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADCLASSIV = FACILITY_OOC + (-10*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_UNSPARKIND = FACILITY_OOC + (-11*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_INSUFMIP = FACILITY_OOC + (-12*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_UNKNMID = FACILITY_OOC + (-13*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_OSERR = FACILITY_OOC + (-14*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_UNKNOID = FACILITY_OOC + (-15*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_QQFAILED = FACILITY_OOC + (-16*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_INITFAILED = FACILITY_OOC + (-17*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_TOOMANYMIP = FACILITY_OOC + (-18*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_TODASFAILED = FACILITY_OOC + (-19*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_FROMDASFAILED = FACILITY_OOC + (-20*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NOCVS = FACILITY_OOC + (-21*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSSDN = FACILITY_OOC + (-22*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADLISTPACKET = FACILITY_OOC + (-23*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADLIST = FACILITY_OOC + (-24*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSETPACKET = FACILITY_OOC + (-25*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSET = FACILITY_OOC + (-26*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADREPLY = FACILITY_OOC + (-27*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_DUPENTRY = FACILITY_OOC + (-28*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NOENTRY = FACILITY_OOC + (-29*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_MEOVERFLOW = FACILITY_OOC + (-30*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_MEUNDERFLOW = FACILITY_OOC + (-31*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_OBSSTA32 = FACILITY_OOC + (-32*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_CANCEL = FACILITY_OOC + (-33*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_CORPAR = FACILITY_OOC + (-34*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_CORRES = FACILITY_OOC + (-35*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_METHODCHAPAR = FACILITY_OOC + (-36*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_METHODCORRES = FACILITY_OOC + (-37*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_CORRUPTMOL = FACILITY_OOC + (-38*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSOURCE = FACILITY_OOC + (-39*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADPSTA = FACILITY_OOC + (-40*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_PARSEERR = FACILITY_OOC + (-41*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADPARAM = FACILITY_OOC + (-42*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_INTERNAL = FACILITY_OOC + (-43*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_EMPTYKEY = FACILITY_OOC + (-44*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_FIFOERR = FACILITY_OOC + (-45*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BUFOVERFLOW = FACILITY_OOC + (-46*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NEEDRESULTPLACE = FACILITY_OOC + (-47*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_MODNOTINITED = FACILITY_OOC + (-48*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_MODINITED = FACILITY_OOC + (-49*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_CANNOLIST = FACILITY_OOC + (-50*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_CANNONULIST = FACILITY_OOC + (-51*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADNOTE = FACILITY_OOC + (-52*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_AMBIGUOUS = FACILITY_OOC + (-53*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NOTUNDERSTOOD = FACILITY_OOC + (-54*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_FOUND = FACILITY_OOC + (-55*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_NOTPRESENT = FACILITY_OOC + (-56*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_ACNETERR = FACILITY_OOC + (-57*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSSDNLAN = FACILITY_OOC + (-58*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSSDNNODE = FACILITY_OOC + (-59*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADSSDNFORMAT = FACILITY_OOC + (-60*256);

    /**
     * see the front end programmer for details
     */
    public final static int OOC_BADLISTPI = FACILITY_OOC + (-61*256);

    /**
     * RDAT_FRG facility
     */
    public final static int FACILITY_RDAT_FRG = 27;
    public final static int RDAT_FRG_OK = 0;
    public final static int RDAT_FRG_SUCCESS = 0;

    /**
     * Unsupported class number: An attempt was made to create an instance for
     * an unexistent class.  Check if the class has been properly created.
     * (Inner Front End error)
     */
    public final static int RDAT_FRG_NOCLASS = FACILITY_RDAT_FRG + (-1*256);

    /**
     * Unsupported OID: An attempt was made to create an instance with the OID
     * out of range (0 - 8191).  (Inner Front End error)
     */
    public final static int RDAT_FRG_INV_OID = FACILITY_RDAT_FRG + (-2*256);

    /**
     * Unsupported message type: An attempt was made to define a message of
     * type not defined in the message type header file.  (Inner Front End
     * error)
     */
    public final static int RDAT_FRG_NOMSG = FACILITY_RDAT_FRG + (-3*256);

    /**
     * IVs too long: There is a limitation on the length of the inner variables
     * structure (IVs).  (Inner Front End error)
     */
    public final static int RDAT_FRG_INV_IVLEN = FACILITY_RDAT_FRG + (-4*256);

    /**
     * Too many superclasses: There is a limitation on the amount of
     * superclasses for a particular class.  (Inner Front End error)
     */
    public final static int RDAT_FRG_TOOMANYCLASS = FACILITY_RDAT_FRG + (-5*256);

    /**
     * Duplicated class definition: A class with the same number has already
     * been defined.  (Inner Front End error)
     */
    public final static int RDAT_FRG_DUPCLASS = FACILITY_RDAT_FRG + (-6*256);

    /**
     * Duplicated OID definition: This object identifier (OID) has already been
     * defined.  (Inner Front End error)
     */
    public final static int RDAT_FRG_DUP_OID = FACILITY_RDAT_FRG + (-7*256);

    /**
     * Superclass for this class is not defined: It is necessary to define
     * superclasses before we define subclasses.  (Inner Front End error)
     */
    public final static int RDAT_FRG_NOSUPERCLASS = FACILITY_RDAT_FRG + (-8*256);

    /**
     * Class for this OID is not defined: The definition of the class should
     * appear before the definition of the instance of this class.  (Inner
     * Front End error)
     */
    public final static int RDAT_FRG_NO_OID_CLASS = FACILITY_RDAT_FRG + (-9*256);

    /**
     * This OID is not defined.  An attempt was made to fulfill the method for
     * an undefined OID.  Most likely the database entry is in error.  Another
     * possibility is that something is wrong with the 386 software.  Notify
     * the front end programmer.
     */
    public final static int RDAT_FRG_NO_OID = FACILITY_RDAT_FRG + (-10*256);

    /**
     * Supermethod for this method is not defined.  (Inner Front End error)
     */
    public final static int RDAT_FRG_NOSUPERMETHOD = FACILITY_RDAT_FRG + (-11*256);

    /**
     * Out of dynamic memory for the class structure.  (Inner Front End error)
     */
    public final static int RDAT_FRG_MEMFAILCLASS = FACILITY_RDAT_FRG + (-12*256);

    /**
     * Out of dynamic memory for instance structure.  (Inner Front End error)
     */
    public final static int RDAT_FRG_MEMFAILINSTNC = FACILITY_RDAT_FRG + (-13*256);

    /**
     * Empty name  (Inner Front End error)
     */
    public final static int RDAT_FRG_EMPTYNAME = FACILITY_RDAT_FRG + (-14*256);

    /**
     * Structure is not enough for this amount of messages.  (Inner Front End
     * error)
     */
    public final static int RDAT_FRG_TOOSMALL = FACILITY_RDAT_FRG + (-15*256);

    /**
     * Message type is not supported by this OID: An attempt was made to
     * fulfill the method for an undefined OID.  Most likely the database entry
     * is in error. Another possibility is that something is wrong with the 386
     * software.  See the front end programmer.
     */
    public final static int RDAT_FRG_INV_OID_MSG = FACILITY_RDAT_FRG + (-16*256);

    /**
     * Given IVs length is not enough.  (Inner Front End error)
     */
    public final static int RDAT_FRG_IV_TOOSMALL = FACILITY_RDAT_FRG + (-17*256);

    /**
     * ACNET error: Acnet communications problem.
     */
    public final static int RDAT_FRG_ACNETERR = FACILITY_RDAT_FRG + (-18*256);

    /**
     * Inner memory problems.  (Inner Front End error).
     */
    public final static int RDAT_FRG_MEMERR = FACILITY_RDAT_FRG + (-19*256);

    /**
     * Bad list request parameters.
     */
    public final static int RDAT_FRG_INVLISTREQ = FACILITY_RDAT_FRG + (-20*256);

    /**
     * Error defining trigger.  (Inner Front End error).
     */
    public final static int RDAT_FRG_TRIGERR = FACILITY_RDAT_FRG + (-21*256);

    /**
     * Bad FTD.
     */
    public final static int RDAT_FRG_INVFTD = FACILITY_RDAT_FRG + (-22*256);

    /**
     * Bad Setting parameters.
     */
    public final static int RDAT_FRG_INVSET = FACILITY_RDAT_FRG + (-23*256);

    /**
     * Bad LAN (SSDN).
     */
    public final static int RDAT_FRG_INVLAN = FACILITY_RDAT_FRG + (-24*256);

    /**
     * Bad node (SSDN).
     */
    public final static int RDAT_FRG_INVNODE = FACILITY_RDAT_FRG + (-25*256);

    /**
     * Bad Format.
     */
    public final static int RDAT_FRG_INVFORMAT = FACILITY_RDAT_FRG + (-26*256);

    /**
     * Unsupported property.
     */
    public final static int RDAT_FRG_INVPROP = FACILITY_RDAT_FRG + (-27*256);

    /**
     * Invalid offset: This is probably a database entry problem.
     */
    public final static int RDAT_FRG_INVOFFSET = FACILITY_RDAT_FRG + (-28*256);

    /**
     * Invalid length: This is probably a database entry problem.
     */
    public final static int RDAT_FRG_INVLEN = FACILITY_RDAT_FRG + (-29*256);

    /**
     * Setting timeout: There is probably something wrong with Arcnet
     * communications, or the 186 to which this device is connected is not
     * functioning correctly.
     */
    public final static int RDAT_FRG_SETTMO = FACILITY_RDAT_FRG + (-30*256);

    /**
     * Bad 186 number: We now allow two 186s per FRIG system (0 and 1).  This
     * is probably a database entry problem.
     */
    public final static int RDAT_FRG_INV186 = FACILITY_RDAT_FRG + (-31*256);

    /**
     * Bad slot: The 386 doesn't know about this type of device in this slot.
     * This is probably a database entry problem.  Another thing is to check
     * the load file for this particular 386.
     */
    public final static int RDAT_FRG_INVSLOT = FACILITY_RDAT_FRG + (-32*256);

    /**
     * Bad channel: This channel number is not supported by this device.  This
     * is probably a database entry problem.
     */
    public final static int RDAT_FRG_INVCHAN = FACILITY_RDAT_FRG + (-33*256);

    /**
     * Invalid offset plus length: This is probably a database entry problem.
     */
    public final static int RDAT_FRG_INVOFFLEN = FACILITY_RDAT_FRG + (-34*256);

    /**
     * Bad actuator: Actuator card is not functioning correctly.  It is not
     * updating data.  See the appropriate engineer.
     */
    public final static int RDAT_FRG_ACTUATORERR = FACILITY_RDAT_FRG + (-35*256);

    /**
     * Attempt to set a device which is in local mode
     */
    public final static int RDAT_FRG_LOCAL = FACILITY_RDAT_FRG + (-36*256);

    /**
     * Invalid device type: This is probably a database entry problem.  Another
     * reason for this error is an alarm (digital or analog) read/write for an
     * unequipped slot.
     */
    public final static int RDAT_FRG_INVTYPE = FACILITY_RDAT_FRG + (-37*256);

    /**
     * Unsupported basic control word: This is probably a database entry
     * problem.
     */
    public final static int RDAT_FRG_INVCONTROL = FACILITY_RDAT_FRG + (-38*256);

    /**
     * Transducer fault in the actuator card: See the appropriate engineer.
     */
    public final static int RDAT_FRG_TRANSDUCERR = FACILITY_RDAT_FRG + (-39*256);

    /**
     * Engine card is malfunctioning: See the appropriate engineer.
     */
    public final static int RDAT_FRG_ENGINERR = FACILITY_RDAT_FRG + (-40*256);

    /**
     * Alarm is not defined: An attempt was made to read an alarm block that
     * hasn't yet been downloaded.
     */
    public final static int RDAT_FRG_NOALARM = FACILITY_RDAT_FRG + (-41*256);

    /**
     * Alarm property is not supported: There is no software support for the
     * alarm property for this type of device.
     */
    public final static int RDAT_FRG_INVALARM = FACILITY_RDAT_FRG + (-42*256);

    /**
     * Undefined operation: An attempt was made to fulfill an operation that is
     * not yet defined.  Check which operations you are attempting to determine
     * if they are properly defined.
     */
    public final static int RDAT_FRG_NOOPER = FACILITY_RDAT_FRG + (-43*256);

    /**
     * Recursive operation: In the course of the operation's definitions,
     * you've accidentaly defined a recursive sequence.  Re-check the
     * operations presently in use.
     */
    public final static int RDAT_FRG_RECURSOPER = FACILITY_RDAT_FRG + (-44*256);

    /**
     * Unsupported operation type: Consult the manual for the list of the
     * operations supported.
     */
    public final static int RDAT_FRG_INVOPER = FACILITY_RDAT_FRG + (-45*256);

    /**
     * Wrong amount of operands for this operation: Consult the manual for the
     * number of operands for a particular operation.
     */
    public final static int RDAT_FRG_BADNUMOPRNDS = FACILITY_RDAT_FRG + (-46*256);

    /**
     * Unsupported type of the operand: This should never happen.  Most
     * probably something is wrong with the FSM application program.  Consult
     * the auther of the application.
     */
    public final static int RDAT_FRG_INVOPERAND = FACILITY_RDAT_FRG + (-47*256);

    /**
     * State is active: The attempt was made to change the currently active
     * state.  Deactivate all FSMs to which this state belongs and retry.
     */
    public final static int RDAT_FRG_STATEACTIVE = FACILITY_RDAT_FRG + (-48*256);

    /**
     * State is undefined: You are trying to activate an FSM that contains
     * undefined states.  Get the list of states and verify that all of them
     * are defined properly.
     */
    public final static int RDAT_FRG_NOSTATE = FACILITY_RDAT_FRG + (-49*256);

    /**
     * FSM is undefined: An attempt was made to activate an FSM that is not yet
     * defined.
     */
    public final static int RDAT_FRG_NOFSM = FACILITY_RDAT_FRG + (-50*256);

    /**
     * FSM is disabled: FSMs have two levels of control - enable/disable and
     * active/inactive.  In order to activate an FSM, it should be enabled.
     */
    public final static int RDAT_FRG_FSMDIS = FACILITY_RDAT_FRG + (-51*256);

    /**
     * Ramp buffer is undefined: The attempt was made to read a RAMP buffer
     * (CBA) that hasn't been set.
     */
    public final static int RDAT_FRG_NORMPBUF = FACILITY_RDAT_FRG + (-52*256);

    /**
     * FSM is currently active: Any attempt to make settings to the currently
     * active FSM will fail.  You must first stop the FSM to do this.
     */
    public final static int RDAT_FRG_FSMACTIVE = FACILITY_RDAT_FRG + (-53*256);

    /**
     * Timer is undefined: An attempt was made to set a value for a timer that
     * is not defined.
     */
    public final static int RDAT_FRG_NOTIMER = FACILITY_RDAT_FRG + (-54*256);

    /**
     * Reload in progress: Temporary error that occurs on the F8 (loops page).
     * You are trying to look at the loops while the system is restoring them
     * from the DB.
     */
    public final static int RDAT_FRG_RELOAD = FACILITY_RDAT_FRG + (-55*256);

    /**
     * Undefined action: An attempt was made to fulfill an action that is not
     * yet defined.  Check which actions you are accessing and insure they are
     * properly defined.
     */
    public final static int RDAT_FRG_NOACTION = FACILITY_RDAT_FRG + (-56*256);

    /**
     * Recursive action: In the course of the actions definitions, you've
     * accidentally defined a recursive sequence.  Recheck the actions
     * presently in use.
     */
    public final static int RDAT_FRG_ACTION_RECURSION = FACILITY_RDAT_FRG + (-57*256);

    /**
     * Invalid amount of outputs for this action: Consult the manual for the
     * number of outputs for a particular action.
     */
    public final static int RDAT_FRG_BADNUMOUT = FACILITY_RDAT_FRG + (-58*256);

    /**
     * State recursion: In state programming, one of the transition rules is
     * transition back to the same state.  This is forbidden.  Examine
     * transition rules for this state.
     */
    public final static int RDAT_FRG_STATE_RECURSION = FACILITY_RDAT_FRG + (-59*256);

    /**
     * Unrecognizable FTD: Invalid FTD format while programming events.
     */
    public final static int RDAT_FRG_INV_EVENT_FTD = FACILITY_RDAT_FRG + (-60*256);

    /**
     * Invalid delay value: The delay value specified for the events FTD is
     * negative.
     */
    public final static int RDAT_FRG_INV_EVENT_DELAY = FACILITY_RDAT_FRG + (-61*256);

    /**
     * Unsupported filtering method: For now the only two filtering methods
     * supported are Butterworth and Smoothing.
     */
    public final static int RDAT_FRG_INV_FILTER_METHOD = FACILITY_RDAT_FRG + (-62*256);

    /**
     * Attempt to change parameters of a running filter: You have to stop a
     * filter before changing any of its parameters.
     */
    public final static int RDAT_FRG_NO_FILTER_MODIFY = FACILITY_RDAT_FRG + (-63*256);

    /**
     * Filter is undefined: An attempt was made to activate a filter that is
     * not completely defined.
     */
    public final static int RDAT_FRG_FILTER_UNDEFINED = FACILITY_RDAT_FRG + (-64*256);

    /**
     * Unsupported actuator precision: Precision values currently supported are
     * in the range from 1 to 4.
     */
    public final static int RDAT_FRG_INVACTUATORPRECISION = FACILITY_RDAT_FRG + (-65*256);

    /**
     * Undefined VMC device: Internal virtual machine device has to be
     * connected to the states server in order to be settable.
     */
    public final static int RDAT_FRG_VM_DEV_UNDEFINED = FACILITY_RDAT_FRG + (-66*256);

    /**
     * Undefined VMC property: The only two properties for the virtual machine
     * devices currently supported are digital and analog alarms.
     */
    public final static int RDAT_FRG_INV_VM_PROP = FACILITY_RDAT_FRG + (-67*256);

    /**
     * Undefined VMC state: Virtual machine state has to be defined in order to
     * be able to read/write the current alarm block.
     */
    public final static int RDAT_FRG_INV_VM_STATE = FACILITY_RDAT_FRG + (-68*256);

    /**
     * Undefined 186 node: This is probably a database entry problem.
     */
    public final static int RDAT_FRG_INV186NODE = FACILITY_RDAT_FRG + (-71*256);

    /**
     * Board type is not defined: This is probably a database entry problem.
     */
    public final static int RDAT_FRG_INVBOARD = FACILITY_RDAT_FRG + (-72*256);

    /**
     * This slot is empty.  This is probably a database entry problem.
     */
    public final static int RDAT_FRG_SLOTEMPTY = FACILITY_RDAT_FRG + (-73*256);

    /**
     * This board doesn't support this property.  This is a 386 software
     * problem.
     */
    public final static int RDAT_FRG_INVBOARDPROP = FACILITY_RDAT_FRG + (-74*256);

    /**
     * Collision between property and flag: This is a 386 software problem.
     */
    public final static int RDAT_FRG_PROPFLAGCOLL = FACILITY_RDAT_FRG + (-75*256);

    /**
     * Nonexistent channel: This is probably a database entry problem.
     */
    public final static int RDAT_FRG_NOCHANNEL = FACILITY_RDAT_FRG + (-76*256);

    /**
     * 186 is malfunctioning
     */
    public final static int RDAT_FRG_186ERR = FACILITY_RDAT_FRG + (-81*256);

    /**
     * Communications with 186 are down
     */
    public final static int RDAT_FRG_186COMMERR = FACILITY_RDAT_FRG + (-82*256);

    /**
     * Unexpected empty slot in 186: Somebody has removed the card from there.
     * Contact the front end programmer.
     */
    public final static int RDAT_FRG_CARDGONE = FACILITY_RDAT_FRG + (-83*256);

    /**
     * Wrong board type/revision in the slot: Somebody has changed geography of
     * the slot without updating then load file, or the slot is empty.
     */
    public final static int RDAT_FRG_SLOTMISMATCH = FACILITY_RDAT_FRG + (-84*256);

    /**
     * Previous settings are in progress.
     */
    public final static int RDAT_FRG_SETBUSY = FACILITY_RDAT_FRG + (-85*256);

    /**
     * Loop value undefined: Loop hasn't ever run to compute a value. This will
     * clear after the loop has been activated, unless there is some error in
     * reading one of the loop's inputs.
     */
    public final static int RDAT_FRG_LOOP_VALUE_UNDEFINED = FACILITY_RDAT_FRG + (-86*256);

    /**
     * SAV_RST facility
     */
    public final static int FACILITY_SAV_RST = 31;
    public final static int SAV_RST_OK = 0;
    public final static int SAV_RST_SUCCESS = 0;

    /**
     * No data returned for this request.
     */
    public final static int SAV_RST_NORETDATA = FACILITY_SAV_RST + (2*256);

    /**
     * Illegal device index specified.
     */
    public final static int SAV_RST_ILDEV = FACILITY_SAV_RST + (-1*256);

    /**
     * Illegal property code specified.
     */
    public final static int SAV_RST_ILPROP = FACILITY_SAV_RST + (-2*256);

    /**
     * The request was not done because of a serious error in a previous
     * request packet.
     */
    public final static int SAV_RST_NOTDONE = FACILITY_SAV_RST + (-3*256);

    /**
     * No such property exists for the specified device.
     */
    public final static int SAV_RST_NOPROP = FACILITY_SAV_RST + (-4*256);

    /**
     * Not enough arguments provided in UTI call.
     */
    public final static int SAV_RST_INSUFFICIENT_ARGS = FACILITY_SAV_RST + (-5*256);

    /**
     * Illegal integer retrieval index (IRINX) specified.
     */
    public final static int SAV_RST_ILRINX = FACILITY_SAV_RST + (-6*256);

    /**
     * Illegal work area specified.
     */
    public final static int SAV_RST_ILWORK = FACILITY_SAV_RST + (-7*256);

    /**
     * Work area is full. You must declare a larger work area with the SRWAIN
     * call.
     */
    public final static int SAV_RST_WORK_FULL = FACILITY_SAV_RST + (-8*256);

    /**
     * Work area empty on SRPROC call. You must first store at least one
     * request in the work area before calling SRPROC.
     */
    public final static int SAV_RST_EMPTY = FACILITY_SAV_RST + (-9*256);

    /**
     * An invalid length has been specified.
     */
    public final static int SAV_RST_ILLEN = FACILITY_SAV_RST + (-10*256);

    /**
     * Illegal save/restore handler code.
     */
    public final static int SAV_RST_ILSRCODE = FACILITY_SAV_RST + (-11*256);

    /**
     * Save already in progress on another console.
     */
    public final static int SAV_RST_INPROGRESS = FACILITY_SAV_RST + (-12*256);

    /**
     * No save file specified.
     */
    public final static int SAV_RST_NOFILE = FACILITY_SAV_RST + (-13*256);

    /**
     * Insufficient quota.  Delete some files if you want to continue.
     */
    public final static int SAV_RST_INSQUOTA = FACILITY_SAV_RST + (-14*256);

    /**
     * Illegal typecode specified.
     */
    public final static int SAV_RST_ITYC = FACILITY_SAV_RST + (-15*256);

    /**
     * Data overflow.  Not enough room in reply buffer for data.
     */
    public final static int SAV_RST_OVFLOW = FACILITY_SAV_RST + (-16*256);

    /**
     * Illegal length or offset specified.
     */
    public final static int SAV_RST_ILLENOROFF = FACILITY_SAV_RST + (-17*256);

    /**
     * Illegal date specified.
     */
    public final static int SAV_RST_ILDATE = FACILITY_SAV_RST + (-18*256);

    /**
     * No such save file. The file cannot be opened.
     */
    public final static int SAV_RST_OPENFAIL = FACILITY_SAV_RST + (-19*256);

    /**
     * No such device index (DI) in the save/restore log.
     */
    public final static int SAV_RST_NODI = FACILITY_SAV_RST + (-20*256);

    /**
     * Illegal parameter in request.
     */
    public final static int SAV_RST_ILPA = FACILITY_SAV_RST + (-21*256);

    /**
     * No data for request. None of the subsystem list IDs exist, hence there
     * is nothing to save.
     */
    public final static int SAV_RST_NODATA = FACILITY_SAV_RST + (-22*256);

    /**
     * Network request has been seriously corrupted.
     */
    public final static int SAV_RST_JUNK = FACILITY_SAV_RST + (-23*256);

    /**
     * System service or directive error. This error is not expected to occur.
     * Please, contact the maintainer of the save/restore system.
     */
    public final static int SAV_RST_SSDE = FACILITY_SAV_RST + (-24*256);

    /**
     * The SRREAD process has terminated or was never started in the first
     * place.
     */
    public final static int SAV_RST_NOREADPROC = FACILITY_SAV_RST + (-25*256);

    /**
     * Read error on a file has occurred.
     */
    public final static int SAV_RST_READERR = FACILITY_SAV_RST + (-26*256);

    /**
     * Forever pending from a front end. Please, make sure all front ends are
     * up and running.
     */
    public final static int SAV_RST_PENDFOREVER = FACILITY_SAV_RST + (-27*256);

    /**
     * Illegal packet type encountered.
     */
    public final static int SAV_RST_ILPT = FACILITY_SAV_RST + (-28*256);

    /**
     * This DI/PI had an error when saved.
     */
    public final static int SAV_RST_SAVEDWERR = FACILITY_SAV_RST + (-29*256);

    /**
     * Illegal request at this time, i.e. unsupported feature.
     */
    public final static int SAV_RST_NOTYET = FACILITY_SAV_RST + (-30*256);

    /**
     * Allocation error has occurred due to excessive number of DI packets.
     */
    public final static int SAV_RST_ALER = FACILITY_SAV_RST + (-31*256);

    /**
     * Console mask protection error.
     */
    public final static int SAV_RST_CONM = FACILITY_SAV_RST + (-32*256);

    /**
     * Storage data acquisition subsequence case over before active data
     * collection was completed.
     */
    public final static int SAV_RST_CASE = FACILITY_SAV_RST + (-34*256);

    /**
     * The property in question has a save file error.
     */
    public final static int SAV_RST_PRER = FACILITY_SAV_RST + (-35*256);

    /**
     * Basic control set failed due to a bad PDB (scaling information).
     */
    public final static int SAV_RST_BADPDB = FACILITY_SAV_RST + (-36*256);

    /**
     * Basic control set failed due to the fact that the device is in local.
     */
    public final static int SAV_RST_DEVINLOCAL = FACILITY_SAV_RST + (-37*256);

    /**
     * Basic control set failed due to a timeout on reading basic status.
     */
    public final static int SAV_RST_TMO = FACILITY_SAV_RST + (-38*256);

    /**
     * Requested collection not found in file.
     */
    public final static int SAV_RST_NO_COLLECTION = FACILITY_SAV_RST + (-39*256);

    /**
     * Canceling a set collection before starting the same set collection.
     */
    public final static int SAV_RST_SET = FACILITY_SAV_RST + (-40*256);

    /**
     * Set collection canceled on a noop (e.g. did not qualify).
     */
    public final static int SAV_RST_NOOP = FACILITY_SAV_RST + (-41*256);

    /**
     * RDAT_CAM facility
     */
    public final static int FACILITY_RDAT_CAM = 33;
    public final static int RDAT_CAM_OK = 0;
    public final static int RDAT_CAM_SUCCESS = 0;

    /**
     * Reply pending: This means that Retdat noticed that data hasn't been
     * updated by the data gathering task.  Usually the result will appear
     * later.  From the point of view of application programs this is the same
     * as DPM_PEND (17 1).
     */
    public final static int RDAT_CAM_PEND = FACILITY_RDAT_CAM + (1*256);

    /**
     * E.SSDR: Illegal SDRPID (Subsystems Device Record Packet ID), which is
     * located in the Subsystem's Device Number. The user should check the
     * database entry for the affected device.
     */
    public final static int RDAT_CAM_INVALID_SDRPID = FACILITY_RDAT_CAM + (-64*256);

    /**
     * E.IFMT: Illegal format code in Subsystems Device Record packet.
     */
    public final static int RDAT_CAM_INV_SSDR_FORMAT_CODE = FACILITY_RDAT_CAM + (-65*256);

    /**
     * E.ZLEN: Zero length specified. The front end cannot process a datapool
     * request having a zero length.
     */
    public final static int RDAT_CAM_ZERO_LEN_REQ = FACILITY_RDAT_CAM + (-66*256);

    /**
     * E.BLEN: Specified length is not a multiple of number of houses. The
     * 'length' of data requested from a wildcard device must be a multiple of
     * the number of houses in the group.
     */
    public final static int RDAT_CAM_INV_WCARD_LEN = FACILITY_RDAT_CAM + (-67*256);

    /**
     * E.XCON: Internal error E.XCON.  Please, contact the appropriate front
     * end programmer.
     */
    public final static int RDAT_CAM_XCON = FACILITY_RDAT_CAM + (-68*256);

    /**
     * E.IOFF: Illegal offset specified.  The offset lies in the middle of a
     * quantum.  Many array devices consist of multi-byte, indivisible quanta.
     * The user must specify a length and offset which are consistent with the
     * internal structure of these devices.
     */
    public final static int RDAT_CAM_INVALID_OFFSET = FACILITY_RDAT_CAM + (-69*256);

    /**
     * E.ILEN: Illegal length specified.  The length may either be too large,
     * or it may request a non-integral number of quanta.  Many array devices
     * consist of multi-byte, indivisible quanta.  The user must specify a
     * length and offset which are consistent with the internal structure of
     * these devices.
     */
    public final static int RDAT_CAM_INVALID_LENGTH = FACILITY_RDAT_CAM + (-70*256);

    /**
     * E.NODT: Offset extends beyond the limit of available data.
     */
    public final static int RDAT_CAM_OFFSET_TOO_BIG = FACILITY_RDAT_CAM + (-71*256);

    /**
     * E.ICNT: GAS count exceeds number of bytes available.  This error
     * indicates a problem either with the database entry or with the TAN map
     * located in the front end.
     */
    public final static int RDAT_CAM_GAS_LEN_EXCEEDED = FACILITY_RDAT_CAM + (-72*256);

    /**
     * E.ABMA: 'MA' not permitted with alarm blocks
     */
    public final static int RDAT_CAM_ALARM_BLOCK_MA = FACILITY_RDAT_CAM + (-73*256);

    /**
     * E.ABCT: GAS count for alarm block not equal to four.  This error
     * indicates a problem with the database entry for the affected device.
     */
    public final static int RDAT_CAM_GAS_AB_COUNT_ERR = FACILITY_RDAT_CAM + (-74*256);

    /**
     * E.ABSZ: Incorrect size for alarm block aspect.
     */
    public final static int RDAT_CAM_AB_ASPECT_SIZE_ERR = FACILITY_RDAT_CAM + (-75*256);

    /**
     * E.IMOD: Illegal module code in Subsystems Device Record packet.
     */
    public final static int RDAT_CAM_INV_SSDR_MODULE_CODE = FACILITY_RDAT_CAM + (-76*256);

    /**
     * E.ILGT: Illegal GAS type.  This error indicates either a problem with
     * the database entry for the affected device, or the TAN map (in the front
     * end) has not been updated to include the GAS type.
     */
    public final static int RDAT_CAM_INVALID_GAS_TYPE = FACILITY_RDAT_CAM + (-77*256);

    /**
     * E.ILGA: Illegal GAS aspect.  This error indicates either a problem with
     * the database entry for the affected device, or the TAN map (in the front
     * end) has not been updated to include the GAS aspect.
     */
    public final static int RDAT_CAM_INVALID_GAS_ASPECT = FACILITY_RDAT_CAM + (-78*256);

    /**
     * E.ILGN: Illegal GAS entry.  This error indicates either a problem with
     * the database entry for the affected device, or the TAN map (in the front
     * end) has not been updated to include the GAS entry.
     */
    public final static int RDAT_CAM_INVALID_GAS_ENTRY = FACILITY_RDAT_CAM + (-79*256);

    /**
     * E.ENCT: Entry count discrepancy.
     */
    public final static int RDAT_CAM_ENTRY_COUNT_ERROR = FACILITY_RDAT_CAM + (-80*256);

    /**
     * E.TRUN: Request truncated (network buffer not large enough).
     */
    public final static int RDAT_CAM_REQUEST_TRUNC = FACILITY_RDAT_CAM + (-81*256);

    /**
     * E.RLOV: Packet overflows request list.  This is probably a DPM problem.
     * Please, contact the maintainer of the DPM process.
     */
    public final static int RDAT_CAM_REQ_LIST_OVFLOW = FACILITY_RDAT_CAM + (-82*256);

    /**
     * E.ZENT: Request contains zero entries.  This is probably a DPM problem.
     * Please, contact the maintainer of the DPM process.
     */
    public final static int RDAT_CAM_ZERO_ENTRY_REQ = FACILITY_RDAT_CAM + (-83*256);

    /**
     * E.RPOV: Reply buffer overflow. Restructure the request so that fewer
     * bytes need to be returned in each request.  RETDAT currently supports a
     * reply buffer of 8192 bytes.
     */
    public final static int RDAT_CAM_REPLY_BUFFER_OVFLOW = FACILITY_RDAT_CAM + (-84*256);

    /**
     * E.TDLF: TDL Full.  Please, contact the appropriate front end programmer.
     */
    public final static int RDAT_CAM_TDL_FULL = FACILITY_RDAT_CAM + (-85*256);

    /**
     * E.MULR: Multiple replies specified for a setting. This is a DPM problem.
     * Please, contact the maintainer of the DPM process.
     */
    public final static int RDAT_CAM_MULT_REPLY_SET = FACILITY_RDAT_CAM + (-86*256);

    /**
     * E.BCCT: GAS count for basic control not equal to one.  This error
     * indicates a problem in the database entry for the affected device.
     */
    public final static int RDAT_CAM_GAS_BCNTRL_COUNT_ERR = FACILITY_RDAT_CAM + (-87*256);

    /**
     * E.BCSZ: Incorrect size for basic control aspect.  This error indicates a
     * problem in the TAN map. Please, contact the appropriate front end
     * programmer.
     */
    public final static int RDAT_CAM_BCNTRL_ASPECT_SIZ_ERR = FACILITY_RDAT_CAM + (-88*256);

    /**
     * E.ICWC: Illegal CAMAC word count (or illegal packing mode).  This error
     * indicates a problem in the database entry for the affected device.
     */
    public final static int RDAT_CAM_INV_CAMAC_WORD_CNT = FACILITY_RDAT_CAM + (-89*256);

    /**
     * E.IPRP: Illegal property for selective data acquisition (RETDAT).  An
     * attempt has been made to read the basic control property.
     */
    public final static int RDAT_CAM_INV_READ_PROPERTY = FACILITY_RDAT_CAM + (-90*256);

    /**
     * E.IIDR: Illegal internal data request.  This error indicates a problem
     * in the database entry for the affected device.
     */
    public final static int RDAT_CAM_INV_INTERNAL_DATA_REQ = FACILITY_RDAT_CAM + (-91*256);

    /**
     * E.WILD: Illegal wildcard (multi-house) operation.  Most likely, an
     * attempt has been made to perform a setting to a wildcard device.
     * Wildcard settings are not supported.
     */
    public final static int RDAT_CAM_INV_WILDCARD_OP = FACILITY_RDAT_CAM + (-92*256);

    /**
     * E.ISPR: An illegal special request was detected by RETDAT.
     */
    public final static int RDAT_CAM_INV_SPECIAL_REQUEST = FACILITY_RDAT_CAM + (-93*256);

    /**
     * E.GALB: An illegal GAS/system error alarm block addressing parameter was
     * detected.  This may be due to a problem in the database entry (SSDN) for
     * the affected device.  It is possible (though unlikely) that a problem
     * exists in the front end TAN map.
     */
    public final static int RDAT_CAM_INV_GAS_AB_ADDRESS = FACILITY_RDAT_CAM + (-94*256);

    /**
     * E.GASHOUSE: GAS house code is out of range.  This error indicates a
     * problem in the database entry for the affected device.
     */
    public final static int RDAT_CAM_INV_GAS_HOUSE_CODE = FACILITY_RDAT_CAM + (-95*256);

    /**
     * E.DEFTRIG: Error defining trigger.  This is an inner front end problem.
     * Please, contact the appropriate front end programmer.
     */
    public final static int RDAT_CAM_TRIGGER_DEF_ERROR = FACILITY_RDAT_CAM + (-96*256);

    /**
     * E.MALLOC: Error allocating memory. This is an inner front end problem.
     * Please, contact the appropriate front end programmer.
     */
    public final static int RDAT_CAM_MALLOC_ERROR = FACILITY_RDAT_CAM + (-97*256);

    /**
     * E.DEVALLOC: Devalloc queue is filled up.  Try to delete some of the
     * running application programs.  If this doesn't help, it is an inner
     * front end problem.  In that case, contact the appropriate front end
     * programmer.
     */
    public final static int RDAT_CAM_DEVALLOC_QUEUE_FULL = FACILITY_RDAT_CAM + (-98*256);

    /**
     * E.RNOQ: RETDAT internal queue is filled.  Try to delete some of the
     * running application programs.  If this doesn't help, it is an inner
     * front end problem.  In that case, contact the appropriate front end
     * programmer.
     */
    public final static int RDAT_CAM_RETDAT_QUEUE_FULL = FACILITY_RDAT_CAM + (-99*256);

    /**
     * E.TOOLONG: Too many STANCs were built from one request by the GAS
     * gathering task.  The limit now is 128.
     */
    public final static int RDAT_CAM_TOO_MANY_STANCS = FACILITY_RDAT_CAM + (-100*256);

    /**
     * E.NODATA: No data accompanies a setting request to the GAS gathering
     * task. Check the application program that you are using.  If it is OK,
     * the problem possibly is in the data pool.
     */
    public final static int RDAT_CAM_NO_GAS_SET_DATA = FACILITY_RDAT_CAM + (-101*256);

    /**
     * E.DOUBLE: Invalid entry double sequential request.  If you are sure that
     * your application is fine, discuss the problem with the front end
     * programmer.
     */
    public final static int RDAT_CAM_INV_DOUBLE_SEQ_REQ = FACILITY_RDAT_CAM + (-102*256);

    /**
     * E.MCOM: The request cannot be honored due to a memory allocation failure
     * in the large dynamic pool MCOM.  This error is not expected to occur.
     * Please, contact the appropriate front end programmer.
     */
    public final static int RDAT_CAM_MCOM_MEMFAIL = FACILITY_RDAT_CAM + (-103*256);

    /**
     * E.TCOM: Front end is temporarily out of memory (TCOM full).  Please,
     * wait a few seconds and try again.
     */
    public final static int RDAT_CAM_OUTOMEM = FACILITY_RDAT_CAM + (-104*256);

    /**
     * E.RTRM: Due to a critical shortage of memory in the front end, the
     * request has been involuntarily terminated.  Try reissuing the request
     * later.
     */
    public final static int RDAT_CAM_REQUEST_TERMINATED = FACILITY_RDAT_CAM + (-105*256);

    /**
     * E.SSDN: Unrecognizable SSDN.  This is probably a database problem.
     */
    public final static int RDAT_CAM_INVALID_SSDN = FACILITY_RDAT_CAM + (-106*256);

    /**
     * E.GASOUTFLM: GAS gathering task is out of local memory.  Please, contact
     * the appropriate front end programmer.
     */
    public final static int RDAT_CAM_GAS_MEMFAIL = FACILITY_RDAT_CAM + (-110*256);

    /**
     * RDAT_MR facility
     */
    public final static int FACILITY_RDAT_MR = 34;
    public final static int RDAT_MR_OK = 0;
    public final static int RDAT_MR_SUCCESS = 0;

    /**
     * Pending.
     */
    public final static int RDAT_MR_PEND = FACILITY_RDAT_MR + (1*256);

    /**
     * Invalid MAC number.
     */
    public final static int RDAT_MR_INVMAC = FACILITY_RDAT_MR + (-1*256);

    /**
     * Invalid typecode.
     */
    public final static int RDAT_MR_INVTYP = FACILITY_RDAT_MR + (-2*256);

    /**
     * Timeout on PDPMAC transmission.
     */
    public final static int RDAT_MR_TIMOUT = FACILITY_RDAT_MR + (-3*256);

    /**
     * MDC error.
     */
    public final static int RDAT_MR_MDCERR = FACILITY_RDAT_MR + (-4*256);

    /**
     * Bad A.I. for KAD
     */
    public final static int RDAT_MR_KADERR = FACILITY_RDAT_MR + (-5*256);

    /**
     * Busy on PDPMAC transmission.
     */
    public final static int RDAT_MR_BUSY = FACILITY_RDAT_MR + (-6*256);

    /**
     * No D/A entry in table.
     */
    public final static int RDAT_MR_NENTRY = FACILITY_RDAT_MR + (-7*256);

    /**
     * No Front Porch data pool.
     */
    public final static int RDAT_MR_NFRPCH = FACILITY_RDAT_MR + (-8*256);

    /**
     * Deallocate memory failed.
     */
    public final static int RDAT_MR_MEMDEA = FACILITY_RDAT_MR + (-9*256);

    /**
     * Invalid property.
     */
    public final static int RDAT_MR_INVPRP = FACILITY_RDAT_MR + (-10*256);

    /**
     * Invalid offset or length.
     */
    public final static int RDAT_MR_INVARY = FACILITY_RDAT_MR + (-11*256);

    /**
     * Invalid frequency time descriptor.
     */
    public final static int RDAT_MR_INVFTD = FACILITY_RDAT_MR + (-13*256);

    /**
     * Unsupported frequency time descriptor.
     */
    public final static int RDAT_MR_USPFTD = FACILITY_RDAT_MR + (-14*256);

    /**
     * Maximum support by MAC, entry not available.
     */
    public final static int RDAT_MR_MAXMAC = FACILITY_RDAT_MR + (-15*256);

    /**
     * Unsupported property.
     */
    public final static int RDAT_MR_USPPRP = FACILITY_RDAT_MR + (-16*256);

    /**
     * MAC does not respond.
     */
    public final static int RDAT_MR_NORESP = FACILITY_RDAT_MR + (-17*256);

    /**
     * MAC is busy.
     */
    public final static int RDAT_MR_MACBSY = FACILITY_RDAT_MR + (-18*256);

    /**
     * No such device.
     */
    public final static int RDAT_MR_NODEV = FACILITY_RDAT_MR + (-19*256);

    /**
     * Not in the alarm scan.
     */
    public final static int RDAT_MR_NALS = FACILITY_RDAT_MR + (-20*256);

    /**
     * EXTEND task is down.
     */
    public final static int RDAT_MR_XDWN = FACILITY_RDAT_MR + (-21*256);

    /**
     * KBD index out of range
     */
    public final static int RDAT_MR_KBDERR = FACILITY_RDAT_MR + (-22*256);

    /**
     * Out of memory.
     */
    public final static int RDAT_MR_SPAC = FACILITY_RDAT_MR + (-64*256);

    /**
     * RDAT_LIN facility
     */
    public final static int FACILITY_RDAT_LIN = 36;
    public final static int RDAT_LIN_OK = 0;
    public final static int RDAT_LIN_SUCCESS = 0;

    /**
     * Access to memory produced a bus error.
     */
    public final static int RDAT_LIN_BUS_ERROR = FACILITY_RDAT_LIN + (-4*256);

    /**
     * Server node detected tardy response from target node. Absence of 15Hz
     * interrupt. Replying node reset but did not accept retry.
     */
    public final static int RDAT_LIN_TARDY_RESPONSE = FACILITY_RDAT_LIN + (-7*256);

    /**
     * Server node detected no response from target node. Is target node
     * running and open onto network?
     */
    public final static int RDAT_LIN_NO_RESPONSE = FACILITY_RDAT_LIN + (-8*256);

    /**
     * An event occurred while waiting for the delay from a previous occurrence
     * of the same event.
     */
    public final static int RDAT_LIN_EVENT_DURING_DELAY = FACILITY_RDAT_LIN + (-9*256);

    /**
     * Cannot queue external request to network. Network queue full? Consult an
     * expert.
     */
    public final static int RDAT_LIN_CANT_QUEUE_REQ = FACILITY_RDAT_LIN + (-32*256);

    /**
     * Request message size not large enough for #request packets. Consult an
     * expert.
     */
    public final static int RDAT_LIN_REQ_TOO_SMALL = FACILITY_RDAT_LIN + (-33*256);

    /**
     * Could not obtain request id from LISTP table. Consult an expert. Reset
     * local station.
     */
    public final static int RDAT_LIN_NO_REQ_ID = FACILITY_RDAT_LIN + (-34*256);

    /**
     * #request packets not in valid range 1-299. Consult an expert.
     */
    public final static int RDAT_LIN_INV_NUM_REQS = FACILITY_RDAT_LIN + (-35*256);

    /**
     * Allocation of dynamic memory failed. Consult an expert. Reset local
     * station. XON/XOFF suppression of serial output?
     */
    public final static int RDAT_LIN_MALLOC_FAIL = FACILITY_RDAT_LIN + (-36*256);

    /**
     * Invalid listype# from SSDN hi byte of first word.
     */
    public final static int RDAT_LIN_LIST_TYPE_BAD = FACILITY_RDAT_LIN + (-37*256);

    /**
     * Invalid ident type#. Consult an expert.
     */
    public final static int RDAT_LIN_ID_TYPE_BAD = FACILITY_RDAT_LIN + (-38*256);

    /**
     * Invalid ident length from SSDN bit#3-0 of first word.
     */
    public final static int RDAT_LIN_ID_LEN_BAD = FACILITY_RDAT_LIN + (-39*256);

    /**
     * Invalid #bytes of data requested. #bytes outside of range 1-5000. #bytes
     * requested not multiple of datum size for array case. Invalid #bytes of
     * setting data. #bytes of data too large for size of setting message.
     */
    public final static int RDAT_LIN_NUM_BYTES_BAD = FACILITY_RDAT_LIN + (-40*256);

    /**
     * Total #idents in all request packets >= 1200. #idents in single array
     * request packet > 256.
     */
    public final static int RDAT_LIN_NUM_IDS_TOO_BIG = FACILITY_RDAT_LIN + (-41*256);

    /**
     * Total #bytes of answers >= 5000.
     */
    public final static int RDAT_LIN_ANS_NBYTES_TOO_BIG = FACILITY_RDAT_LIN + (-42*256);

    /**
     * Total #bytes of answers > maximum in request packet.
     */
    public final static int RDAT_LIN_ANS_NBYTES_GT_MAX = FACILITY_RDAT_LIN + (-43*256);

    /**
     * Offset/length option not enabled in this SSDN. Offset into arbitrary
     * data structure not supported.
     */
    public final static int RDAT_LIN_OFFSET_NOTENB = FACILITY_RDAT_LIN + (-44*256);

    /**
     * UDP/IP setting denied by IP security table.
     */
    public final static int RDAT_LIN_IP_SECURITY = FACILITY_RDAT_LIN + (-45*256);

    /**
     * #setting packets not in valid range 1-299. Consult an expert.
     */
    public final static int RDAT_LIN_NUM_SETS_BAD = FACILITY_RDAT_LIN + (-46*256);

    /**
     * Internal read routine# invalid. Consult an expert.
     */
    public final static int RDAT_LIN_READ_RTN_NUM_BAD = FACILITY_RDAT_LIN + (-47*256);

    /**
     * Node# word is zero in SSDN second word.
     */
    public final static int RDAT_LIN_ZERO_NODE = FACILITY_RDAT_LIN + (-48*256);

    /**
     * Can't find destination task name for this protocol. Local application
     * protocol handler installed? enabled?
     */
    public final static int RDAT_LIN_NO_DEST_TSKNAM = FACILITY_RDAT_LIN + (-49*256);

    /**
     * System table not defined for this listype#. SSDN invalid?
     */
    public final static int RDAT_LIN_NO_TABLE = FACILITY_RDAT_LIN + (-65*256);

    /**
     * Entry# (chan#, bit#, etc) out of range. SSDN invalid?
     */
    public final static int RDAT_LIN_NO_ENTRY_NUM = FACILITY_RDAT_LIN + (-66*256);

    /**
     * Odd #bytes of setting data.
     */
    public final static int RDAT_LIN_NUM_BYTES_ODD = FACILITY_RDAT_LIN + (-67*256);

    /**
     * Bus error on write.
     */
    public final static int RDAT_LIN_WRITE_BUS_ERROR = FACILITY_RDAT_LIN + (-68*256);

    /**
     * #bytes of setting data too small.
     */
    public final static int RDAT_LIN_SET_NBYTES_TOO_SML = FACILITY_RDAT_LIN + (-69*256);

    /**
     * #bytes of setting data too large.
     */
    public final static int RDAT_LIN_SET_NBYTES_TOO_BIG = FACILITY_RDAT_LIN + (-70*256);

    /**
     * Invalid #bytes of setting data.
     */
    public final static int RDAT_LIN_SET_NBYTES_BAD = FACILITY_RDAT_LIN + (-71*256);

    /**
     * Internal set-type# out of range. Consult an expert.
     */
    public final static int RDAT_LIN_SET_TYPE_NUM_BAD = FACILITY_RDAT_LIN + (-72*256);

    /**
     * Settings not allowed for this listype#. SSDN invalid?
     */
    public final static int RDAT_LIN_NO_SETS = FACILITY_RDAT_LIN + (-73*256);

    /**
     * Analog control type# out of range in local database.
     */
    public final static int RDAT_LIN_ANA_CTL_TYPE_BAD = FACILITY_RDAT_LIN + (-74*256);

    /**
     * Invalid binary byte address in BADDR table.
     */
    public final static int RDAT_LIN_BBA_BAD = FACILITY_RDAT_LIN + (-75*256);

    /**
     * Invalid mpx channel# (Linac D/A hardware)
     */
    public final static int RDAT_LIN_MPX_CHAN_NUM_BAD = FACILITY_RDAT_LIN + (-76*256);

    /**
     * F3 scale factor out of range (motor #steps processing) in local
     * database.
     */
    public final static int RDAT_LIN_SCALE_FACTOR_BAD = FACILITY_RDAT_LIN + (-77*256);

    /**
     * No CPROQ table or co-processor# out of range.
     */
    public final static int RDAT_LIN_NO_CPU = FACILITY_RDAT_LIN + (-78*256);

    /**
     * Hardware D/A board address odd.
     */
    public final static int RDAT_LIN_HBA_ODD = FACILITY_RDAT_LIN + (-79*256);

    /**
     * Bit# index out of range (associated bit control via channel)
     */
    public final static int RDAT_LIN_BIT_NUM_BAD = FACILITY_RDAT_LIN + (-80*256);

    /**
     * Bit# out of range for this station's database.
     */
    public final static int RDAT_LIN_BITNUM_TOO_BIG = FACILITY_RDAT_LIN + (-81*256);

    /**
     * Digital Control Delay table full (for software-formed pulses).
     */
    public final static int RDAT_LIN_DCD_TABLE_FULL = FACILITY_RDAT_LIN + (-82*256);

    /**
     * Digital control type# out of range 1-15.
     */
    public final static int RDAT_LIN_DIG_CTL_TYPE_BAD = FACILITY_RDAT_LIN + (-83*256);

    /**
     * Co-processor command queue unavailable. CPROQ table?
     */
    public final static int RDAT_LIN_CPU_FULL = FACILITY_RDAT_LIN + (-84*256);

    /**
     * Co-processor invalid queue header.
     */
    public final static int RDAT_LIN_CPU_INV_QUEUE = FACILITY_RDAT_LIN + (-85*256);

    /**
     * Queue full or unavailable.
     */
    public final static int RDAT_LIN_QUEUE_FULL = FACILITY_RDAT_LIN + (-86*256);

    /**
     * Dynamic memory allocation failed. Consult an expert. Reset station.
     */
    public final static int RDAT_LIN_MEMFAIL = FACILITY_RDAT_LIN + (-87*256);

    /**
     * Error status from 1553 controller.
     */
    public final static int RDAT_LIN_1553_ERROR = FACILITY_RDAT_LIN + (-88*256);

    /**
     * Invalid 1553 command for one word output. 1553 command block?
     */
    public final static int RDAT_LIN_INV_1553_CMND = FACILITY_RDAT_LIN + (-89*256);

    /**
     * Invalid 1553 Command Block address (must be multiple of 16).
     */
    public final static int RDAT_LIN_INV_1553_CB_ADDR = FACILITY_RDAT_LIN + (-90*256);

    /**
     * Invalid 1553 order code in first word of Command Block.
     */
    public final static int RDAT_LIN_INV_1553_ORDER_CODE = FACILITY_RDAT_LIN + (-91*256);

    /**
     * 1553 interrupts not working. Consult an expert.
     */
    public final static int RDAT_LIN_NO_1553_INTERRUPTS = FACILITY_RDAT_LIN + (-92*256);

    /**
     * Cannot initialize 1553 command queue. Consult an expert.
     */
    public final static int RDAT_LIN_1553_INIT_QUEUE_ERR = FACILITY_RDAT_LIN + (-93*256);

    /**
     * No Q1553 table of pointers to 1553 controller queues. Consult an expert.
     */
    public final static int RDAT_LIN_NO_1553_TABLE_PTRS = FACILITY_RDAT_LIN + (-94*256);

    /**
     * Invalid Motor table.
     */
    public final static int RDAT_LIN_MOTOR_TABLE_BAD = FACILITY_RDAT_LIN + (-95*256);

    /**
     * Motor table full. Too many motors active at once?
     */
    public final static int RDAT_LIN_MOTOR_TABLE_FULL = FACILITY_RDAT_LIN + (-96*256);

    /**
     * Invalid 9513 timing channel pair. V177 board access.
     */
    public final static int RDAT_LIN_INV_9513_TIM_CHAN = FACILITY_RDAT_LIN + (-97*256);

    /**
     * Timing event# out of range.
     */
    public final static int RDAT_LIN_TIMING_EVENT_NUM_BAD = FACILITY_RDAT_LIN + (-98*256);

    /**
     * Invalid data value.
     */
    public final static int RDAT_LIN_INVALID_DATA = FACILITY_RDAT_LIN + (-99*256);

    /**
     * Invalid #bytes of text in Comment alarm control (D0).
     */
    public final static int RDAT_LIN_NBYTES_TEXT_BAD = FACILITY_RDAT_LIN + (-100*256);

    /**
     * No DSTRM table of Data Stream queue pointers.
     */
    public final static int RDAT_LIN_NO_DSTRM_TABLE = FACILITY_RDAT_LIN + (-101*256);

    /**
     * Data Stream queue type# out of range.
     */
    public final static int RDAT_LIN_BAD_DSTRM_QUEUE_TYPE = FACILITY_RDAT_LIN + (-102*256);

    /**
     * Data Stream queue not initialized.
     */
    public final static int RDAT_LIN_NO_DSTRM_QUEUE_INIT = FACILITY_RDAT_LIN + (-103*256);

    /**
     * No MMAPS table of memory-mapped board templates.
     */
    public final static int RDAT_LIN_NO_MMAPS_TABLE = FACILITY_RDAT_LIN + (-104*256);

    /**
     * Invalid MMAPS table header.
     */
    public final static int RDAT_LIN_INV_MMAPS_HEADER = FACILITY_RDAT_LIN + (-105*256);

    /**
     * Invalid MMAPS table entry size.
     */
    public final static int RDAT_LIN_INV_MMAPS_ENTRY_SIZE = FACILITY_RDAT_LIN + (-106*256);

    /**
     * Invalid board# for MMAPS table.
     */
    public final static int RDAT_LIN_INV_MMAPS_BOARD_NUM = FACILITY_RDAT_LIN + (-107*256);

    /**
     * Invalid directory entry in MMAPS table.
     */
    public final static int RDAT_LIN_INV_MMAPS_DIR_ENTRY = FACILITY_RDAT_LIN + (-108*256);

    /**
     * End of MMAPS table reached during template processing.
     */
    public final static int RDAT_LIN_MMAPS_END_OF_TABLE = FACILITY_RDAT_LIN + (-109*256);

    /**
     * Invalid MMAPS command type code.
     */
    public final static int RDAT_LIN_INV_MMAPS_CMND_TYPE = FACILITY_RDAT_LIN + (-110*256);

    /**
     * Invalid MMAPS loop params.
     */
    public final static int RDAT_LIN_INV_MMAPS_LOOP = FACILITY_RDAT_LIN + (-111*256);

    /**
     * MMAPS memory write verify error.
     */
    public final static int RDAT_LIN_MMAPS_WRITE_ERROR = FACILITY_RDAT_LIN + (-112*256);

    /**
     * Invalid listype#. SSDN hi byte of first word?
     */
    public final static int RDAT_LIN_INV_LISTTYPE_NUM = FACILITY_RDAT_LIN + (-114*256);

    /**
     * Invalid ident type# (error in listype table). Consult an expert.
     */
    public final static int RDAT_LIN_INV_LISTTYPE_ID_TYPE = FACILITY_RDAT_LIN + (-115*256);

    /**
     * Invalid ident length for this listype. SSDN bit#3-0 first word?
     */
    public final static int RDAT_LIN_INV_LISTTYPE_ID_LEN = FACILITY_RDAT_LIN + (-116*256);

    /**
     * Little console settings keyswitch disabled.
     */
    public final static int RDAT_LIN_KEYSWITCH_DISABLED = FACILITY_RDAT_LIN + (-117*256);

    /**
     * Little console external settings switch disabled.
     */
    public final static int RDAT_LIN_EXT_SWITCH_DISABLED = FACILITY_RDAT_LIN + (-118*256);

    /**
     * Data Server setting not implemented. (D0)
     */
    public final static int RDAT_LIN_D0_DATA_SERVE = FACILITY_RDAT_LIN + (-119*256);

    /**
     * Invalid listype for this Acnet property. Alarm block setting?
     */
    public final static int RDAT_LIN_INV_LISTTYPE_PROP = FACILITY_RDAT_LIN + (-120*256);

    /**
     * Invalid byte address pair in BADDR table. Consult an expert.
     */
    public final static int RDAT_LIN_BYTE_ADDR_PAIR_INV = FACILITY_RDAT_LIN + (-121*256);

    /**
     * Invalid sequence of program downloading settings.
     */
    public final static int RDAT_LIN_SET_SEQUENCE_INV = FACILITY_RDAT_LIN + (-122*256);

    /**
     * Memory verify error with listype# 72(longwords) or 77(words).
     */
    public final static int RDAT_LIN_MEM_VERIFY_ERR = FACILITY_RDAT_LIN + (-123*256);

    /**
     * RDAT_OPR facility
     */
    public final static int FACILITY_RDAT_OPR = 39;
    public final static int RDAT_OPR_OK = 0;
    public final static int RDAT_OPR_SUCCESS = 0;

    /**
     * Your request is pending.  When data is available it will be sent.
     */
    public final static int RDAT_OPR_E_PEND = FACILITY_RDAT_OPR + (1*256);

    /**
     * Illegal device index.
     */
    public final static int RDAT_OPR_E_ILDI = FACILITY_RDAT_OPR + (-1*256);

    /**
     * Illegal property code.
     */
    public final static int RDAT_OPR_E_ILPR = FACILITY_RDAT_OPR + (-2*256);

    /**
     * Truncated datapool requests are not supported.
     */
    public final static int RDAT_OPR_E_RTL = FACILITY_RDAT_OPR + (-3*256);

    /**
     * No such property supported for device.
     */
    public final static int RDAT_OPR_E_NSPR = FACILITY_RDAT_OPR + (-4*256);

    /**
     * USMs not supported for readings.
     */
    public final static int RDAT_OPR_E_USM = FACILITY_RDAT_OPR + (-5*256);

    /**
     * Illegal length offset.
     */
    public final static int RDAT_OPR_E_ILOF = FACILITY_RDAT_OPR + (-6*256);

    /**
     * Unsupported SSDN subtypecode.
     */
    public final static int RDAT_OPR_E_USTC = FACILITY_RDAT_OPR + (-7*256);

    /**
     * Unsupported SSDN typecode.
     */
    public final static int RDAT_OPR_E_UTC = FACILITY_RDAT_OPR + (-8*256);

    /**
     * No such VAX process active.
     */
    public final static int RDAT_OPR_E_NSP = FACILITY_RDAT_OPR + (-9*256);

    /**
     * Bad length.
     */
    public final static int RDAT_OPR_E_BLEN = FACILITY_RDAT_OPR + (-10*256);

    /**
     * SSDN subtypecode out of range.
     */
    public final static int RDAT_OPR_E_JOOR = FACILITY_RDAT_OPR + (-11*256);

    /**
     * Unsupported data return freqency for this request.
     */
    public final static int RDAT_OPR_E_UFTD = FACILITY_RDAT_OPR + (-12*256);

    /**
     * Your device could not be initialized.  Either the local datapool is full
     * or the database returned an error when trying to recall the last value
     * of the device.
     */
    public final static int RDAT_OPR_E_SYS = FACILITY_RDAT_OPR + (-13*256);

    /**
     * RDAT_BRF facility
     */
    public final static int FACILITY_RDAT_BRF = 43;
    public final static int RDAT_BRF_OK = 0;
    public final static int RDAT_BRF_SUCCESS = 0;

    /**
     * Pending.
     */
    public final static int RDAT_BRF_PEND = FACILITY_RDAT_BRF + (1*256);

    /**
     * Invalid MAC number.
     */
    public final static int RDAT_BRF_INVMAC = FACILITY_RDAT_BRF + (-1*256);

    /**
     * Invalid typecode.
     */
    public final static int RDAT_BRF_INVTYP = FACILITY_RDAT_BRF + (-2*256);

    /**
     * Timeout on PDPMAC transmission.
     */
    public final static int RDAT_BRF_TIMOUT = FACILITY_RDAT_BRF + (-3*256);

    /**
     * MDC error.
     */
    public final static int RDAT_BRF_MDCERR = FACILITY_RDAT_BRF + (-4*256);

    /**
     * Bad A.I. for KAD
     */
    public final static int RDAT_BRF_KADERR = FACILITY_RDAT_BRF + (-5*256);

    /**
     * Busy on PDPMAC transmission.
     */
    public final static int RDAT_BRF_BUSY = FACILITY_RDAT_BRF + (-6*256);

    /**
     * No D/A entry in table.
     */
    public final static int RDAT_BRF_NENTRY = FACILITY_RDAT_BRF + (-7*256);

    /**
     * No Front Porch data pool.
     */
    public final static int RDAT_BRF_NFRPCH = FACILITY_RDAT_BRF + (-8*256);

    /**
     * Deallocate memory failed.
     */
    public final static int RDAT_BRF_MEMDEA = FACILITY_RDAT_BRF + (-9*256);

    /**
     * Invalid property.
     */
    public final static int RDAT_BRF_INVPRP = FACILITY_RDAT_BRF + (-10*256);

    /**
     * Invalid offset or length.
     */
    public final static int RDAT_BRF_INVARY = FACILITY_RDAT_BRF + (-11*256);

    /**
     * Invalid frequency time descriptor.
     */
    public final static int RDAT_BRF_INVFTD = FACILITY_RDAT_BRF + (-13*256);

    /**
     * Unsupported frequency time descriptor.
     */
    public final static int RDAT_BRF_USPFTD = FACILITY_RDAT_BRF + (-14*256);

    /**
     * Maximum support by MAC, entry not available.
     */
    public final static int RDAT_BRF_MAXMAC = FACILITY_RDAT_BRF + (-15*256);

    /**
     * Unsupported property.
     */
    public final static int RDAT_BRF_USPPRP = FACILITY_RDAT_BRF + (-16*256);

    /**
     * MAC does not respond.
     */
    public final static int RDAT_BRF_NORESP = FACILITY_RDAT_BRF + (-17*256);

    /**
     * MAC is busy.
     */
    public final static int RDAT_BRF_MACBSY = FACILITY_RDAT_BRF + (-18*256);

    /**
     * No such device.
     */
    public final static int RDAT_BRF_NODEV = FACILITY_RDAT_BRF + (-19*256);

    /**
     * Not in the alarm scan.
     */
    public final static int RDAT_BRF_NALS = FACILITY_RDAT_BRF + (-20*256);

    /**
     * EXTEND task is down.
     */
    public final static int RDAT_BRF_XDWN = FACILITY_RDAT_BRF + (-21*256);

    /**
     * KBD index out of range
     */
    public final static int RDAT_BRF_KBDERR = FACILITY_RDAT_BRF + (-22*256);

    /**
     * Out of memory.
     */
    public final static int RDAT_BRF_SPAC = FACILITY_RDAT_BRF + (-64*256);

    /**
     * RDAT_QPM facility
     */
    public final static int FACILITY_RDAT_QPM = 44;
    public final static int RDAT_QPM_OK = 0;
    public final static int RDAT_QPM_SUCCESS = 0;

    /**
     * The length you are asking for exceeds maximum allowed.  This is probably
     * a bad database entry
     */
    public final static int RDAT_QPM_BAD_LENGTH = FACILITY_RDAT_QPM + (-100*256);

    /**
     * The offset with the length requested is outside the maximum range for
     * this device.   This is probably a database entry problem.
     */
    public final static int RDAT_QPM_BAD_OFFSET = FACILITY_RDAT_QPM + (-101*256);

    /**
     * The database entry has an illegal entry number encoded in the SSDN OMSP
     * (OOC Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_ENTRY = FACILITY_RDAT_QPM + (-102*256);

    /**
     * The database entry has an illegal lead number encoded in the SSDN OMSP
     * (OOC Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_LEAD = FACILITY_RDAT_QPM + (-103*256);

    /**
     * The database entry has an illegal quench protection unit number encoded
     * in the SSDN OMSP (OOC Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_QPU = FACILITY_RDAT_QPM + (-104*256);

    /**
     * The database entry has an illegal quench detection unit number encoded
     * in the SSDN OMSP (OOC Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_QDU = FACILITY_RDAT_QPM + (-105*256);

    /**
     * The database entry has an illegal voltage to ground tap number encoded
     * in the SSDN OMSP (OOC Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_VTG = FACILITY_RDAT_QPM + (-106*256);

    /**
     * The database entry has an illegal element number encoded in the SSDN
     * OMSP (OOC message specific parameters)
     */
    public final static int RDAT_QPM_BAD_ELEMENT = FACILITY_RDAT_QPM + (-107*256);

    /**
     * The database entry has an illegal index encoded in the SSDN OMSP (OOC
     * Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_INDEX = FACILITY_RDAT_QPM + (-109*256);

    /**
     * The database entry has an illegal mask encoded in the SSDN OMSP (OOC
     * Message Specific Parameters)
     */
    public final static int RDAT_QPM_BAD_MASK = FACILITY_RDAT_QPM + (-110*256);

    /**
     * The data your are sending is outside of the allowable range to set the
     * reboot lockout current
     */
    public final static int RDAT_QPM_BAD_RLI = FACILITY_RDAT_QPM + (-111*256);

    /**
     * CAMFE2 facility
     */
    public final static int FACILITY_CAMFE2 = 45;
    public final static int CAMFE2_OK = 0;
    public final static int CAMFE2_SUCCESS = 0;

    /**
     * Too many CDF High Voltage PCs: The current version of the front end
     * software supports up to 10 CDF High Voltage PCs, connected to the front
     * end via an RS232 interface.  If you need more active PCs, talk to the
     * front end programmers.  If you have fewer than 10 PCs and you are seeing
     * this problem, it means that something is wrong with the database
     * devices.
     */
    public final static int CAMFE2_TOO_MANY_PCS = FACILITY_CAMFE2 + (-1*256);

    /**
     * Too many CDF High Voltage PC devices: The current version of the CDF
     * front end software supports arbitration for up to 768 database devices
     * (different names).  If you need more, talk to the front end programmers.
     */
    public final static int CAMFE2_TOO_MANY_PC_DEVS = FACILITY_CAMFE2 + (-2*256);

    /**
     * CDF High Voltage PC returned an error code: The PC which supports these
     * devices responded with a '?' error code.  This can be caused by a
     * database problem (the name you are using is not supported for this PC),
     * an RS232 communication problem (in this casethe error should come and
     * go), or some unknown reason within the PC software.
     */
    public final static int CAMFE2_HV_PC_ERROR = FACILITY_CAMFE2 + (-3*256);

    /**
     * Data conversion problem from CDF High Voltage PC: Data received from a
     * CDF High Voltage PC could not, for some reason, be interpreted.
     * Sometimes this is caused by an RS232 communications problem.  It might
     * be necessary to reboot either the PC itself or the front end computer.
     */
    public final static int CAMFE2_HV_PC_CONVERT_ERROR = FACILITY_CAMFE2 + (-4*256);

    /**
     * CDF High Voltage PC device name conflict: This is a database problem
     * which occurs when the front end receives several requests with the same
     * name, but different physical crate/slot/subaddress for a CDF High
     * Voltage PC.
     */
    public final static int CAMFE2_HV_PC_NAME_CONFLICT = FACILITY_CAMFE2 + (-5*256);

    /**
     * Block transfer unassigned buffer: This is a front end internal problem.
     * You should notify the appropriate front end programmer.
     */
    public final static int CAMFE2_BLK_XFER_BAD_BUFFER = FACILITY_CAMFE2 + (-6*256);

    /**
     * Block transfer FIFO full: Hardware problem with the block transfer
     * controller.  Report it to the appropriate engineer.  If this becomes
     * really bad, you can try to switch block transfer off (see error 18 -79
     * for instructions.)
     */
    public final static int CAMFE2_BLK_XFER_FIFO_FULL = FACILITY_CAMFE2 + (-7*256);

    /**
     * Block transfer unexpected DRMQ: Hardware problem with the block transfer
     * controller. Report it to the appropriate engineer.  If this becomes
     * really bad, you can try to switch block transfer off (see error 18 -79
     * for instructions.)
     */
    public final static int CAMFE2_BLK_XFER_UNEX_DRMQ = FACILITY_CAMFE2 + (-8*256);

    /**
     * Block transfer crate controller is active: Hardware problem with the
     * block transfer controller. Report it to the appropriate engineer.  If
     * this becomes really bad, you can try to switch block transfer off (see
     * error 18 -79 for instructions.)
     */
    public final static int CAMFE2_BLK_XFER_CC_ACTIVE = FACILITY_CAMFE2 + (-9*256);

    /**
     * Block transfer FIFO not empty: Hardware problem with the block transfer
     * controller. Report it to the appropriate engineer.  If this becomes
     * really bad, you can try to switch block transfer off (see error 18 -79
     * for instructions.)
     */
    public final static int CAMFE2_BLK_XFR_FIFO_NOTEMPTY = FACILITY_CAMFE2 + (-10*256);

    /**
     * Drivers MXBFIFO bad parameter: This is a front end internal problem.
     * You should notify the appropriate front end programmer and try to
     * explain what program you were running or which devices you were
     * accessing.
     */
    public final static int CAMFE2_MXBFIFO_BAD_PARAM = FACILITY_CAMFE2 + (-11*256);

    /**
     * The card you are trying to talk to is in the middle of reset operation.
     * SAMs (3527 cards) are doing periodic self calibration.  During this time
     * it is impossible to do readings.  Don't panic.  This error is normal.
     * If it persists, you might try replacing the SAM.
     */
    public final static int CAMFE2_DEVICE_BEING_RESET = FACILITY_CAMFE2 + (-12*256);

    /**
     * CDF High Voltage PC is permanently busy: The RS232 communications FIFO
     * (on a CAMAC 3344 card) for transmitting to a CDF High Voltage PC is
     * full.  There can be several reasons for this: somebody unplugged the PC
     * from the 3344 card; the PC is malfunctioning, sick or off;
     * communications with the PC are completely faulty; etc.
     */
    public final static int CAMFE2_HV_PC_BUSY = FACILITY_CAMFE2 + (-13*256);

    /**
     * Triggers problem in drivers: This is a front end internal problem.  You
     * should notify the appropriate front end programmer.
     */
    public final static int CAMFE2_TRIGGERS_ERROR = FACILITY_CAMFE2 + (-14*256);

    /**
     * Fake setting are not allowed for this device: The Fake Setting parameter
     * on DPSET/DPSRPY specifies that the setting value will be transmitted to
     * the front end, but the front end will not actually control any hardware.
     * This option is available for only afew types of devices, and is used
     * almost exclusively during the reboot process.  If you get this error,
     * you are trying a fake setting to a device which does not support this
     * option.  If you think you MUST have it, see a front end programmer.
     */
    public final static int CAMFE2_NO_FAKE_SETTING = FACILITY_CAMFE2 + (-15*256);

    /**
     * Error in the Front End internal 4208 card tables: This is a front end
     * internal problem.  You should notify the appropriate front end
     * programmer.
     */
    public final static int CAMFE2_4208_TABLE_ERROR = FACILITY_CAMFE2 + (-16*256);

    /**
     * Persistent communication problem with CDF High Voltage PC: The front end
     * can't get a reply back from the PC, even after retrying several times in
     * a row.  Check whether the PC to which you are trying to talk is alive,
     * and if it is, then double check the cabling between PC and 3344 card.
     * You might have to reboot either the PC itself or the front end computer.
     */
    public final static int CAMFE2_HV_PC_COMM_ERROR = FACILITY_CAMFE2 + (-17*256);

    /**
     * Error in the Front End internal GAS speaking routines: This is a front
     * end internal problem.  You should notify the appropriate front end
     * programmer.
     */
    public final static int CAMFE2_INTERNAL_GAS_ERROR = FACILITY_CAMFE2 + (-18*256);

    /**
     * CAEN failure: CAEN subsytem failure.  You should consult CDF PC
     * programmer about the source of this problem.
     */
    public final static int CAMFE2_CAEN_ERROR = FACILITY_CAMFE2 + (-19*256);

    /**
     * GAS dispatch is out of stacks: GAS gathering task has overflowed the
     * internal delay queue.  You can try to stop some of the applications
     * using GAS speakers.  If this doesn't help, you might try to reboot the
     * GAS module.  Please notify the front end programmers if this error
     * persists.
     */
    public final static int CAMFE2_GAS_STACK_OVERFLOW = FACILITY_CAMFE2 + (-20*256);

    /**
     * SWIC/SEM scanner internal error: This is a front end internal problem.
     * You should notify the appropriate front end programmer.
     */
    public final static int CAMFE2_SWIC_SEM_SCANNER_ERR = FACILITY_CAMFE2 + (-21*256);

    /**
     * Frig node is down: This error will occur if you are trying to talk to
     * one of the FRIG ringwide devices.  If the error persists, make sure that
     * the node is really down (by using the application talking to this
     * particular house) and reboot FRIG.
     */
    public final static int CAMFE2_FRIG_NODE_DOWN = FACILITY_CAMFE2 + (-22*256);

    /**
     * SCIOQ input queue error: This is a front end internal problem.  You
     * should notify the appropriate front end programmer.
     */
    public final static int CAMFE2_SCIOQ_QUEUE_ERROR = FACILITY_CAMFE2 + (-23*256);

    /**
     * Frig zero length reply: This is a front end internal problem.  You
     * should notify the appropriate front end programmer.
     */
    public final static int CAMFE2_FRIG_ZERO_LEN_REPLY = FACILITY_CAMFE2 + (-24*256);

    /**
     * TECAR facility
     */
    public final static int FACILITY_TECAR = 46;
    public final static int TECAR_OK = 0;
    public final static int TECAR_SUCCESS = 0;

    /**
     * For RPC experts only: The TECAR library routine that was called is
     * unable to serialize its argument(s). This could be due to either a bad
     * pointer being passed, or something being passed incorrectly, or a
     * pointer to the wrong type of object being passed. Your application
     * should not return this error status if the TECAR library is fully
     * debugged. This error status indicates that there may be a bug in the
     * TECAR library routine that your application called.
     */
    public final static int TECAR_CANTENCODEARGS = FACILITY_TECAR + (-1*256);

    /**
     * For RPC experts only: The TECAR library routine that was called is
     * unable to deserialize its results. This could be due to either a bad
     * pointer being passed, or something being passed incorrectly, or a
     * pointer to the wrong type of object being passed. Your application
     * should not return this error status if the TECAR library is fully
     * debugged. This error status indicates that there may be a bug in the
     * TECAR library routine that your application called.
     */
    public final static int TECAR_CANTDECODERES = FACILITY_TECAR + (-2*256);

    /**
     * For RPC experts only: The TECAR library routine is unable to send the
     * Remote Procedure Call request. The reason for this is typically due to
     * networking failure. Your application should not return this error status
     * if the TECAR library is fully debugged. This error status indicates that
     * there may be a bug in the TECAR library routine that your application
     * called.
     */
    public final static int TECAR_CANTSEND = FACILITY_TECAR + (-3*256);

    /**
     * For RPC experts only: The TECAR library routine didn't get the results
     * back from the Remote Procedure Call. The reason for this is typically
     * due to networking failure, but it could also be caused by TECAR
     * crashing. Your application should not return thiserror status if the
     * TECAR library is fully debugged. This error status indicates that there
     * may be a bug in the TECAR library routine that your application called.
     */
    public final static int TECAR_CANTRECV = FACILITY_TECAR + (-4*256);

    /**
     * For RPC experts only: The communications between TECAR and this console
     * timed out. This is most likely due to a networking failure. Your
     * application should not return this error status if the TECAR library is
     * fully debugged. This error status indicates that there may be a bug in
     * the TECAR library routine that your application called.
     */
    public final static int TECAR_TIMEDOUT = FACILITY_TECAR + (-5*256);

    /**
     * For RPC experts only: The TECAR library specified a version of a
     * particular Remote Procedure Call that didn't match the version of that
     * remote procedure that is curently in use by TECAR. The solution is to
     * correct the version mistmatch, which may be in the TECAR library, or on
     * TECAR itself. Your application should not return this error status if
     * the TECAR library is fully debugged. This error status indicates that
     * there may be a bug in the TECAR library routine that your application
     * called.
     */
    public final static int TECAR_VERSMISMATCH = FACILITY_TECAR + (-6*256);

    /**
     * For RPC experts only: Error authenticating this request. You should
     * never get this error because TECAR does not currently do authentication.
     * Your application should not return this error status if the TECAR
     * library is fully debugged. This error status indicates that there may be
     * a bug in the TECAR library routine that your application called.
     */
    public final static int TECAR_AUTHERROR = FACILITY_TECAR + (-7*256);

    /**
     * For RPC experts only: The TECAR library asked for a program that TECAR
     * does not have available. The only 'program' that TECAR has available is
     * the 'TECAR' 'program', which is the only 'program' that the TECAR
     * library knows about. Theoretically, this error should never occur. Your
     * application should not return this error status if the TECAR library is
     * fully debugged. This error status indicates that there may be a bug in
     * the TECAR library routine that your application called.
     */
    public final static int TECAR_PROGUNAVAIL = FACILITY_TECAR + (-8*256);

    /**
     * For RPC experts only: The TECAR 'program' version doesn't match the
     * TECAR 'program' version that is encoded into the TECAR library. The
     * solution to this problem is to make TECAR and all consoles use the same
     * 'program' version. This error should never happen, and will probably
     * only ever happen if the wrong version of a library or object module
     * accidentally gets distributed. Your application should not return this
     * error status if the TECAR library is fully debugged. This error status
     * indicates that there may be a bug in the TECAR library routine that your
     * application called.
     */
    public final static int TECAR_PROGVERSMISMATCH = FACILITY_TECAR + (-9*256);

    /**
     * For RPC experts only: The remote procedure that was specified inside of
     * a TECAR library routine is not known by TECAR. The cause of this is
     * usually an administration error, and can be corrected by insuring that
     * TECAR itself is running the right code, or by insuring that this console
     * is running a version of the TECAR library that is compatible with the
     * version that the TECAR system is running. Your application should not
     * return this error status if the TECAR library is fully debugged. This
     * error status indicates that there may be a bug in the TECAR library
     * routine that your application called.
     */
    public final static int TECAR_PROCUNAVAIL = FACILITY_TECAR + (-10*256);

    /**
     * For RPC experts only: The TECAR system is unable to deserialize its
     * argument(s). This could be due to either a bad pointer being passed, or
     * something being passed incorrectly, or a pointer to the wrong type of
     * object being passed. Your application shouldnot return this error status
     * if the TECAR library is fully debugged. This error status indicates that
     * there may be a bug in the TECAR library routine that your application
     * called.
     */
    public final static int TECAR_CANTDECODEARGS = FACILITY_TECAR + (-11*256);

    /**
     * For RPC experts only: This could be caused by a network failure. It is
     * definitely a problem for an RPC expert to solve. Your application should
     * not return this error status if the TECAR library is fully debugged.
     * This error status indicates that there may be a bug in the TECAR library
     * routine that your application called.
     */
    public final static int TECAR_SYSTEMERROR = FACILITY_TECAR + (-12*256);

    /**
     * For RPC experts only: The TCP/IP layer of software running on this
     * console is unable to find the Internet address of the TECAR system,
     * given by the application program. The most-likely cause of this problem
     * would be if the application program gave the wrong name of the TECAR
     * system, or passed the name incorrectly. The correct name for any TECAR
     * system would be either 'tecar_mp' or 'tecar_a2'. Another, less-likely
     * cause of this problem would be if the domain nameservers had 'lost' the
     * name of this system,or weren't working correctly, for one reason or
     * another. Your application should not return this error status if the
     * TECAR library is fully debugged. This error status indicates that there
     * may be a bug in the TECAR library routine that your application called.
     */
    public final static int TECAR_UNKNOWNHOST = FACILITY_TECAR + (-13*256);

    /**
     * For RPC experts only: The TECAR library is asking for a service on the
     * TECAR system that has not yet registered with the portmapper on that
     * system. The most-likely cause of this error would be if the TECAR server
     * subsystem was not running on the TECAR system. If you get this error,
     * the best thing to do would be to ask a TECAR expert, such as Bob Flora
     * or Kevin Martin. Your application should not return this error status if
     * the TECAR library is fully debugged. This error status indicates that
     * there may bea bug in the TECAR library routine that your application
     * called.
     */
    public final static int TECAR_PMAPFAILURE = FACILITY_TECAR + (-14*256);

    /**
     * For RPC experts only: The TECAR library is asking for a service on the
     * TECAR system that has not yet registered with the portmapper on that
     * system. The most-likely cause of this error would be if the TECAR server
     * subsystem was not running on the TECAR system. If you get this error,
     * the best thing to do would be to ask a TECAR expert, such as Bob Flora
     * or Kevin Martin. Your application should not return this error status if
     * the TECAR library is fully debugged. This error status indicates that
     * there may bea bug in the TECAR library routine that your application
     * called.
     */
    public final static int TECAR_PROGNOTREGISTERED = FACILITY_TECAR + (-15*256);

    /**
     * For RPC experts only: This could be caused by a network failure. It is
     * definitely a problem for an RPC expert to solve. Your application should
     * not return this error status if the TECAR library is fully debugged.
     * This error status indicates that there may be a bug in the TECAR library
     * routine that your application called.
     */
    public final static int TECAR_FAILED = FACILITY_TECAR + (-16*256);

    /**
     * For RPC experts only: The protocol that was requested from within the
     * TECAR library is not a valid RPC protocol for the TECAR system. This
     * error should never occur in a debugged TECAR library. The only valid
     * protocols are TCP and IP. (I believe that TECAR only uses TCP.) Your
     * application should not return this error status if the TECAR library is
     * fully debugged. This error status indicates that there may be a bug in
     * the TECAR library routine that your application called.
     */
    public final static int TECAR_UNKNOWNPROTO = FACILITY_TECAR + (-17*256);

    /**
     * The pointer passed to the TECAR UTI by the application program was bad.
     * In the case of the pointer to the string containing the name of the
     * TECAR system to which you are going to communicate with (which is always
     * the first argument in any of the user-callable functions in the TECAR
     * UTI), this pointer must be either a pointer to a null-terminated string
     * (as a standard string in C) or it must be a pointer to a VMS character
     * descriptor.
     */
    public final static int TECAR_BADPOINTER = FACILITY_TECAR + (-24*256);

    /**
     * The name of the TECAR system passed to the TECAR UTI was bad. Currently
     * the only valid names are 'tecar_mp' and 'tecar_a2'.
     */
    public final static int TECAR_TECAR_BADNAME = FACILITY_TECAR + (-25*256);

    /**
     * The snapshot failed.
     */
    public final static int TECAR_TECAR_SNAP_FAIL = FACILITY_TECAR + (-26*256);

    /**
     * The string passed to t_qbst() containing the sector and controller to
     * test (for the Quench Bypass Switch test) was invalid. Proper sector
     * strings are two characters in length, where the first character is the
     * sector, which may be one of 'A', 'B', 'C', 'D', 'E', or 'F', and the
     * second character is the controller, which may be 'A' or 'B'.
     */
    public final static int TECAR_TECAR_BAD_SECTOR = FACILITY_TECAR + (-27*256);

    /**
     * RDAT_BPM facility
     */
    public final static int FACILITY_RDAT_BPM = 47;
    public final static int RDAT_BPM_OK = 0;
    public final static int RDAT_BPM_SUCCESS = 0;

    /**
     * Measurement is pending waiting for arm and/or trigger conditions
     */
    public final static int RDAT_BPM_PEND = FACILITY_RDAT_BPM + (1*256);

    /**
     * Unsupported class number
     */
    public final static int RDAT_BPM_BADCLASSN = FACILITY_RDAT_BPM + (-1*256);

    /**
     * Can't add any more objects, objarray filled
     */
    public final static int RDAT_BPM_OBJSFULL = FACILITY_RDAT_BPM + (-2*256);

    /**
     * Unsupported message type
     */
    public final static int RDAT_BPM_BADMT = FACILITY_RDAT_BPM + (-3*256);

    /**
     * Instance variables too long
     */
    public final static int RDAT_BPM_BADLENIVS = FACILITY_RDAT_BPM + (-4*256);

    /**
     * Too many superclasses
     */
    public final static int RDAT_BPM_SCLSSUN = FACILITY_RDAT_BPM + (-5*256);

    /**
     * Duplicated class definition
     */
    public final static int RDAT_BPM_DUPCLASS = FACILITY_RDAT_BPM + (-6*256);

    /**
     * Duplicated OID definition
     */
    public final static int RDAT_BPM_DUPOID = FACILITY_RDAT_BPM + (-7*256);

    /**
     * Superclass for this device is not defined
     */
    public final static int RDAT_BPM_SCLSSND = FACILITY_RDAT_BPM + (-8*256);

    /**
     * Class for this OID is not defined
     */
    public final static int RDAT_BPM_CLASSND = FACILITY_RDAT_BPM + (-9*256);

    /**
     * This OID is not defined
     */
    public final static int RDAT_BPM_OIDND = FACILITY_RDAT_BPM + (-10*256);

    /**
     * Supermethod is not defined
     */
    public final static int RDAT_BPM_SUPMND = FACILITY_RDAT_BPM + (-11*256);

    /**
     * Not enough memory for class
     */
    public final static int RDAT_BPM_CLCRMEM = FACILITY_RDAT_BPM + (-12*256);

    /**
     * Not enough memory for this instance of class
     */
    public final static int RDAT_BPM_INCRMEM = FACILITY_RDAT_BPM + (-13*256);

    /**
     * Empty name
     */
    public final static int RDAT_BPM_NAMEND = FACILITY_RDAT_BPM + (-14*256);

    /**
     * Class storage is not enough for this message type
     */
    public final static int RDAT_BPM_MSGOVL = FACILITY_RDAT_BPM + (-15*256);

    /**
     * Message type is not supported by this OID
     */
    public final static int RDAT_BPM_UNSUPMT = FACILITY_RDAT_BPM + (-16*256);

    /**
     * Instance variables too short
     */
    public final static int RDAT_BPM_LENNEN = FACILITY_RDAT_BPM + (-17*256);

    /**
     * ACNET error
     */
    public final static int RDAT_BPM_ACNERR = FACILITY_RDAT_BPM + (-18*256);

    /**
     * Inner memory problems
     */
    public final static int RDAT_BPM_INMEM = FACILITY_RDAT_BPM + (-19*256);

    /**
     * Bad list request parameters
     */
    public final static int RDAT_BPM_BADLIST = FACILITY_RDAT_BPM + (-20*256);

    /**
     * Error defining trigger
     */
    public final static int RDAT_BPM_TRIGGER = FACILITY_RDAT_BPM + (-21*256);

    /**
     * Bad frequency time descriptor
     */
    public final static int RDAT_BPM_BADFTD = FACILITY_RDAT_BPM + (-22*256);

    /**
     * Bad setting parameters
     */
    public final static int RDAT_BPM_BADSET = FACILITY_RDAT_BPM + (-23*256);

    /**
     * Bad local area network in database entry
     */
    public final static int RDAT_BPM_BADLAN = FACILITY_RDAT_BPM + (-24*256);

    /**
     * Bad node defined in database entry
     */
    public final static int RDAT_BPM_BADNODE = FACILITY_RDAT_BPM + (-25*256);

    /**
     * Bad format
     */
    public final static int RDAT_BPM_BADFORM = FACILITY_RDAT_BPM + (-26*256);

    /**
     * Bad list property index
     */
    public final static int RDAT_BPM_BADLPI = FACILITY_RDAT_BPM + (-27*256);

    /**
     * The database offset is either negative or larger than the data.
     */
    public final static int RDAT_BPM_BADOFFSET = FACILITY_RDAT_BPM + (-28*256);

    /**
     * The database length doesn't match the length of the data.
     */
    public final static int RDAT_BPM_BADLENGTH = FACILITY_RDAT_BPM + (-29*256);

    /**
     * Setting timeout
     */
    public final static int RDAT_BPM_SETTMO = FACILITY_RDAT_BPM + (-30*256);

    /**
     * The data array doesn't match the database entry.
     */
    public final static int RDAT_BPM_BADENTRY = FACILITY_RDAT_BPM + (-31*256);

    /**
     * The data for this machine cycle is not available.
     */
    public final static int RDAT_BPM_BADCYCLE = FACILITY_RDAT_BPM + (-32*256);

    /**
     * This input doesn't exist.
     */
    public final static int RDAT_BPM_BADCHANNEL = FACILITY_RDAT_BPM + (-33*256);

    /**
     * Bad length plus offset
     */
    public final static int RDAT_BPM_BADOFLEN = FACILITY_RDAT_BPM + (-34*256);

    /**
     * This position channel doesn't exist in this BPM.
     */
    public final static int RDAT_BPM_BADPOS = FACILITY_RDAT_BPM + (-35*256);

    /**
     * This intensity channel doesn't exist in this BPM.
     */
    public final static int RDAT_BPM_BADINT = FACILITY_RDAT_BPM + (-36*256);

    /**
     * Wrong device type
     */
    public final static int RDAT_BPM_WRONGTP = FACILITY_RDAT_BPM + (-37*256);

    /**
     * Wrong basic control word
     */
    public final static int RDAT_BPM_WRBASCON = FACILITY_RDAT_BPM + (-38*256);

    /**
     * Stop data taking: Data taking must be halted when reading this data.
     */
    public final static int RDAT_BPM_STOPDATA = FACILITY_RDAT_BPM + (-39*256);

    /**
     * The data structure doesn't match the array size of the request.
     */
    public final static int RDAT_BPM_BADELEMENT = FACILITY_RDAT_BPM + (-40*256);

    /**
     * Alarm is not defined yet
     */
    public final static int RDAT_BPM_NOALRM = FACILITY_RDAT_BPM + (-41*256);

    /**
     * Alarm property is not supported
     */
    public final static int RDAT_BPM_ALRSUPPORT = FACILITY_RDAT_BPM + (-42*256);

    /**
     * The combination of the offset and element has indexed out of the data
     * array size.
     */
    public final static int RDAT_BPM_BADINDEX = FACILITY_RDAT_BPM + (-43*256);

    /**
     * There was no new data this cycle.  BPM may have a trigger problem or
     * there was no beam.
     */
    public final static int RDAT_BPM_NO_DATA = FACILITY_RDAT_BPM + (-44*256);

    /**
     * Timing system status error
     */
    public final static int RDAT_BPM_TSG_STATUS_ERROR = FACILITY_RDAT_BPM + (-45*256);

    /**
     * Missing MDAT interrupt
     */
    public final static int RDAT_BPM_NO_MDAT_INT = FACILITY_RDAT_BPM + (-46*256);

    /**
     * Measurement timed out.
     */
    public final static int RDAT_BPM_TIMEOUT = FACILITY_RDAT_BPM + (-47*256);

    /**
     * Closed orbit synchronization trigger not received
     */
    public final static int RDAT_BPM_CO_TIMEOUT = FACILITY_RDAT_BPM + (-48*256);

    /**
     * Invalid measurement mode requested
     */
    public final static int RDAT_BPM_INVALID_MODE = FACILITY_RDAT_BPM + (-49*256);

    /**
     * ADC initialization failed
     */
    public final static int RDAT_BPM_NO_ADC = FACILITY_RDAT_BPM + (-50*256);

    /**
     * Timing system initialization failed
     */
    public final static int RDAT_BPM_NO_TSG = FACILITY_RDAT_BPM + (-51*256);

    /**
     * Timestamp device initialization failed
     */
    public final static int RDAT_BPM_NO_CLOCK = FACILITY_RDAT_BPM + (-52*256);

    /**
     * The front end was unable to create a VxWorks message queue.
     */
    public final static int RDAT_BPM_NO_MESSAGE_QUEUE = FACILITY_RDAT_BPM + (-53*256);

    /**
     * The front end was unable to create a VxWorks interrupt service routine.
     */
    public final static int RDAT_BPM_NO_ISR = FACILITY_RDAT_BPM + (-54*256);

    /**
     * The front end was unable to create a VxWorks reboot handler.
     */
    public final static int RDAT_BPM_NO_REBOOT_HANDLER = FACILITY_RDAT_BPM + (-55*256);

    /**
     * The front end was unable to spawn an armed event handler task.
     */
    public final static int RDAT_BPM_NO_ARMED_EVT_HNDLR = FACILITY_RDAT_BPM + (-56*256);

    /**
     * The front end was unable to spawn a measurement handler task.
     */
    public final static int RDAT_BPM_NO_MEASURE_HNDLR = FACILITY_RDAT_BPM + (-57*256);

    /**
     * A bad value for an engineering parameter was found during
     * initialization.
     */
    public final static int RDAT_BPM_BAD_ENG_PARAM = FACILITY_RDAT_BPM + (-58*256);

    /**
     * The front end was unable to create a background measurment control task.
     */
    public final static int RDAT_BPM_NO_BKGD_MEASURE = FACILITY_RDAT_BPM + (-59*256);

    /**
     * The front end was unable to create a repetitive flash control task.
     */
    public final static int RDAT_BPM_NO_REP_FLASH = FACILITY_RDAT_BPM + (-60*256);

    /**
     * Timing system error
     */
    public final static int RDAT_BPM_TSG_ERROR = FACILITY_RDAT_BPM + (-61*256);

    /**
     * ADC error
     */
    public final static int RDAT_BPM_ADC_ERROR = FACILITY_RDAT_BPM + (-62*256);

    /**
     * The requested measurement was aborted.
     */
    public final static int RDAT_BPM_ABORT = FACILITY_RDAT_BPM + (-63*256);

    /**
     * Generic BPM system error
     */
    public final static int RDAT_BPM_GENERIC_ERROR = FACILITY_RDAT_BPM + (-64*256);

    /**
     * Bad acquisition spec enable value
     */
    public final static int RDAT_BPM_BAD_ASPEC_ENABLE = FACILITY_RDAT_BPM + (-96*256);

    /**
     * Bad acquisition spec measurement value
     */
    public final static int RDAT_BPM_BAD_ASPEC_MEAS = FACILITY_RDAT_BPM + (-97*256);

    /**
     * Bad acquisition spec beam mode value
     */
    public final static int RDAT_BPM_BAD_ASPEC_BEAM_MODE = FACILITY_RDAT_BPM + (-98*256);

    /**
     * Bad acquisition spec beam type value
     */
    public final static int RDAT_BPM_BAD_ASPEC_BEAM_TYPE = FACILITY_RDAT_BPM + (-99*256);

    /**
     * Bad acquisition spec measurement type value
     */
    public final static int RDAT_BPM_BAD_ASPEC_MEAS_TYPE = FACILITY_RDAT_BPM + (-100*256);

    /**
     * Bad acquisition spec arm event value
     */
    public final static int RDAT_BPM_BAD_ASPEC_ARM_EVT = FACILITY_RDAT_BPM + (-101*256);

    /**
     * Bad acquisition spec trigger event value
     */
    public final static int RDAT_BPM_BAD_ASPEC_TRIG_EVT = FACILITY_RDAT_BPM + (-102*256);

    /**
     * Bad acquisition spec pretrigger enable value
     */
    public final static int RDAT_BPM_BAD_ASPEC_PTRIG_ENAB = FACILITY_RDAT_BPM + (-103*256);

    /**
     * Bad acquisition spec trigger frequency value
     */
    public final static int RDAT_BPM_BAD_ASPEC_TRIG_FREQ = FACILITY_RDAT_BPM + (-104*256);

    /**
     * Bad acquisition spec trigger delay value
     */
    public final static int RDAT_BPM_BAD_ASPEC_TRIG_DLY = FACILITY_RDAT_BPM + (-105*256);

    /**
     * Bad acquisition spec global delay value
     */
    public final static int RDAT_BPM_BAD_ASPEC_GLBL_DLY = FACILITY_RDAT_BPM + (-106*256);

    /**
     * Bad acquisition spec intensity threshold value
     */
    public final static int RDAT_BPM_BAD_ASPEC_INT_THRSH = FACILITY_RDAT_BPM + (-107*256);

    /**
     * Bad acquisition spec timeout value
     */
    public final static int RDAT_BPM_BAD_ASPEC_TIMEOUT = FACILITY_RDAT_BPM + (-108*256);

    /**
     * Bad readout spec event index value
     */
    public final static int RDAT_BPM_BAD_RSPEC_EVT_INDEX = FACILITY_RDAT_BPM + (-109*256);

    /**
     * Bad readout spec trigger event value
     */
    public final static int RDAT_BPM_BAD_RSPEC_DATA_TYPE = FACILITY_RDAT_BPM + (-110*256);

    /**
     * Bad readout spec beginning turn value
     */
    public final static int RDAT_BPM_BAD_RSPEC_BEG_TURN = FACILITY_RDAT_BPM + (-111*256);

    /**
     * Bad readout spec number of turns value
     */
    public final static int RDAT_BPM_BAD_RSPEC_NUM_TURN = FACILITY_RDAT_BPM + (-112*256);

    /**
     * Bad readout spec beginning turn plus number of turns value
     */
    public final static int RDAT_BPM_BAD_RSPEC_LAST_TURN = FACILITY_RDAT_BPM + (-113*256);

    /**
     * Bad readout spec channel value
     */
    public final static int RDAT_BPM_BAD_RSPEC_CHANNEL = FACILITY_RDAT_BPM + (-114*256);

    /**
     * Bad diagnostic spec channel B value
     */
    public final static int RDAT_BPM_BAD_DSPEC_CHANNEL_B = FACILITY_RDAT_BPM + (-115*256);

    /**
     * Bad diagnostic spec channel A value
     */
    public final static int RDAT_BPM_BAD_DSPEC_CHANNEL_A = FACILITY_RDAT_BPM + (-116*256);

    /**
     * Bad diagnostic spec enable value
     */
    public final static int RDAT_BPM_BAD_DSPEC_ENABLE = FACILITY_RDAT_BPM + (-117*256);

    /**
     * Bad diagnostic spec reserved (must be zero) value
     */
    public final static int RDAT_BPM_BAD_DSPEC_RESERVED = FACILITY_RDAT_BPM + (-118*256);

    /**
     * Bad calibration spec amplitude value
     */
    public final static int RDAT_BPM_BAD_CSPEC_AMPLITUDE = FACILITY_RDAT_BPM + (-119*256);

    /**
     * Bad calibration spec waveform value
     */
    public final static int RDAT_BPM_BAD_CSPEC_WAVEFORM = FACILITY_RDAT_BPM + (-120*256);

    /**
     * Bad calibration spec balance value
     */
    public final static int RDAT_BPM_BAD_CSPEC_BALANCE = FACILITY_RDAT_BPM + (-121*256);

    /**
     * Bad calibration spec reserved (must be zero) value
     */
    public final static int RDAT_BPM_BAD_CSPEC_RESERVED = FACILITY_RDAT_BPM + (-122*256);

    /**
     * OAF facility
     */
    public final static int FACILITY_OAF = 48;
    public final static int OAF_OK = 0;
    public final static int OAF_SUCCESS = 0;

    /**
     * Request is pending.  Your request has been successfully sent to a front
     * end.  No data has come back yet from that request.
     */
    public final static int OAF_PEND = FACILITY_OAF + (1*256);

    /**
     * Memory allocation failure.  Contact the OAF programmer.
     */
    public final static int OAF_MEMFAIL = FACILITY_OAF + (-1*256);

    /**
     * The required setup has not been performed.  Contact the OAF programmer.
     */
    public final static int OAF_NOSETUP = FACILITY_OAF + (-2*256);

    /**
     * An invalid argument has been passed to a function.  Contact the OAF
     * programmer.
     */
    public final static int OAF_INVARG = FACILITY_OAF + (-3*256);

    /**
     * A required file is not open.  Contact the OAF programmer.
     */
    public final static int OAF_NOTOPN = FACILITY_OAF + (-4*256);

    /**
     * Requested feature is not yet supported.  Contact the OAF programmer.
     */
    public final static int OAF_NOTYET = FACILITY_OAF + (-5*256);

    /**
     * Client contributor is not connected to the Open Access Front End.
     */
    public final static int OAF_NOTASK = FACILITY_OAF + (-6*256);

    /**
     * Zero SDPK or request packets were requests.  This is illegal. Contact
     * the OAF programmer.
     */
    public final static int OAF_ZENT = FACILITY_OAF + (-7*256);

    /**
     * Incoming request was too long and truncated.  Contact the OAF programer.
     */
    public final static int OAF_TRUNC = FACILITY_OAF + (-8*256);

    /**
     * Incoming request was too short.  Contact the OAF programmer.
     */
    public final static int OAF_RLOV = FACILITY_OAF + (-9*256);

    /**
     * Reply was too short. Contact the OAF programmer.
     */
    public final static int OAF_RPOV = FACILITY_OAF + (-10*256);

    /**
     * Illegal SSDN.  Contact the OAF programmer.
     */
    public final static int OAF_SSDN = FACILITY_OAF + (-11*256);

    /**
     * The client reply was truncated.  Contact the OAF programmer.
     */
    public final static int OAF_CLTRUNC = FACILITY_OAF + (-12*256);

    /**
     * The client reply's length is bad.  Contact the OAF programmer.
     */
    public final static int OAF_CLLENGTH = FACILITY_OAF + (-13*256);

    /**
     * Requesting multiple replies on sets is not permitted. Contact the OAF
     * programmer.
     */
    public final static int OAF_MULR = FACILITY_OAF + (-14*256);

    /**
     * The client was not responding to requests and has been logged out.
     */
    public final static int OAF_LOGOUT = FACILITY_OAF + (-15*256);

    /**
     * An operational client is running on the wrong ACNET node.
     */
    public final static int OAF_INVNODE = FACILITY_OAF + (-16*256);

    /**
     * OAFC facility
     */
    public final static int FACILITY_OAFC = 49;
    public final static int OAFC_OK = 0;
    public final static int OAFC_SUCCESS = 0;

    /**
     * Conditions mean alarm limits are ignored (no alarms raised)
     */
    public final static int OAFC_ALARM_CONDITION_IGNORE = FACILITY_OAFC + (2*256);

    /**
     * Request is pending.  Your request has been successfully sent to a front
     * end.  No data has come back yet from that request. Indicates a
     * particular Open Access Client did not respond to a reading or setting
     * request in a timely manner.  This could be due tolost communication
     * between the client and the Open Access Server.
     */
    public final static int OAFC_PEND = FACILITY_OAFC + (1*256);

    /**
     * Memory allocation failure.
     */
    public final static int OAFC_MEMFAIL = FACILITY_OAFC + (-1*256);

    /**
     * The required setup has not been performed.
     */
    public final static int OAFC_NOSETUP = FACILITY_OAFC + (-2*256);

    /**
     * An invalid argument has been passed to a function.
     */
    public final static int OAFC_INVARG = FACILITY_OAFC + (-3*256);

    /**
     * A required file is not open.
     */
    public final static int OAFC_NOTOPN = FACILITY_OAFC + (-4*256);

    /**
     * Stale data was returned on a data acquistion access.
     */
    public final static int OAFC_STALE = FACILITY_OAFC + (-5*256);

    /**
     * No such attribute exists for request.
     */
    public final static int OAFC_NOATT = FACILITY_OAFC + (-6*256);

    /**
     * No scaling information was found for this request.
     */
    public final static int OAFC_NOSCALE = FACILITY_OAFC + (-7*256);

    /**
     * The PDB information for this device is bad.
     */
    public final static int OAFC_BADSCALE = FACILITY_OAFC + (-8*256);

    /**
     * Invalid raw data length.
     */
    public final static int OAFC_INVLEN = FACILITY_OAFC + (-9*256);

    /**
     * Setting attempted with OAC settings disabled.
     */
    public final static int OAFC_SETDIS = FACILITY_OAFC + (-10*256);

    /**
     * No such device.
     */
    public final static int OAFC_NOSUCH = FACILITY_OAFC + (-11*256);

    /**
     * Desired service is unavailable.
     */
    public final static int OAFC_UNAVAIL = FACILITY_OAFC + (-12*256);

    /**
     * Invalid device for this operation.
     */
    public final static int OAFC_INVDEV = FACILITY_OAFC + (-13*256);

    /**
     * Scaling failed on this device.
     */
    public final static int OAFC_SCALEFAIL = FACILITY_OAFC + (-14*256);

    /**
     * Program bug-check.
     */
    public final static int OAFC_BUGCHK = FACILITY_OAFC + (-15*256);

    /**
     * Data is corrupted or inconsistent.
     */
    public final static int OAFC_CORRUPT = FACILITY_OAFC + (-16*256);

    /**
     * Invalid raw data offset.
     */
    public final static int OAFC_INVOFF = FACILITY_OAFC + (-17*256);

    /**
     * Requested feature is not yet supported.
     */
    public final static int OAFC_NOTYET = FACILITY_OAFC + (-18*256);

    /**
     * Requested value out of range.
     */
    public final static int OAFC_RANGE = FACILITY_OAFC + (-19*256);

    /**
     * Error resulted from a library calculation. This error is only generated
     * by a specific Open Access Client. It indicates that the caclulation of a
     * synthetic device, using a private caclulation library-routine, failed.
     * The error can only be addressed by the keeper of the OAC that owns the
     * device that is in error.
     */
    public final static int OAFC_LIBERR = FACILITY_OAFC + (-20*256);

    /**
     * Error in calculation due to input device error. Indicates the device
     * reading that are input to the OAC device are returning errors.
     * Persistent problems should be reported to the keeper of the OAC that
     * owns the device.
     */
    public final static int OAFC_INPERR = FACILITY_OAFC + (-21*256);

    /**
     * Generic error--not mapped to a more specific error code.
     */
    public final static int OAFC_GENERR = FACILITY_OAFC + (-22*256);

    /**
     * A setting was attempted with an invalid value, or under an invalid
     * context. This could be due to the OAC not being configured correctly.
     * Or the user is making an invalid requested setting.
     */
    public final static int OAFC_INVSET = FACILITY_OAFC + (-23*256);

    /**
     * There are too few values available to make a calculation.
     */
    public final static int OAFC_TOO_FEW_VALUES = FACILITY_OAFC + (-24*256);

    /**
     * A math exception occurred during a calculation.
     */
    public final static int OAFC_MATH_EXCEPTION = FACILITY_OAFC + (-25*256);

    /**
     * The requested device is not supported by the Open Access Client (OAC).
     */
    public final static int OAFC_UNSUPPORTED = FACILITY_OAFC + (-26*256);

    /**
     * The IP address of the Webservice server for phidget USB is not
     * reachable. Check the setting of the device: element[1]-[4]. Update will
     * take effect after reset.
     */
    public final static int OAFC_BADSERVER = FACILITY_OAFC + (-27*256);

    /**
     * The phidget USB card with the serial number is not attached. Check the
     * setting of the device: element[0]. Another possibility is the webservice
     * server PORT is not correct. Check the setting of the device: element[5].
     * Update will take effect after reset.
     */
    public final static int OAFC_BADSERIALNO = FACILITY_OAFC + (-28*256);

    /**
     * The requested property is invalid in this context.
     */
    public final static int OAFC_INVPROP = FACILITY_OAFC + (-42*256);

    /**
     * OAFP facility
     */
    public final static int FACILITY_OAFP = 50;
    public final static int OAFP_OK = 0;
    public final static int OAFP_SUCCESS = 0;

    /**
     * Pending.
     */
    public final static int OAFP_PEND = FACILITY_OAFP + (1*256);

    /**
     * The detached snapshot plot manager is not connected to its server. SNAP
     * is a process that should be continuously running on node DCE28. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SNAP = FACILITY_OAFP + (-1*256);

    /**
     * The MCRVCR Open Access Client is not connected to its server. MCRVCR is
     * a process that should be continuously running on node DCE31. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MCRVCR = FACILITY_OAFP + (-2*256);

    /**
     * The MIRROR model Open Access Client is not connected to its server.
     * MIRROR is a process that should be continuously running on node DCE32.
     * Contact the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MIRROR = FACILITY_OAFP + (-3*256);

    /**
     * The VSAOSC Open Access Client is not connected to its server. VSAOSC is
     * a process that should be continuously running on node DCE33. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_VSAOSC = FACILITY_OAFP + (-4*256);

    /**
     * The SRFILE model Open Access Client is not connected to its server.
     * SRFILE is a process that should be continuously running on node DCE32.
     * Contact the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SRFILE = FACILITY_OAFP + (-5*256);

    /**
     * The Network ping front end is not connected to its server. NETPNG is a
     * process that should be continuously running on node DUE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_NETPNG = FACILITY_OAFP + (-6*256);

    /**
     * The RRORBL Open Access Client is not connected to its server.  RRORBL is
     * a process that should be continuously running on node DCE08. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_RRORBL = FACILITY_OAFP + (-7*256);

    /**
     * The Tevatron Chromaticity Open Access Client is not connected to its
     * server. TCHROM is a process that should be continuously running on node
     * DCE40.  Contact the Central Services Group. Contact the keeper of the
     * OAC or the Central Services Group.
     */
    public final static int OAFP_TCHROM = FACILITY_OAFP + (-8*256);

    /**
     * The CRYOPC Open Access Client is not connected to its server. CRYOPC is
     * a process that should be continuously running on node DPE10. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CRYOPC = FACILITY_OAFP + (-9*256);

    /**
     * The CACHE Open Access Client is not connected to its server. CACHE is a
     * process that should be continuously running on node DCE30. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CACHE = FACILITY_OAFP + (-10*256);

    /**
     * The GLFRIG Open Access Client is not connected to its server. GLFRIG is
     * a process that should be continuously running on node DCE39. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_GLFRIG = FACILITY_OAFP + (-11*256);

    /**
     * The ECCOLL Open Access Client is not connected to its server. ECCOLL is
     * a process that should be continuously running on node DCE28. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ECCOLL = FACILITY_OAFP + (-12*256);

    /**
     * The ARF1RF Open Access Client is not connected to its server. ARF1RF is
     * a process that should be continuously running on node DCE33. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ARF1RF = FACILITY_OAFP + (-13*256);

    /**
     * The BOOLOS Open Access Client is not connected to its server. BOOLOS is
     * a process that should be continuously running on node DUE11. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BOOLOS = FACILITY_OAFP + (-14*256);

    /**
     * The NUM118 Open Access Client is not connected to its server. NUM118 is
     * a process that should be continuously running on node DUE31. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_NUM118 = FACILITY_OAFP + (-15*256);

    /**
     * The SDASRV model Open Access Client is not connected to its server.
     * SDASRV is a process that runs on node DCE29. Contact Kevin Cahill (or
     * the Central Services Group).
     */
    public final static int OAFP_SDASRV = FACILITY_OAFP + (-16*256);

    /**
     * The BOOOAC Open Access Client is not connected to its server. BOOOAC is
     * a process that should be continuously running on node DCE39. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BOOOAC = FACILITY_OAFP + (-17*256);

    /**
     * The XMLRPC Open Access Client is not connected to its server. XMLRPC is
     * a process that should be continuously running on node LIMELI. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_XMLRPC = FACILITY_OAFP + (-18*256);

    /**
     * The HEARTB Open Access Client is not connected to its server. HEARTB is
     * a process that should be continuously running on node DUE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_HEARTB = FACILITY_OAFP + (-19*256);

    /**
     * The TEVCAL Open Access Client is not connected to its server. TEVCAL is
     * a process that should be continuously running on the node DCE40. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TEVCAL = FACILITY_OAFP + (-20*256);

    /**
     * The OPCOAC Open Access Client is not connected to its server. OPCOAC is
     * a process that should be continuously running on the node DPE09. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_OPCOAC = FACILITY_OAFP + (-21*256);

    /**
     * The Open Access Model LJOAC is not connected to its server. LJOAC is a
     * process that should be continuously running on node DCE28. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_LJOAC = FACILITY_OAFP + (-22*256);

    /**
     * The DPMOAC Open Access Client is not connected to its server. DPMOAC is
     * a process that should be continuously running on node DCE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DPMOAC = FACILITY_OAFP + (-23*256);

    /**
     * The CHLOAC Open Access Client is not connected to its server. CHLOAC is
     * a process that should be continuously running on node DCE39. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CHLOAC = FACILITY_OAFP + (-24*256);

    /**
     * The DBSETS Open Access Client is not connected to its server. DBSETS is
     * a process that should be continuously running on node DCE28. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DBSETS = FACILITY_OAFP + (-25*256);

    /**
     * The LVTEST Open Access Client is not connected to its server. LVTEST is
     * a process that should be continuously running on node DPE03. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_LVTEST = FACILITY_OAFP + (-26*256);

    /**
     * The BRFOAC Open Access Client is not connected to its server. BRFOAC is
     * a process that should be continuously running on node DUE14. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BRFOAC = FACILITY_OAFP + (-27*256);

    /**
     * The TESTJY Open Access Client is not connected to its server. TESTJY is
     * a process that should be continuously running on node DPE03. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TESTJY = FACILITY_OAFP + (-28*256);

    /**
     * The MACSET Open Access Client is not connected to its server. MACSET is
     * a process that should be continuously running on node DCE32. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MACSET = FACILITY_OAFP + (-29*256);

    /**
     * The MJRROR Open Access Client is not connected to its server. MJRROR is
     * a process that should be continuously running on node DCE30. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MJRROR = FACILITY_OAFP + (-30*256);

    /**
     * The MONITR Open Access Client is not connected to its server. MONITR is
     * a process that should be continuously running on node DUE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MONITR = FACILITY_OAFP + (-31*256);

    /**
     * The TEVCOL Open Access client is not connected to its server. TEVCOL is
     * a process that should be continuously running on node DCE03. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TEVCOL = FACILITY_OAFP + (-32*256);

    /**
     * The CBSHOT (Colliding Beams Sequenced Data Acquisition) Open Access
     * Client is not connected to its server.  CBSHOT is a thread that should
     * be continuously running on the Data Acquisition Engine, DCE31. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CBSHOT = FACILITY_OAFP + (-33*256);

    /**
     * The JPLOT Open Access Client is not connected to its server. JPLOT is a
     * process that should be continuously running on node SATURN. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_JPLOT = FACILITY_OAFP + (-34*256);

    /**
     * The PHIDGT Open Access Client is not connected to its server. PHIDGT is
     * a process that should be continuously running on node DPE09. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_PHIDGT = FACILITY_OAFP + (-35*256);

    /**
     * The REMOTE Open Access Client is not connected to its server. REMOTE is
     * a process that should be continuously running on node DCE34. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_REMOTE = FACILITY_OAFP + (-36*256);

    /**
     * The PBSHOT (PBar transfer Sequenced Data Acquisition) Open Access Client
     * is not connected to its server.  PBSHOT is a thread that should be
     * continuously running on the Data Acquisition Engine, DUE08. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_PBSHOT = FACILITY_OAFP + (-37*256);

    /**
     * The NUM121 Open Access Client is not currently running. NUM121 is a
     * process that should be continuously running on node DUE31. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_NUM121 = FACILITY_OAFP + (-38*256);

    /**
     * The EVENTS Open Access Client is not connected to its server. EVENTS is
     * a process that should be continuously running on node DUE09. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_EVENTS = FACILITY_OAFP + (-39*256);

    /**
     * The LJALRM Open Access Client is not connected to its server. LJALRM is
     * a process that should be continuously running on node DUE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_LJALRM = FACILITY_OAFP + (-40*256);

    /**
     * The CRYTST Open Access Client is not connected to its server. CRYTST is
     * a process that should be continuously running on node CRYMES. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CRYTST = FACILITY_OAFP + (-41*256);

    /**
     * The EVENTH Open Access Client is not connected to its server. EVENTH is
     * a process that should be continuously running on node DUE03. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_EVENTH = FACILITY_OAFP + (-42*256);

    /**
     * The BLMLOG Open Access Client is not connected to its server. BLMLOG is
     * a process that should be continuously running on node DUE06. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BLMLOG = FACILITY_OAFP + (-43*256);

    /**
     * The DECAYS Open Access Client is not connected to its server. DECAYS is
     * a process that should be continuously running on node DUE32. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DECAYS = FACILITY_OAFP + (-44*256);

    /**
     * The SRSAVE Open Access Client is not connected to its server. SRSAVE is
     * a process that should be continuously running on node DCE32. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SRSAVE = FACILITY_OAFP + (-45*256);

    /**
     * The BIGSAV Open Access Client is not connected to its server. BIGSAV is
     * a process that should be continuously running on node DCE28. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BIGSAV = FACILITY_OAFP + (-46*256);

    /**
     * The ERRORZ Open Access Client is not connected to its server. ERRORZ is
     * a process that should be continuously running on node DCE35. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ERRORZ = FACILITY_OAFP + (-47*256);

    /**
     * The FRCONS Open Access Client is not connected to its server. FRCONS is
     * a process that should be continuously running on node DCE37. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_FRCONS = FACILITY_OAFP + (-48*256);

    /**
     * The ERRORS Open Access Client is not connected to its server. ERRORS is
     * a process that should be continuously running on node CTL159. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ERRORS = FACILITY_OAFP + (-49*256);

    /**
     * The NMLOPC Open Access Client is not connected to its server. NMLOPC is
     * a process that should be continuously running on node DPE09. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_NMLOPC = FACILITY_OAFP + (-50*256);

    /**
     * The EVENTN Open Access Client is not connected to its server. EVENTN is
     * a process that should be continuously running on node DUE40. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_EVENTN = FACILITY_OAFP + (-51*256);

    /**
     * The TRREC Open Access Client is not connected to its server. TRREC is a
     * process that should be continuously running on node DPE03. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TRREC = FACILITY_OAFP + (-52*256);

    /**
     * The SCHSAV Open Access Client is not connected to its server. SCHSAV is
     * a process that should be continuously running on node DCE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SCHSAV = FACILITY_OAFP + (-53*256);

    /**
     * The DLLRF Open Access Client is not connected to its server. DLLRF is a
     * process that should be continuously running on node BALROG. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DLLRF = FACILITY_OAFP + (-54*256);

    /**
     * The CDFMON Open Access Client is not connected to its server. CDFMON is
     * a process that should be continuously running on node DUE13. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_CDFMON = FACILITY_OAFP + (-55*256);

    /**
     * The DIGTUN Open Access Client is not connected to its server. DIGTUN is
     * a process that should be continuously running on node DCE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DIGTUN = FACILITY_OAFP + (-56*256);

    /**
     * The MACALC Open Access Client is not connected to its server. MACALC is
     * a process that should be continuously running on node DCE10. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MACALC = FACILITY_OAFP + (-57*256);

    /**
     * The TIMEAV Open Access Client is not connected to its server. TIMEAV is
     * a process that should be continuously running on node DCE10. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TIMEAV = FACILITY_OAFP + (-58*256);

    /**
     * The TEVMTN Open Access Client is not connected to its server. TEVMTN is
     * a process that should be continuously running on node DCE27. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVMTN = FACILITY_OAFP + (-59*256);

    /**
     * The CONSAR Open Access Client is not connected to its server. CONSAR is
     * a process that should be continuously running on node DCE13. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CONSAR = FACILITY_OAFP + (-60*256);

    /**
     * The AUTUNE Open Access Client is not connected to its server. AUTUNE is
     * a process that should be continuously running on node DUE43. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_AUTUNE = FACILITY_OAFP + (-61*256);

    /**
     * The VACAVE Open Access Client is not connected to its server. VACAVE is
     * a process that should be continuously running on node DCE13. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_VACAVE = FACILITY_OAFP + (-62*256);

    /**
     * The NETMON Open Access Client is not connected to its server. NETMON is
     * a process that should be continuously running on node DPE09. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_NETMON = FACILITY_OAFP + (-63*256);

    /**
     * The HALORT Open Access Client is not connected to its server. HALORT is
     * a process that should be continuously running on node DCE37. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_HALORT = FACILITY_OAFP + (-64*256);

    /**
     * The BATCH Open Access Client is not connected to its server. BATCH is a
     * process that should be continuously running on node DUE20. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BATCH = FACILITY_OAFP + (-65*256);

    /**
     * The VLOGGR Open Access Client is not connected to its server. VLOGGR is
     * a process that should be continuously running on node DUE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_VLOGGR = FACILITY_OAFP + (-66*256);

    /**
     * The ECBCAL Open Access Client is not connected to its server. ECBCAL is
     * a process that should be continuously running on node DUE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ECBCAL = FACILITY_OAFP + (-67*256);

    /**
     * The FSMDEV Open Access Client is not connected to its server. FSMDEV is
     * a process that should be continuously running on node DCE09. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_FSMDEV = FACILITY_OAFP + (-68*256);

    /**
     * The ALARMZ Open Access Client is not connected to its server. ALARMZ is
     * a process that should be continuously running on node DCE32. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ALARMZ = FACILITY_OAFP + (-69*256);

    /**
     * The COLDCO Open Access Client is not connected to its server. COLDCO is
     * a process that should be continuously running on node DCE39. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_COLDCO = FACILITY_OAFP + (-70*256);

    /**
     * The JABDEV Open Access Client is not connected to its server. JABDEV is
     * a process that should be continuously running on node ADEE10. Contact
     * the keeper of the OAC, EE Support, or the Central Services Group.
     */
    public final static int OAFP_JABDEV = FACILITY_OAFP + (-71*256);

    /**
     * The ACCBPM Open Access Client is not connected to its server. ACCBPM is
     * a process that should be continuously running on node CTL058. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ACCBPM = FACILITY_OAFP + (-72*256);

    /**
     * The RRSHOT Open Access Client is not connected to its server. RRSHOT is
     * a process that should be continuously running on node DUE33. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_RRSHOT = FACILITY_OAFP + (-73*256);

    /**
     * The CONSAD Open Access Client is not connected to its server. CONSAD is
     * a process that should be continuously running on node DCE37. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CONSAD = FACILITY_OAFP + (-74*256);

    /**
     * The TEMSBD Open Access Client is not connected to its server. TEMSBD is
     * a process that should be continuously running on node PYTHON. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TEMSBD = FACILITY_OAFP + (-75*256);

    /**
     * The ESTATS Open Access Client is not connected to its server. ESTATS is
     * a process that should be continuously running on node DUE47. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_ESTATS = FACILITY_OAFP + (-76*256);

    /**
     * The TEVTUN Open Access Client is not connected to its server. TEVTUN is
     * a process that should be continuously running on node DUE27. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TEVTUN = FACILITY_OAFP + (-77*256);

    /**
     * The CCPEFF Open Access Client is not connected to its server. CCPEFF is
     * a process that should be continuously running on node DCE39. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CCPEFF = FACILITY_OAFP + (-78*256);

    /**
     * The TEMITF Open Access Client is not connected to its server. TEMITF is
     * a process that should be continuously running on node DCE37. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TEMITF = FACILITY_OAFP + (-79*256);

    /**
     * The BACKUP Open Access Client is not connected to its server. BACKUP is
     * a process that should be continuously running on node DCE08. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BACKUP = FACILITY_OAFP + (-80*256);

    /**
     * The BOOMON Open Access Client is not connected to its server. BOOMON is
     * a process that should be continuously running on node DUE46. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BOOMON = FACILITY_OAFP + (-81*256);

    /**
     * The TESTZY Open Access Client is not connected to its server. TESTZY is
     * a process that should be continuously running on node CTL040. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TESTZY = FACILITY_OAFP + (-82*256);

    /**
     * The CHECKS Open Access Client is not connected to its server. CHECKS is
     * a process that should be continuously running on node DCE35. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CHECKS = FACILITY_OAFP + (-83*256);

    /**
     * The TEVSKY Open Access Client is not connected to its server. TEVSKY is
     * a process that should be continuously running on node DCE26. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVSKY = FACILITY_OAFP + (-84*256);

    /**
     * The CRTEMP Open Access Client is not connected to its server. CRTEMP is
     * a process that should be continuously running on node DCE33. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_CRTEMP = FACILITY_OAFP + (-85*256);

    /**
     * The VLOGV Open Access Client is not connected to its server. VLOGV is a
     * process that should be continuously running on node DUE27. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_VLOGV = FACILITY_OAFP + (-86*256);

    /**
     * The SETS Open Access Client is not connected to its server. SETS is a
     * process that should be continuously running on node DUE45. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SETS = FACILITY_OAFP + (-87*256);

    /**
     * The BOOCOL Open Access Client is not connected to its server. BOOCOL is
     * a process that should be continuously running on node DCE29. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BOOCOL = FACILITY_OAFP + (-88*256);

    /**
     * The WEATHR Open Access Client is not connected to its server. WEATHR is
     * a process that should be continuously running on node DCE33. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_WEATHR = FACILITY_OAFP + (-89*256);

    /**
     * The DEBBPM Open Access Client is not connected to its server. DEBBPM is
     * a process that should be continuously running on node DUE30. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DEBBPM = FACILITY_OAFP + (-90*256);

    /**
     * The FLOWSM Open Access Client is not connected to its server. FLOWSM is
     * a process that should be continuously running on node DCE39. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_FLOWSM = FACILITY_OAFP + (-91*256);

    /**
     * The SHOTKY Open Access Client is not connected to its server. SHOTKY is
     * a process that should be continuously running on node DPE07. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SHOTKY = FACILITY_OAFP + (-92*256);

    /**
     * The LEVELS Open Access Client is not connected to its server. LEVELS is
     * a process that should be continuously running on node DUE04. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_LEVELS = FACILITY_OAFP + (-93*256);

    /**
     * The SYNTHE Open Access Client is not connected to its server. SYNTHE is
     * a process that should be continuously running on node DCE33. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SYNTHE = FACILITY_OAFP + (-94*256);

    /**
     * The DAMPE1 Open Access Client is not connected to its server. DAMPE1 is
     * a process that should be continuously running on node BALROG. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DAMPE1 = FACILITY_OAFP + (-95*256);

    /**
     * The DAMPE2 Open Access Client is not connected to its server. DAMPE2 is
     * a process that should be continuously running on node DCE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DAMPE2 = FACILITY_OAFP + (-96*256);

    /**
     * The DAMPE3 Open Access Client is not connected to its server. DAMPE3 is
     * a process that should be continuously running on node DCE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DAMPE3 = FACILITY_OAFP + (-97*256);

    /**
     * The DAMPE4 Open Access Client is not connected to its server. DAMPE4 is
     * a process that should be continuously running on node DCE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DAMPE4 = FACILITY_OAFP + (-98*256);

    /**
     * The DAMPE5 Open Access Client is not connected to its server. DAMPE5 is
     * a process that should be continuously running on node DCE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_DAMPE5 = FACILITY_OAFP + (-99*256);

    /**
     * The TEVCRG Open Access Client is not connected to its server. TEVCRG is
     * a process that should be continuously running on node DCE26. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVCRG = FACILITY_OAFP + (-100*256);

    /**
     * The PIDLUP Open Access Client is not connected to its server. PIDLUP is
     * a process that should be continuously running on node PYTHON. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_PIDLUP = FACILITY_OAFP + (-101*256);

    /**
     * The MUCOOL Open Access Client is not connected to its server. MUCOOL is
     * a process that should be continuously running on node MUCMTA. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MUCOOL = FACILITY_OAFP + (-102*256);

    /**
     * The SERBAL Open Access Client is not connected to its server. SERBAL is
     * a process that should be continuously running on node DUE26. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SERBAL = FACILITY_OAFP + (-103*256);

    /**
     * The TEVICS Open Access Client is not connected to its server. TEVICS is
     * a process that should be continuously running on node DCE04. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TEVICS = FACILITY_OAFP + (-104*256);

    /**
     * The MIBBIM Open Access Client is not connected to its server. MIBBIM is
     * a process that should be continuously running on node DCE36. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MIBBIM = FACILITY_OAFP + (-105*256);

    /**
     * The TOR910 Open Access Client is not connected to its server. TOR910 is
     * a process that should be continuously running on node DCE11. Contact the
     * keeper of the OAC, the Pbar Department, or the Central Services Group.
     */
    public final static int OAFP_TOR910 = FACILITY_OAFP + (-106*256);

    /**
     * The DEBIKI Open Access Client is not connected to its server. DEBIKI is
     * a process that should be continuously running on node DCE33. Contact the
     * Central Services Group.
     */
    public final static int OAFP_DEBIKI = FACILITY_OAFP + (-107*256);

    /**
     * The DEBEKI Open Access Client is not connected to its server. DEBEKI is
     * a process that should be continuously running on node DCE33. Contact the
     * Central Services Group.
     */
    public final static int OAFP_DEBEKI = FACILITY_OAFP + (-108*256);

    /**
     * The ACCIKI Open Access Client is not connected to its server. ACCIKI is
     * a process that should be continuously running on node DCE33. Contact the
     * Central Services Group.
     */
    public final static int OAFP_ACCIKI = FACILITY_OAFP + (-109*256);

    /**
     * The SHOTPR Open Access Client is not connected to its server. SHOTPR is
     * a process that should be continuously running on node DCE04. Contact the
     * keeper of the OAC, the Central Services Group, or the Pbar Department.
     */
    public final static int OAFP_SHOTPR = FACILITY_OAFP + (-110*256);

    /**
     * The SHOTPB Open Access Client is not connected to its server. PBARSA is
     * a process that should be continuously running on node DCE04. Contact the
     * keeper of the OAC, the Central Services Group, or the Pbar Department.
     */
    public final static int OAFP_SHOTPB = FACILITY_OAFP + (-111*256);

    /**
     * The PBARSA Open Access Client is not connected to its server. PBARSA is
     * a process that should be continuously running on node DCE12. Contact the
     * keeper of the OAC, the Pbar Department, or the Central Services Group.
     */
    public final static int OAFP_PBARSA = FACILITY_OAFP + (-112*256);

    /**
     * The TEVHLX Open Access Client is not connected to its server. TEVHLX is
     * a process that should be continuously running on node DCE26. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVHLX = FACILITY_OAFP + (-113*256);

    /**
     * The RCYSCH Open Access Client is not connected to its server. RCYSCH is
     * a process that should be continuously running on node AD1007. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_RCYSCH = FACILITY_OAFP + (-114*256);

    /**
     * The BCCOAC Open Access Client is not connected to its server. BCCOAC is
     * a process that should be continuously running on node PYTHON. Contact
     * the keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_BCCOAC = FACILITY_OAFP + (-115*256);

    /**
     * The EMINOS Open Access Client is not connected to its server. EMINOS is
     * a process that should be continuously running on node DCE01. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_EMINOS = FACILITY_OAFP + (-116*256);

    /**
     * The MAGLEV Open Access Client is not connected to its server. MAGLEV is
     * a process that should be continuously running on node DCE37. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_MAGLEV = FACILITY_OAFP + (-117*256);

    /**
     * The INITEV Open Access Client is not connected to its server. INITEV is
     * a process that should be continuously running on node DCE03. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_INITEV = FACILITY_OAFP + (-118*256);

    /**
     * The SBDCAL Open Access Client is not connected to its server. SBDCAL is
     * a process that should be continuously running on node DUE23. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SBDCAL = FACILITY_OAFP + (-119*256);

    /**
     * The TLONBP Open Access Client is not connected to its server. TLONBP is
     * a process that should be continuously running on node DCE10. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_TLONBP = FACILITY_OAFP + (-120*256);

    /**
     * The TEVTTT Open Access Client is not connected to its server. TEVTTT is
     * a process that should be continuously running on node DCE26. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVTTT = FACILITY_OAFP + (-121*256);

    /**
     * The FLXCAP Open Access Client is not connected to its server. FLXCAP is
     * a process that should be continuously running on node DCE11. Contact the
     * keeper of the OAC, the Pbar Department, or the Central Services Group.
     */
    public final static int OAFP_FLXCAP = FACILITY_OAFP + (-122*256);

    /**
     * The TEVATF Open Access Client is not connected to its server. TEVATF is
     * a process that should be continuously running on node DCE26. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVATF = FACILITY_OAFP + (-123*256);

    /**
     * The AP2BPM Open Access Client is not connected to its server. AP2BPM is
     * a process that should be continuously running on node DUE02. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_AP2BPM = FACILITY_OAFP + (-124*256);

    /**
     * The TEVMON Open Access Client is not connected to its server. TEVMON is
     * a process that should be continuously running on node DCE26. Contact the
     * keeper of the OAC, the Tevatron Department, or the Central Services
     * Group.
     */
    public final static int OAFP_TEVMON = FACILITY_OAFP + (-125*256);

    /**
     * The JAERS Open Access Client is not connected to its server. JAERS is a
     * process that should be continuously running on node DUE26. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_JAERS = FACILITY_OAFP + (-126*256);

    /**
     * The SETSDB Open Access Client is not connected to its server. SETSDB is
     * a process that should be continuously running on node DCE42. Contact the
     * keeper of the OAC or the Central Services Group.
     */
    public final static int OAFP_SETSDB = FACILITY_OAFP + (-127*256);

    /**
     * OAM facility
     */
    public final static int FACILITY_OAM = 52;
    public final static int OAM_OK = 0;
    public final static int OAM_SUCCESS = 0;

    /**
     * Request is pending.  Your request has been successfully sent to a front
     * end.  No data has come back yet from that request.
     */
    public final static int OAM_PEND = FACILITY_OAM + (1*256);

    /**
     * Memory allocation failure.  Contact the OAF programmer.
     */
    public final static int OAM_MEMFAIL = FACILITY_OAM + (-1*256);

    /**
     * The required setup has not been performed.  Contact the OAF programmer.
     */
    public final static int OAM_NOSETUP = FACILITY_OAM + (-2*256);

    /**
     * An invalid argument has been passed to a function.  Contact the OAF
     * programmer.
     */
    public final static int OAM_INVARG = FACILITY_OAM + (-3*256);

    /**
     * A required file is not open.  Contact the OAF programmer.
     */
    public final static int OAM_NOTOPN = FACILITY_OAM + (-4*256);

    /**
     * Requested feature is not yet supported.  Contact the OAF programmer.
     */
    public final static int OAM_NOTYET = FACILITY_OAM + (-5*256);

    /**
     * Client contributor is not connected to the Open Access Front End.
     */
    public final static int OAM_NOTASK = FACILITY_OAM + (-6*256);

    /**
     * Zero SDPK or request packets were requests.  This is illegal. Contact
     * the OAF programmer.
     */
    public final static int OAM_ZENT = FACILITY_OAM + (-7*256);

    /**
     * Incoming request was too long and truncated.  Contact the OAF programer.
     */
    public final static int OAM_TRUNC = FACILITY_OAM + (-8*256);

    /**
     * Incoming request was too short.  Contact the OAF programmer.
     */
    public final static int OAM_RLOV = FACILITY_OAM + (-9*256);

    /**
     * Reply was too short. Contact the OAF programmer.
     */
    public final static int OAM_RPOV = FACILITY_OAM + (-10*256);

    /**
     * Illegal SSDN.  Contact the OAF programmer.
     */
    public final static int OAM_SSDN = FACILITY_OAM + (-11*256);

    /**
     * The client reply was truncated.  Contact the OAF programmer.
     */
    public final static int OAM_CLTRUNC = FACILITY_OAM + (-12*256);

    /**
     * The client reply's length is bad.  Contact the OAF programmer.
     */
    public final static int OAM_CLLENGTH = FACILITY_OAM + (-13*256);

    /**
     * Requesting multiple replies on sets is not permitted. Contact the OAF
     * programmer.
     */
    public final static int OAM_MULR = FACILITY_OAM + (-14*256);

    /**
     * The client was not responding to requests and has been logged out.
     */
    public final static int OAM_LOGOUT = FACILITY_OAM + (-15*256);

    /**
     * An operational client is running on the wrong ACNET node.
     */
    public final static int OAM_INVNODE = FACILITY_OAM + (-16*256);

    /**
     * OAMC facility
     */
    public final static int FACILITY_OAMC = 53;
    public final static int OAMC_OK = 0;
    public final static int OAMC_SUCCESS = 0;

    /**
     * Pending.
     */
    public final static int OAMC_PEND = FACILITY_OAMC + (1*256);

    /**
     * OAFP2 facility
     */
    public final static int FACILITY_OAFP2 = 54;
    public final static int OAFP2_OK = 0;
    public final static int OAFP2_SUCCESS = 0;

    /**
     * Pending.
     */
    public final static int OAFP2_PEND = FACILITY_OAFP2 + (1*256);

    /**
     * The BUNNY0 OAC is not connected to its server. BUNNY0 is a process that
     * runs on nodes DPE08 or AD107879. This OAC is used for testing, and its
     * occasional failures are expected. You don't need to contact anybody.
     */
    public final static int OAFP2_BUNNY0 = FACILITY_OAFP2 + (-1*256);

    /**
     * The BUNNY1 OAC is not connected to its server. BUNNY1 is a process that
     * should be continuously running on node DSE10. Contact the Central
     * Services Group.
     */
    public final static int OAFP2_BUNNY1 = FACILITY_OAFP2 + (-2*256);

    /**
     * The BUNNY2 OAC is not connected to its server. BUNNY2 is a process that
     * should be continuously running on node DSE09. Contact the Central
     * Services Group.
     */
    public final static int OAFP2_BUNNY2 = FACILITY_OAFP2 + (-3*256);

    /**
     * The BUNNY3 OAC is not connected to its server. BUNNY3 is a process that
     * should be continuously running on node DSE08. Contact the Central
     * Services Group.
     */
    public final static int OAFP2_BUNNY3 = FACILITY_OAFP2 + (-4*256);

    /**
     * The BUNNY4 OAC is not connected to its server. BUNNY4 is a process that
     * should be continuously running on node DSE07. Contact the Central
     * Services Group.
     */
    public final static int OAFP2_BUNNY4 = FACILITY_OAFP2 + (-5*256);

    /**
     * The LINBPM OAC is not connected to its server. LINBPM is a process that
     * should be continuously running on node DCE10.  Contact the Central
     * Services Group.
     */
    public final static int OAFP2_LINBPM = FACILITY_OAFP2 + (-6*256);

    /**
     * SQL facility
     */
    public final static int FACILITY_SQL = 55;
    public final static int SQL_OK = 0;
    public final static int SQL_SUCCESS = 0;

    /**
     * Row(s) returned are smaller than specified rowsize. Usually a
     * programming error. Clib's db_sqlapi uses Sybase's DB-Library (as opposed
     * to CT-Library) which silently truncates VARCHAR/CHAR columns at 255
     * characters.   Therefore, code which is not expecting this truncation
     * will be subject to this error as well.
     */
    public final static int SQL_SMALLROW = FACILITY_SQL + (9*256);

    /**
     * Additional rows are available. Increase the number of rows in the reply
     * buffer.
     */
    public final static int SQL_MOREROWS = FACILITY_SQL + (5*256);

    /**
     * SQL operation pending. (asynchronous operation)
     */
    public final static int SQL_PEND = FACILITY_SQL + (1*256);

    /**
     * General SQL error.  Look at returned error text, or check the slot
     * logfile.
     */
    public final static int SQL_GENERIC_ERROR = FACILITY_SQL + (-1*256);

    /**
     * Timeout Error.
     */
    public final static int SQL_TMO = FACILITY_SQL + (-24*256);

    /**
     * Database currently not available, retry later.
     */
    public final static int SQL_NOTAVAIL = FACILITY_SQL + (-71*256);

    /**
     * The row size specified in the request does not match the size of the
     * actual data request. A change in the database is the likely reason.
     * Update program.
     */
    public final static int SQL_ROWSIZE = FACILITY_SQL + (-72*256);

    /**
     * The given application is not allowed access to the given
     * table/procedure, advise the table owner that access is desired.
     */
    public final static int SQL_NOPRIV = FACILITY_SQL + (-73*256);

    /**
     * A SQL Syntax error occurred when processing the query.  Look at returned
     * error text, or check the local slot logfile.
     */
    public final static int SQL_SYNTAX = FACILITY_SQL + (-74*256);

    /**
     * Query contains an ambiguous field name.  Fully specify field names
     * contained in more than one table of a join.
     */
    public final static int SQL_AMBIGUOUS = FACILITY_SQL + (-75*256);

    /**
     * Your query was deadlocked with another process and has been chosen as
     * deadlock victim.  Re-run your command.
     */
    public final static int SQL_DEADLOCK = FACILITY_SQL + (-76*256);

    /**
     * Attempt to insert duplicate row or key into a table has failed.
     */
    public final static int SQL_DUPLICATE = FACILITY_SQL + (-77*256);

    /**
     * Server, database, table, view or procedure name not found or invalid.
     */
    public final static int SQL_BADNAME = FACILITY_SQL + (-78*256);

    /**
     * Database or database modification log is full. Expert intervention is
     * required.
     */
    public final static int SQL_NOSPACE = FACILITY_SQL + (-79*256);

    /**
     * Query is too big or complex.  Try to break down the query into smaller
     * parts.
     */
    public final static int SQL_TOOBIG = FACILITY_SQL + (-80*256);

    /**
     * Bulk copy is not enabled for some reason.  Fast bulk copy is not enabled
     * for the requested database.  Slow bulk copy can be used instead by
     * creating an index on your table.
     */
    public final static int SQL_NO_BULK_COPY = FACILITY_SQL + (-81*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER0 = FACILITY_SQL + (-112*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER1 = FACILITY_SQL + (-113*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER2 = FACILITY_SQL + (-114*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER3 = FACILITY_SQL + (-115*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER4 = FACILITY_SQL + (-116*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER5 = FACILITY_SQL + (-117*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER6 = FACILITY_SQL + (-118*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER7 = FACILITY_SQL + (-119*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER8 = FACILITY_SQL + (-120*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USER9 = FACILITY_SQL + (-121*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USERA = FACILITY_SQL + (-122*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USERB = FACILITY_SQL + (-123*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USERC = FACILITY_SQL + (-124*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USERD = FACILITY_SQL + (-125*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USERE = FACILITY_SQL + (-126*256);

    /**
     * This error is reserved for use by individual applications.  See app's
     * keeper.
     */
    public final static int SQL_USERF = FACILITY_SQL + (-127*256);

    /**
     * MECAR facility
     */
    public final static int FACILITY_MECAR = 56;
    public final static int MECAR_OK = 0;
    public final static int MECAR_SUCCESS = 0;

    /**
     * Unsupported class number: An attempt was made to create an instance for
     * a nonexistent class.  Check if the class has been properly created.
     * (Inner Front End error)
     */
    public final static int MECAR_NO_SUCH_CLASS = FACILITY_MECAR + (-1*256);

    /**
     * Unsupported OID: An attempt was made to create an instance with the OID
     * out of range (0 - 499).  (Inner Front End error)
     */
    public final static int MECAR_INVALID_OID = FACILITY_MECAR + (-2*256);

    /**
     * Unsupported message type: An attempt was made to define a message of
     * type not defined in the message type header file.  (Inner Front End
     * error)
     */
    public final static int MECAR_INV_MSG_TYPE = FACILITY_MECAR + (-3*256);

    /**
     * IVs too long: There is a limitation on the length of the inner variables
     * structure (IVs).  (Inner Front End error)
     */
    public final static int MECAR_IVS_TOO_LONG = FACILITY_MECAR + (-4*256);

    /**
     * Too many superclasses: There is a limitation on the number of
     * superclasses for a particular class.  (Inner Front End error)
     */
    public final static int MECAR_TOO_MANY_SUPRCLASSES = FACILITY_MECAR + (-5*256);

    /**
     * Duplicated class definition: A class with the same number has already
     * been defined.  (Inner Front End error)
     */
    public final static int MECAR_DUPLICATE_CLASS = FACILITY_MECAR + (-6*256);

    /**
     * Duplicated OID definition: This object identifier (OID) has already been
     * defined.  (Inner Front End error)
     */
    public final static int MECAR_DUPLICATE_OID = FACILITY_MECAR + (-7*256);

    /**
     * Superclass for this class is not defined: It is necessary to define
     * superclasses before we define subclasses.  (Inner Front End error)
     */
    public final static int MECAR_NO_SUCH_SUPRCLASS = FACILITY_MECAR + (-8*256);

    /**
     * Class for this OID is not defined: The definition of the class should
     * appear before the definition of the instance of this class.  (Inner
     * Front End error)
     */
    public final static int MECAR_NO_SUCH_OID_CLASS = FACILITY_MECAR + (-9*256);

    /**
     * This OID is not defined: An attempt was made to fulfill the method for
     * an undefined OID.  Most likely the database entry is in error.  Another
     * option is that something is wrong with the 386 software.  Notify front
     * end programmer.
     */
    public final static int MECAR_NO_SUCH_OID = FACILITY_MECAR + (-10*256);

    /**
     * Supermethod for this method is not defined  (Inner Front End error)
     */
    public final static int MECAR_NO_SUCH_SUPERMETHOD = FACILITY_MECAR + (-11*256);

    /**
     * Out of dynamic memory for the class structure  (Inner Front End error)
     */
    public final static int MECAR_CLASS_OUTOMEM = FACILITY_MECAR + (-12*256);

    /**
     * Out of dynamic memory for instance structure  (Inner Front End error)
     */
    public final static int MECAR_INSTANCE_OUTOMEM = FACILITY_MECAR + (-13*256);

    /**
     * Empty name  (Inner Front End error)
     */
    public final static int MECAR_EMPTY_NAME = FACILITY_MECAR + (-14*256);

    /**
     * Structure is not large enough for this number of messages  (Inner Front
     * End error)
     */
    public final static int MECAR_STRUCT_TOO_SMALL = FACILITY_MECAR + (-15*256);

    /**
     * Message type is not supported by this OID: An attempt was made to
     * fulfill the method for an undefined OID.  Most probably the database
     * entry is in error.  Another option is that something is  wrong with the
     * 386 software.  Notify the front end programmer.
     */
    public final static int MECAR_INV_OID_MSG_TYPE = FACILITY_MECAR + (-16*256);

    /**
     * Given IVs length is not enough  (Inner Front End error)
     */
    public final static int MECAR_IVS_TOO_SHORT = FACILITY_MECAR + (-17*256);

    /**
     * ACNET error: ACNET communications problem.
     */
    public final static int MECAR_ACNET_COMM_ERROR = FACILITY_MECAR + (-18*256);

    /**
     * Inner memory problems  (Inner Front End error)
     */
    public final static int MECAR_INTERNAL_MEMFAIL = FACILITY_MECAR + (-19*256);

    /**
     * Bad list request parameters
     */
    public final static int MECAR_INV_LIST_REQUEST = FACILITY_MECAR + (-20*256);

    /**
     * Error defining trigger  (Inner Front End error)
     */
    public final static int MECAR_TRIGGER_DEF_ERROR = FACILITY_MECAR + (-21*256);

    /**
     * Invalid FTD
     */
    public final static int MECAR_BAD_FTD = FACILITY_MECAR + (-22*256);

    /**
     * Invalid setting parameters
     */
    public final static int MECAR_BAD_SET_PARAMS = FACILITY_MECAR + (-23*256);

    /**
     * Invalid LAN (SSDN)
     */
    public final static int MECAR_BAD_LAN = FACILITY_MECAR + (-24*256);

    /**
     * Invalid node (SSDN)
     */
    public final static int MECAR_BAD_NODE = FACILITY_MECAR + (-25*256);

    /**
     * Invalid Format
     */
    public final static int MECAR_BAD_FORMAT = FACILITY_MECAR + (-26*256);

    /**
     * Unsupported property
     */
    public final static int MECAR_BAD_PROPERTY = FACILITY_MECAR + (-27*256);

    /**
     * Invalid offset: This is probably a database entry problem.
     */
    public final static int MECAR_BAD_OFFSET = FACILITY_MECAR + (-28*256);

    /**
     * Invalid length: This is probably a database entry problem.
     */
    public final static int MECAR_BAD_LENGTH = FACILITY_MECAR + (-29*256);

    /**
     * Bad channel: This channel number is not supported by this device.  This
     * is probably a database entry problem.
     */
    public final static int MECAR_BAD_CHANNEL = FACILITY_MECAR + (-30*256);

    /**
     * Invalid offset plus length: This is probably a database entry problem.
     */
    public final static int MECAR_BAD_OFFSET_LENGTH = FACILITY_MECAR + (-31*256);

    /**
     * Invalid device type: This is probably a database entry problem.
     */
    public final static int MECAR_BAD_DEVICE_TYPE = FACILITY_MECAR + (-32*256);

    /**
     * Unsupported basic control word: This is probably a database entry
     * problem.
     */
    public final static int MECAR_BAD_BASIC_CONTROL = FACILITY_MECAR + (-33*256);

    /**
     * Alarm is not defined: An attempt was made to read an alarm block that
     * hasn't been downloaded.
     */
    public final static int MECAR_NO_ALARM = FACILITY_MECAR + (-34*256);

    /**
     * Alarm property is not supported: There is no software support for the
     * alarm property for this type of device.
     */
    public final static int MECAR_CANNOT_ALARM = FACILITY_MECAR + (-35*256);

    /**
     * Class mismatch: This is a front end problem that should never happen.
     * Notify the front end programmer.
     */
    public final static int MECAR_CLASS_MISMATCH = FACILITY_MECAR + (-36*256);

    /**
     * Unsupported property for FTP: This property is not supported by the
     * current FTP support.  See what property you are specifying for plotting.
     * The allowed ones are reading, reading the setting and basic status.
     */
    public final static int MECAR_CANNOT_FTP = FACILITY_MECAR + (-37*256);

    /**
     * Connection failed: MECAR does some of its interprocessor communications
     * using a TCP/IP network across the VME backplane.  One of these TCP
     * client connections has failed.  Retry the operation.
     */
    public final static int MECAR_CONNECT_FAILED = FACILITY_MECAR + (-100*256);

    /**
     * Unknown RPC: MECAR does some of its interprocessor communications using
     * Remote Procedure Calls (RPC's).  An RPC has been attempted but failed.
     * This could be because the RPC's server processor is down or because the
     * TCP connection between the RPC client and the RPC server has failed.
     * Retry the operation.
     */
    public final static int MECAR_RPC_FAILED = FACILITY_MECAR + (-101*256);

    /**
     * Memory allocation failure: An attempt to allocate memory has failed.
     */
    public final static int MECAR_MEMFAIL = FACILITY_MECAR + (-102*256);

    /**
     * Main Injector bus index invalid: The Main Injector bus index which has
     * been supplied is invalid.
     */
    public final static int MECAR_INV_MI_BUS_INDEX = FACILITY_MECAR + (-103*256);

    /**
     * Main Injector event index invalid: The Main Injector event index which
     * has been supplied is invalid.
     */
    public final static int MECAR_INV_MI_EVENT_INDEX = FACILITY_MECAR + (-104*256);

    /**
     * Error in IRSc RPC call: The setting attempt of a Current Break Point
     * Table failed in the IRSc RPC call.
     */
    public final static int MECAR_BRK_PNT_SET_FAIL = FACILITY_MECAR + (-105*256);

    /**
     * Control Permit request invalid: The data in the Control Permit request
     * was not valid.
     */
    public final static int MECAR_INV_CNTRL_PERMIT_REQ = FACILITY_MECAR + (-106*256);

    /**
     * Decimation Type invalid: The requested Data Decimation Type is not
     * supported.
     */
    public final static int MECAR_INV_DECIMATION_TYPE = FACILITY_MECAR + (-107*256);

    /**
     * VPCC parameter error: Voltage Profile Control Command (VPCC) parameters
     * were not valid.
     */
    public final static int MECAR_VPCC_PARAM_ERROR = FACILITY_MECAR + (-108*256);

    /**
     * Voltage Profile Generation Error: An error occurred while generating a
     * Voltage Profile.
     */
    public final static int MECAR_VOLT_PROF_GEN_ERR = FACILITY_MECAR + (-109*256);

    /**
     * Template Tier Table Error: There were not enough Template Tiers loaded
     * to create the Tier Table with the requested Power Supplies.
     */
    public final static int MECAR_TIER_TABLE_ERROR = FACILITY_MECAR + (-110*256);

    /**
     * Power Supply not in circuit and/or bad channel number
     */
    public final static int MECAR_PS_NOT_IN_CIRCUIT = FACILITY_MECAR + (-111*256);

    /**
     * Invalid bit number on plot: A request was made to plot an invalid bit
     * number.  Valid range (0 - 31).
     */
    public final static int MECAR_INV_BIT_NUMBER = FACILITY_MECAR + (-112*256);

    /**
     * Invalid OOC message specific parameter (OMSP)
     */
    public final static int MECAR_INV_OMSP = FACILITY_MECAR + (-113*256);

    /**
     * Internal save/restore error
     */
    public final static int MECAR_SAVE_RESTORE_ERROR = FACILITY_MECAR + (-114*256);

    /**
     * Internal VPCC return error
     */
    public final static int MECAR_INTERNAL_VPCC_ERROR = FACILITY_MECAR + (-115*256);

    /**
     * Invalid CPU index error: The MECAR CPU number supplied was not valid.
     * Valid numbers (0 - 4).
     */
    public final static int MECAR_INV_CPU_NUMBER = FACILITY_MECAR + (-116*256);

    /**
     * MOOC facility
     */
    public final static int FACILITY_MOOC = 57;
    public final static int MOOC_OK = 0;
    public final static int MOOC_SUCCESS = 0;

    /**
     * Conditions mean alarm limits are ignored (no alarms raised)
     */
    public final static int MOOC_ALARM_CONDITION_IGNORE = FACILITY_MOOC + (7*256);

    /**
     * No recent data of this type was found.
     */
    public final static int MOOC_NO_RECENT_DATA = FACILITY_MOOC + (6*256);

    /**
     * The requested operation is presently disabled.
     */
    public final static int MOOC_OPERATION_DISABLED = FACILITY_MOOC + (5*256);

    /**
     * Settings for the requested device are presently disabled.
     */
    public final static int MOOC_DEVICE_SET_DISABLED = FACILITY_MOOC + (4*256);

    /**
     * The requested device is presently disabled.
     */
    public final static int MOOC_DEVICE_DISABLED = FACILITY_MOOC + (3*256);

    /**
     * The device is not connected, but the device could reconnect.
     */
    public final static int MOOC_DEVICE_NOT_CONNECTED = FACILITY_MOOC + (2*256);

    /**
     * The device is not found, but software will continue to search.
     */
    public final static int MOOC_DEVICE_NOT_FOUND = FACILITY_MOOC + (1*256);

    /**
     * An attempt was made to create an instance for a nonexistent class. Check
     * if the class has been properly created. (Inner Front End error) Please,
     * contact the appropriate front end programmer.
     */
    public final static int MOOC_NO_SUCH_CLASS = FACILITY_MOOC + (-1*256);

    /**
     * An attempt was made to create an instance with the OID out of range (0 -
     * 499). (Inner Front End error).  Please, contact the appropriate front
     * end programmer.
     */
    public final static int MOOC_INVALID_OID = FACILITY_MOOC + (-2*256);

    /**
     * An attempt was made to define a message of a type not defined in the
     * message type header file.  (Inner Front End error).  Please, contact the
     * appropriate front end programmer.
     */
    public final static int MOOC_INV_MSG_TYPE = FACILITY_MOOC + (-3*256);

    /**
     * There is a limitation on the length of the inner variables structure
     * (IVs). (Inner Front End error).  Please, contact the appropriate front
     * end programmer.
     */
    public final static int MOOC_IVS_TOO_LONG = FACILITY_MOOC + (-4*256);

    /**
     * There is a limitation on the number of superclasses for a particular
     * class.  (Inner Front End error).  Please, contact the appropriate front
     * end programmer.
     */
    public final static int MOOC_TOO_MANY_SUPRCLASSES = FACILITY_MOOC + (-5*256);

    /**
     * A class with the same number is already defined. (Inner Front End
     * error).  Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_DUPLICATE_CLASS = FACILITY_MOOC + (-6*256);

    /**
     * This object identifier (OID) is already defined. (Inner Front End
     * error).  Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_DUPLICATE_OID = FACILITY_MOOC + (-7*256);

    /**
     * The superclass for this class is not defined.  It is necessary to define
     * superclasses before defining subclasses.  (Inner Front End error).
     * Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_NO_SUCH_SUPRCLASS = FACILITY_MOOC + (-8*256);

    /**
     * The class for this OID is not defined.  The definition of the class
     * should appear before the definition of an instance of this class. (Inner
     * Front End error).  Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_NO_SUCH_OID_CLASS = FACILITY_MOOC + (-9*256);

    /**
     * This OID is not defined.  An attempt was made to fulfill a method for an
     * undefined OID.  Most likely this is a problem with the database entry.
     * Another option is that something is wrong with the initialization
     * routine OOC_INI.C.  Please, contact the appropriate front end
     * programmer.
     */
    public final static int MOOC_NO_SUCH_OID = FACILITY_MOOC + (-10*256);

    /**
     * Supermethod for this method is not defined.  (Inner Front End error).
     * Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_NO_SUCH_SUPERMETHOD = FACILITY_MOOC + (-11*256);

    /**
     * Out of dynamic memory for the class structure.  (Inner Front End error).
     * Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_CLASS_OUTOMEM = FACILITY_MOOC + (-12*256);

    /**
     * Out of dynamic memory for instance structure.  (Inner Front End error).
     * Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_INSTANCE_OUTOMEM = FACILITY_MOOC + (-13*256);

    /**
     * Empty name  (Inner Front End error).  Please, contact the appropriate
     * front end programmer.
     */
    public final static int MOOC_EMPTY_NAME = FACILITY_MOOC + (-14*256);

    /**
     * This structure is not large enough for this number of messages. (Inner
     * Front End error).  Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_STRUCT_TOO_SMALL = FACILITY_MOOC + (-15*256);

    /**
     * This message type is not supported by this OID.  An attempt was made to
     * fulfill a method for an undefined OID. Most probably this is a database
     * entry problem.  Another possibility is that something is wrong with the
     * initialization routine OOC_INI.C.  Please, contact the appropriate front
     * end programmer.
     */
    public final static int MOOC_INV_OID_MSG_TYPE = FACILITY_MOOC + (-16*256);

    /**
     * Given inner variables (IVs) length is not enough.  (Inner Front End
     * error). Please, contact the appropriate front end programmer.
     */
    public final static int MOOC_IVS_TOO_SHORT = FACILITY_MOOC + (-17*256);

    /**
     * ACNET communications problem.
     */
    public final static int MOOC_ACNET_COMM_ERROR = FACILITY_MOOC + (-18*256);

    /**
     * Inner memory problem.  (Inner Front End error).  Please, contact the
     * appropriate front end programmer.
     */
    public final static int MOOC_INTERNAL_MEMFAIL = FACILITY_MOOC + (-19*256);

    /**
     * Bad list request parameters.
     */
    public final static int MOOC_INV_LIST_REQUEST = FACILITY_MOOC + (-20*256);

    /**
     * Error defining trigger.  (Inner Front End error).  Please, contact the
     * appropriate front end programmer.
     */
    public final static int MOOC_TRIGGER_DEF_ERROR = FACILITY_MOOC + (-21*256);

    /**
     * Bad Frequency Time Descriptor (FTD).
     */
    public final static int MOOC_BAD_FTD = FACILITY_MOOC + (-22*256);

    /**
     * Bad setting parameters.
     */
    public final static int MOOC_BAD_SET_PARAMS = FACILITY_MOOC + (-23*256);

    /**
     * Bad LAN (SSDN).
     */
    public final static int MOOC_BAD_LAN = FACILITY_MOOC + (-24*256);

    /**
     * Bad node (SSDN).
     */
    public final static int MOOC_BAD_NODE = FACILITY_MOOC + (-25*256);

    /**
     * The data returned from a device is in the wrong format. This could
     * happen, for instance, in digital input cards that expect BCD formatted
     * data but receive hex data.
     */
    public final static int MOOC_BAD_FORMAT = FACILITY_MOOC + (-26*256);

    /**
     * Unsupported property index.
     */
    public final static int MOOC_BAD_PROPERTY = FACILITY_MOOC + (-27*256);

    /**
     * Wrong offset.  Most likely this is a database entry problem.
     */
    public final static int MOOC_BAD_OFFSET = FACILITY_MOOC + (-28*256);

    /**
     * Wrong length.  Most likely this is a database entry problem.
     */
    public final static int MOOC_BAD_LENGTH = FACILITY_MOOC + (-29*256);

    /**
     * Setting timeout
     */
    public final static int MOOC_SET_TMO = FACILITY_MOOC + (-30*256);

    /**
     * Bad 186 number.  This is most likely a database problem.
     */
    public final static int MOOC_BAD_186_NUMBER = FACILITY_MOOC + (-31*256);

    /**
     * Bad slot.  This is most likely a database problem.
     */
    public final static int MOOC_BAD_SLOT = FACILITY_MOOC + (-32*256);

    /**
     * This channel number is not supported by this device. Most likely this is
     * a database entry problem. In some cases, this error is the result of an
     * unresponsive piece of hardware.
     */
    public final static int MOOC_BAD_CHANNEL = FACILITY_MOOC + (-33*256);

    /**
     * Bad offset plus length.  Most likely this is a database entry problem.
     */
    public final static int MOOC_BAD_OFFSET_LENGTH = FACILITY_MOOC + (-34*256);

    /**
     * Actuator is not updating data.
     */
    public final static int MOOC_BAD_ACTUATOR = FACILITY_MOOC + (-35*256);

    /**
     * A setting was attempted for a device that is in local.
     */
    public final static int MOOC_LOCAL_MODE_SET = FACILITY_MOOC + (-36*256);

    /**
     * Wrong device type.  Most likely this is a database entry problem.
     */
    public final static int MOOC_BAD_DEVICE_TYPE = FACILITY_MOOC + (-37*256);

    /**
     * Unsupported basic control word.  Most likely this is a database entry
     * problem.
     */
    public final static int MOOC_BAD_BASIC_CONTROL = FACILITY_MOOC + (-38*256);

    /**
     * Transducer fault in the actuator card.  Please, contact the appropriate
     * engineer.
     */
    public final static int MOOC_TRANSDUCER_FAULT = FACILITY_MOOC + (-39*256);

    /**
     * Engine fault
     */
    public final static int MOOC_ENGINE_FAULT = FACILITY_MOOC + (-40*256);

    /**
     * An attempt was made to read an alarm block that hasn't been downloaded.
     */
    public final static int MOOC_NO_ALARM = FACILITY_MOOC + (-41*256);

    /**
     * There is no micro software support for the alarm property for this type
     * of device.
     */
    public final static int MOOC_CANNOT_ALARM = FACILITY_MOOC + (-42*256);

    /**
     * Front end problem that should never happen. Please, contact the
     * appropriate front end programmer.
     */
    public final static int MOOC_CLASS_MISMATCH = FACILITY_MOOC + (-43*256);

    /**
     * This property is not supported by the current FTP support. See what
     * property you are specifying for plotting. The allowed ones are reading,
     * reading the setting, and basic status.
     */
    public final static int MOOC_CANNOT_FTP = FACILITY_MOOC + (-44*256);

    /**
     * Missing hardware board in configuration.
     */
    public final static int MOOC_MISSING_BOARD = FACILITY_MOOC + (-45*256);

    /**
     * Cannot produce the requested pulse.
     */
    public final static int MOOC_NO_PULSE = FACILITY_MOOC + (-46*256);

    /**
     * Initial OID (object ID) is not specified.
     */
    public final static int MOOC_NO_INITIAL_OID = FACILITY_MOOC + (-47*256);

    /**
     * Unsupported GPIB address.  Currently supported addresses are 0-15.  Make
     * sure addresses do not confict.
     */
    public final static int MOOC_BAD_GPIB_ADDRESS = FACILITY_MOOC + (-48*256);

    /**
     * GPIB address is not responding.  Timeouts may vary depending on
     * implementation, but the default is 10 seconds per GPIB request.
     */
    public final static int MOOC_GPIB_TMO = FACILITY_MOOC + (-49*256);

    /**
     * Illegal GPIB sequence.  Tried to do a reading or reading of the setting
     * before setting the GPIB cmd.
     */
    public final static int MOOC_ILLEGAL_GPIB_SEQ = FACILITY_MOOC + (-50*256);

    /**
     * GPIB device is currently owned or locked via semaphore by another user.
     */
    public final static int MOOC_GPIB_LOCKED = FACILITY_MOOC + (-51*256);

    /**
     * GPIB specific error. More than likely this is a device which is screwed
     * up.
     */
    public final static int MOOC_GPIB_ERROR = FACILITY_MOOC + (-52*256);

    /**
     * Settings are not allowed for a state which is currently active.
     */
    public final static int MOOC_STATE_ACTIVE = FACILITY_MOOC + (-53*256);

    /**
     * FSM is not defined. Consequently, it can't be started.
     */
    public final static int MOOC_FSM_UNDEFINED = FACILITY_MOOC + (-54*256);

    /**
     * Settings are not allowed for an FSM which is currently active.
     */
    public final static int MOOC_FSM_ACTIVE = FACILITY_MOOC + (-55*256);

    /**
     * State is not defined.  An undefined state cannot be included in the
     * Finite State Machine.
     */
    public final static int MOOC_STATE_UNDEFINED = FACILITY_MOOC + (-56*256);

    /**
     * Incarnation is already locked by either state or another user. The
     * implementation of the circular buffer allows only one user to lock the
     * incarnation for a given buffer.
     */
    public final static int MOOC_INCARNATION_LOCKED = FACILITY_MOOC + (-57*256);

    /**
     * Incarnation number specified by the lock command is out of the defined
     * range of incarnations.
     */
    public final static int MOOC_INV_INCARNATION = FACILITY_MOOC + (-58*256);

    /**
     * Collection number specified for the given incarnation of the event
     * buffer is not within the range of the data collections fulfilled in this
     * incarnation.
     */
    public final static int MOOC_INV_COLLECTION = FACILITY_MOOC + (-59*256);

    /**
     * Circular buffer is out of internal memory for the given data collection.
     */
    public final static int MOOC_BUFFER_OUTOMEM = FACILITY_MOOC + (-60*256);

    /**
     * This event overlapped with the previous one.  Data collection was not
     * done.
     */
    public final static int MOOC_EVENT_OVERLAP = FACILITY_MOOC + (-61*256);

    /**
     * Given ADC is in use by another state.
     */
    public final static int MOOC_ADC_BUSY = FACILITY_MOOC + (-62*256);

    /**
     * Specified event number is not within the range 0 - 255.
     */
    public final static int MOOC_BAD_EVENT_NUMBER = FACILITY_MOOC + (-63*256);

    /**
     * Arcnet communication problem
     */
    public final static int MOOC_ARCNET_ERROR = FACILITY_MOOC + (-64*256);

    /**
     * SWIC sequencer is not initialized
     */
    public final static int MOOC_SEQUENCER_NOT_INIT = FACILITY_MOOC + (-65*256);

    /**
     * Not all events for the measurement sequence are defined.  For every
     * sequence, three events have to be defined: start sequence, make next
     * measurement, and stop sequence.
     */
    public final static int MOOC_EVENT_UNDEFINED = FACILITY_MOOC + (-66*256);

    /**
     * Bad measurement number is specified for the measurement sequence.
     */
    public final static int MOOC_BAD_MEASURE_NUM = FACILITY_MOOC + (-67*256);

    /**
     * Not all measurements for the measurement sequence are defined.
     */
    public final static int MOOC_UNDEFINED_MEASURE = FACILITY_MOOC + (-68*256);

    /**
     * Bad subaddress.  Most likely this is a database problem.  Bad subaddress
     * (calculation type, number) is specified for buffer/circular buffer.
     */
    public final static int MOOC_BAD_SUBADDRESS = FACILITY_MOOC + (-69*256);

    /**
     * The value specified for buffer/circular buffer is not calculated.
     * Consult the measurement definition for this measurement.
     */
    public final static int MOOC_NOT_CALCULATED = FACILITY_MOOC + (-70*256);

    /**
     * Timing problem.  End of sequence event occurred prior to the next
     * measurement event for this measurement.
     */
    public final static int MOOC_END_OF_SEQUENCE = FACILITY_MOOC + (-71*256);

    /**
     * Timing problem.  The next measurement event occurred before data
     * collection was completed for the previous one.
     */
    public final static int MOOC_TIMING = FACILITY_MOOC + (-72*256);

    /**
     * Sequencer does not know anything about this type of measurement.  Most
     * likely this is a bookkeeping problem.
     */
    public final static int MOOC_BAD_MEASURE_TYPE = FACILITY_MOOC + (-73*256);

    /**
     * Sequencer hardware problem. Please, contact the appropriate engineer,
     * currently Al Franck.
     */
    public final static int MOOC_SEQUENCER_INACTIVE = FACILITY_MOOC + (-74*256);

    /**
     * Sequencer hardware problem. Please, conatact the appropriate engineer,
     * currently Al Franck.
     */
    public final static int MOOC_SEQUENCER_ERROR = FACILITY_MOOC + (-75*256);

    /**
     * Sigma/mean calculation does not converge. Try to analyze the data and
     * determine the problem.
     */
    public final static int MOOC_CALC_ERROR = FACILITY_MOOC + (-76*256);

    /**
     * Data is not being updated
     */
    public final static int MOOC_NO_DATA_UPDATE = FACILITY_MOOC + (-77*256);

    /**
     * Memory for this buffer has not been allocated.
     */
    public final static int MOOC_NOT_ALLOCATED = FACILITY_MOOC + (-78*256);

    /**
     * 186 is sick.  We have either lost Arcnet connection with the 186 or it
     * is stuck. Your best bet is to try to reboot the 186.
     */
    public final static int MOOC_186_SICK = FACILITY_MOOC + (-81*256);

    /**
     * Communications with the 186 are down.  The master CPU cannot make sense
     * out of the messages that are sent by the 186.  Most likely something is
     * wrong with the Arcnet LAN.
     */
    public final static int MOOC_186_COMM_FAIL = FACILITY_MOOC + (-82*256);

    /**
     * PLC specific error.  Since PLCs are numerous with many specific errors,
     * all errors are grouped into this one error code.  Usually this implies
     * the PLC is broken, powered down, not communicating to the host front
     * end, or PLC communication to its I/O is disabled.  Examples of PLCs are
     * the following:  CHL TI/Siemens PM550 connected via RS232 9600 baud and
     * TI/Siemens 545 connected via Ethernet; MIPS Allen-Bradley SLC504
     * connected via DH+ proprietary network; MILCW Sixtrak Gateway connected
     * via Ethernet; SCADA ENIM 101 or EGATE via Ethernet.
     */
    public final static int MOOC_PLC_ERROR = FACILITY_MOOC + (-83*256);

    /**
     * PLC is not responding to a query for data
     */
    public final static int MOOC_PLC_TIMEOUT = FACILITY_MOOC + (-84*256);

    /**
     * RS232 read/write error
     */
    public final static int MOOC_RS232 = FACILITY_MOOC + (-85*256);

    /**
     * There are too many ion pumps off to calculate an ion pump average.
     */
    public final static int MOOC_TOO_FEW_ION_PUMPS = FACILITY_MOOC + (-86*256);

    /**
     * Multiwire calculation on plane that was not in beam.
     */
    public final static int MOOC_BADPLANE = FACILITY_MOOC + (-87*256);

    /**
     * An error occured when getting data over the CIA crate dataway from the
     * vacuum card.  Check if the card you are trying to reference is properly
     * installed in the crate.
     */
    public final static int MOOC_DATAWAY_ERROR = FACILITY_MOOC + (-88*256);

    /**
     * Requested action still busy from previous request.
     */
    public final static int MOOC_BUSY = FACILITY_MOOC + (-89*256);

    /**
     * Virtual I/O Bus (VIOB) setting of this device already in progress.
     */
    public final static int MOOC_VIOB_SET_IN_PROG = FACILITY_MOOC + (-90*256);

    /**
     * Bad type value in an analog alarm block.  The type value is in the third
     * byte of the 6-byte long subsystem data area.  It and the Q field of the
     * flags word completely specify the type of the the parameter being
     * scanned.
     */
    public final static int MOOC_ALARM_BAD_TYPE = FACILITY_MOOC + (-91*256);

    /**
     * Bad Q field value in an alarm block.  Either the Q value is invalid
     * (e.g. 3), or is not valid for the given type (e.g. 0 or 1 for a float).
     */
    public final static int MOOC_ALARM_BAD_Q = FACILITY_MOOC + (-92*256);

    /**
     * No type specified in an analog alarm block, and the front end does not
     * know the type either.
     */
    public final static int MOOC_ALARM_NO_TYPE = FACILITY_MOOC + (-93*256);

    /**
     * Attempt was made to define a class with a reserved class number or
     * instantiate an object with a reserved object number/ID.
     */
    public final static int MOOC_RESERVED = FACILITY_MOOC + (-94*256);

    /**
     * This front end does not support version information.
     */
    public final static int MOOC_NOVERSION = FACILITY_MOOC + (-95*256);

    /**
     * An attempt has been made to read a data-pooled device that hasn't yet
     * produced data. Either the sampling event hasn't fired, or the data pool
     * task hasn't been configured to support the device, or the data pool task
     * is ill.
     */
    public final static int MOOC_NO_DATA_IN_POOL = FACILITY_MOOC + (-96*256);

    /**
     * The OMSP misc field value passed to a class method was in error.
     */
    public final static int MOOC_OMSP_BADMISC = FACILITY_MOOC + (-97*256);

    /**
     * The OMSP typ field value passed to a class method was in error.
     */
    public final static int MOOC_OMSP_BADTYP = FACILITY_MOOC + (-98*256);

    /**
     * The OMSP chan field value passed to a class method was in error.
     */
    public final static int MOOC_OMSP_BADCHAN = FACILITY_MOOC + (-99*256);

    /**
     * The OMSP misc2 field value passed to a class method was in error.
     */
    public final static int MOOC_OMSP_BADMISC2 = FACILITY_MOOC + (-100*256);

    /**
     * The requested device does not support reads.
     */
    public final static int MOOC_READ_NOT_SUPPORTED = FACILITY_MOOC + (-101*256);

    /**
     * The requested device does not support fast reads.
     */
    public final static int MOOC_FASTREADNOTSUPPORTED = FACILITY_MOOC + (-102*256);

    /**
     * The requested device does not support settings.
     */
    public final static int MOOC_SET_NOT_SUPPORTED = FACILITY_MOOC + (-103*256);

    /**
     * A null pointer was passed to a class method.
     */
    public final static int MOOC_NULL_POINTER = FACILITY_MOOC + (-104*256);

    /**
     * The class method has no Device Accessor for this request.
     */
    public final static int MOOC_NO_ACCESSOR = FACILITY_MOOC + (-105*256);

    /**
     * The Device Accessor can't fulfill this request (generic error).
     */
    public final static int MOOC_DEVICE_ERROR = FACILITY_MOOC + (-106*256);

    /**
     * This reading has timed out.  It probably is due to an event not
     * occurring.
     */
    public final static int MOOC_READ_TIMEOUT = FACILITY_MOOC + (-107*256);

    /**
     * Settings to this device are presently disabled.  This can be enabled by
     * issuing an enable to the device.
     */
    public final static int MOOC_SETS_DISABLED = FACILITY_MOOC + (-108*256);

    /**
     * Illegal device ID.  This can be caused by an invalid value in the SSDN
     * misc2 field.
     */
    public final static int MOOC_BAD_DEVICE_ID = FACILITY_MOOC + (-109*256);

    /**
     * The specified device ID has not been defined in this front end.  This
     * can be caused by an invalid value in the SSDN misc2 field.
     */
    public final static int MOOC_DEVICE_NOT_DEFINED = FACILITY_MOOC + (-110*256);

    /**
     * The device driver failed.
     */
    public final static int MOOC_DRIVER_FAILED = FACILITY_MOOC + (-111*256);

    /**
     * The PEP (Packet Exchange Protocol) server is down.
     */
    public final static int MOOC_PEP_SERVER_DOWN = FACILITY_MOOC + (-115*256);

    /**
     * MOOC_INT facility
     */
    public final static int FACILITY_MOOC_INT = 58;
    public final static int MOOC_INT_OK = 0;
    public final static int MOOC_INT_SUCCESS = 0;

    /**
     * A method has whacked this setting data for forwarding.
     */
    public final static int MOOC_INT_WHACK_FORWARD = FACILITY_MOOC_INT + (1*256);

    /**
     * TLG facility
     */
    public final static int FACILITY_TLG = 60;
    public final static int TLG_OK = 0;
    public final static int TLG_SUCCESS = 0;

    /**
     * Front end resources are currently being utilized by another user.
     */
    public final static int TLG_BLOCKED = FACILITY_TLG + (-1*256);

    /**
     * Unable to meet timeline constraints.  This error occurs whenever the
     * testing task at the front end is unable to place a module or the module
     * is placed fewer times than requested.
     */
    public final static int TLG_CONSTRAINT_ERROR = FACILITY_TLG + (-2*256);

    /**
     * A serious front end error has occurred.  Errors include using a
     * corrupted module or having the placing task at the front end fail at
     * placing a module or placing a module fewer times than requested.
     */
    public final static int TLG_FATAL_ERROR = FACILITY_TLG + (-3*256);

    /**
     * Front end computation is in progress.  The TLG front end is in the
     * process of computing the placement of the desired events and machine
     * states according to the timeline specifications.
     */
    public final static int TLG_PENDING = FACILITY_TLG + (-4*256);

    /**
     * The module slot is empty or not allocated.
     */
    public final static int TLG_MOD_EMPTY = FACILITY_TLG + (-5*256);

    /**
     * The timeline slot is empty or not allocated.
     */
    public final static int TLG_TLN_EMPTY = FACILITY_TLG + (-6*256);

    /**
     * An invalid request was made to the TLG front end.  An example would be
     * utilizing invalid module and timeline IDs i.e. outside of the valid
     * range (1,255).
     */
    public final static int TLG_INVALID_REQ = FACILITY_TLG + (-7*256);

    /**
     * The TLG front end is out of memory.  A block was requested that was too
     * large for the memory currently available to the TLG front end.
     */
    public final static int TLG_OUT_OF_MEM = FACILITY_TLG + (-8*256);

    /**
     * The TLG front end has booted.  The front end has successfully started up
     * and is awaiting the necessary settings to be downloaded.
     */
    public final static int TLG_BOOTED = FACILITY_TLG + (-9*256);

    /**
     * The TLG front end has booted.  The front end has successfully started up
     * and is receiving the necessary settings from the download server.  After
     * the settings needed for the current timeline are received, the TLG front
     * end will start playing events/states.
     */
    public final static int TLG_STARTING = FACILITY_TLG + (-10*256);

    /**
     * The module is not approved.  Timelines to be played by the front end
     * require that all of the modules that they use be approved.  The approval
     * of modules is done by program D69.
     */
    public final static int TLG_MOD_NOTAPP = FACILITY_TLG + (-11*256);

    /**
     * The timeline is not in service.  Timelines to be played at front end
     * must be in service.  Placing timelines in service is done by program
     * D69.
     */
    public final static int TLG_TLN_OUTSRV = FACILITY_TLG + (-12*256);

    /**
     * The module is approved.  This error occurs if an attempt is made to
     * delete an approved module.  Module approval must first be removed from
     * program D69.
     */
    public final static int TLG_MOD_APPRV = FACILITY_TLG + (-13*256);

    /**
     * The timeline is in service.  This error occurs if an attempt is made to
     * delete an in service Timeline.  The timeline must first be removed from
     * service by using program D69.
     */
    public final static int TLG_TLN_INSRV = FACILITY_TLG + (-14*256);

    /**
     * CNSLIDTR facility
     */
    public final static int FACILITY_CNSLIDTR = 61;
    public final static int CNSLIDTR_OK = 0;
    public final static int CNSLIDTR_SUCCESS = 0;

    /**
     * Internal memory problem: Consolidator machine is out of memory for
     * servicing of this request.  Either machine is overloaded with the
     * requests, or, most probably, consolidator's software bug.
     */
    public final static int CNSLIDTR_MEMFAIL = FACILITY_CNSLIDTR + (-1*256);

    /**
     * Node is down: The node to which you are trying to talk is currently
     * down.
     */
    public final static int CNSLIDTR_NODE_DOWN = FACILITY_CNSLIDTR + (-2*256);

    /**
     * Wrong reply length: The length of the reply of the participating node is
     * less than expected.
     */
    public final static int CNSLIDTR_BAD_REPLY_LEN = FACILITY_CNSLIDTR + (-3*256);

    /**
     * Bad list: Something is wrong in the incoming RETDAT or SETDAT request.
     * Most probably network problem.
     */
    public final static int CNSLIDTR_BAD_LIST = FACILITY_CNSLIDTR + (-4*256);

    /**
     * Invalid FTD: Consolidator can not translate FTD of the incoming request.
     * This is probably a Consolidator's software bug.
     */
    public final static int CNSLIDTR_INVALID_FTD = FACILITY_CNSLIDTR + (-5*256);

    /**
     * Bad device code in SSDN: Most probably data base problem. SSDN for all
     * consolidator devices should contain FF or F0 in the second byte for
     * supporting devices or front end for consolidated devices.
     */
    public final static int CNSLIDTR_INVALID_DEVICE_CODE = FACILITY_CNSLIDTR + (-6*256);

    /**
     * Invalid length: Bad length for the given device.  The length for the
     * given device is calculated according to the formula :
     * length=(length_of_device_per_node + 2)*amount_of_nodes;
     */
    public final static int CNSLIDTR_INVALID_LENGTH = FACILITY_CNSLIDTR + (-7*256);

    /**
     * Unsupported property.  This is probably a database problem.
     */
    public final static int CNSLIDTR_INVALID_PROPERTY = FACILITY_CNSLIDTR + (-8*256);

    /**
     * Invalid consolidation type: For consolidated devices the first byte of
     * SSDN defines the consolidation table (condsolidation type) that should
     * be used for this device.  This is probably a database problem.
     */
    public final static int CNSLIDTR_BAD_CONS_TYPE = FACILITY_CNSLIDTR + (-9*256);

    /**
     * Invalid offset
     */
    public final static int CNSLIDTR_INVALID_OFFSET = FACILITY_CNSLIDTR + (-10*256);

    /**
     * Bad length/offset combination.
     */
    public final static int CNSLIDTR_INVALID_LENGTHOFFSET = FACILITY_CNSLIDTR + (-11*256);

    /**
     * ACNET error: ACNET error in RETDAT/SETDAT request.
     */
    public final static int CNSLIDTR_REQUEST_ERROR = FACILITY_CNSLIDTR + (-12*256);

    /**
     * FIXTAR facility
     */
    public final static int FACILITY_FIXTAR = 62;
    public final static int FIXTAR_OK = 0;
    public final static int FIXTAR_SUCCESS = 0;

    /**
     * Not allowed to call this routine from an AST receiver.
     */
    public final static int FIXTAR_NOTFROMAST = FACILITY_FIXTAR + (-1*256);

    /**
     * Already executed run down.
     */
    public final static int FIXTAR_RANDOWN = FACILITY_FIXTAR + (-2*256);

    /**
     * da_process_request in progress.
     */
    public final static int FIXTAR_PROCINPROG = FACILITY_FIXTAR + (-3*256);

    /**
     * db_access_request in progress.
     */
    public final static int FIXTAR_DBACCPROG = FACILITY_FIXTAR + (-4*256);

    /**
     * ds_execute_list in progress.
     */
    public final static int FIXTAR_EXECPEND = FACILITY_FIXTAR + (-5*256);

    /**
     * Must supply handle..
     */
    public final static int FIXTAR_SUPHDL = FACILITY_FIXTAR + (-6*256);

    /**
     * Database access suppressed.
     */
    public final static int FIXTAR_DBSUPPRESS = FACILITY_FIXTAR + (-7*256);

    /**
     * Invalid FTD.
     */
    public final static int FIXTAR_INVFTD = FACILITY_FIXTAR + (-8*256);

    /**
     * Invalid completion FTD.
     */
    public final static int FIXTAR_INVCOMPLETIONFTD = FACILITY_FIXTAR + (-9*256);

    /**
     * No previous request given.
     */
    public final static int FIXTAR_NOPREV = FACILITY_FIXTAR + (-10*256);

    /**
     * Database access has not yet completed.
     */
    public final static int FIXTAR_DBACCPEND = FACILITY_FIXTAR + (-11*256);

    /**
     * Invalid list identifier.
     */
    public final static int FIXTAR_INVLISTID = FACILITY_FIXTAR + (-12*256);

    /**
     * Exceeded handle allocation limit.
     */
    public final static int FIXTAR_NOHDLALLOC = FACILITY_FIXTAR + (-13*256);

    /**
     * No such property or attribute.
     */
    public final static int FIXTAR_NOPRPATR = FACILITY_FIXTAR + (-14*256);

    /**
     * Invalid or not enough arguments.
     */
    public final static int FIXTAR_INVARG = FACILITY_FIXTAR + (-15*256);

    /**
     * Memory unavailable in DAR's global section.
     */
    public final static int FIXTAR_GBLSECTALL = FACILITY_FIXTAR + (-16*256);

    /**
     * Invalid handle.
     */
    public final static int FIXTAR_INVHDL = FACILITY_FIXTAR + (-17*256);

    /**
     * Invalid data length.
     */
    public final static int FIXTAR_INVLENGTH = FACILITY_FIXTAR + (-18*256);

    /**
     * Can't cancel RESERVED list.
     */
    public final static int FIXTAR_RESLISTID = FACILITY_FIXTAR + (-19*256);

    /**
     * Initialization routine not called.
     */
    public final static int FIXTAR_NOINIT = FACILITY_FIXTAR + (-20*256);

    /**
     * Device not Test CAMAC type.
     */
    public final static int FIXTAR_DEVNOTSTCM = FACILITY_FIXTAR + (-21*256);

    /**
     * Bad constant list count for PD synthesizer.
     */
    public final static int FIXTAR_BADCONCNT = FACILITY_FIXTAR + (-22*256);

    /**
     * Bad input component device count for PD synthesizer.
     */
    public final static int FIXTAR_BADDICNT = FACILITY_FIXTAR + (-23*256);

    /**
     * Bad PD synthesizer function code number.
     */
    public final static int FIXTAR_BADFCNNO = FACILITY_FIXTAR + (-24*256);

    /**
     * Too many input devices for PD synthesizer.
     */
    public final static int FIXTAR_TOOMNYDI = FACILITY_FIXTAR + (-25*256);

    /**
     * Invalid synthetic device.
     */
    public final static int FIXTAR_INVSYNDEV = FACILITY_FIXTAR + (-26*256);

    /**
     * Invalid data offset.
     */
    public final static int FIXTAR_INVOFFSET = FACILITY_FIXTAR + (-27*256);

    /**
     * Insufficient dynamic memory - allocation failed.
     */
    public final static int FIXTAR_INSDYNMEM = FACILITY_FIXTAR + (-28*256);

    /**
     * Invalid global section memory address specified.
     */
    public final static int FIXTAR_INVGMADDR = FACILITY_FIXTAR + (-29*256);

    /**
     * Free queue count not in MIN_FREE_QUEUE to MAX_FREE_QUEUE
     */
    public final static int FIXTAR_INVFQCNT = FACILITY_FIXTAR + (-30*256);

    /**
     * Invalid free queue parameter.
     */
    public final static int FIXTAR_INVFQPARAM = FACILITY_FIXTAR + (-31*256);

    /**
     * Must give number of free queues first.
     */
    public final static int FIXTAR_INVFQINIT = FACILITY_FIXTAR + (-32*256);

    /**
     * Can't open DAR initialization file.
     */
    public final static int FIXTAR_NOFILE = FACILITY_FIXTAR + (-33*256);

    /**
     * DAR and UTI versions incompatible - Recompile/relink program.
     */
    public final static int FIXTAR_DARINCMPTBL = FACILITY_FIXTAR + (-34*256);

    /**
     * DAR server not active.
     */
    public final static int FIXTAR_NODARSERVER = FACILITY_FIXTAR + (-35*256);

    /**
     * Failed acknowledgement from camac card.
     */
    public final static int FIXTAR_NO_X = FACILITY_FIXTAR + (-36*256);

    /**
     * Link timeout.
     */
    public final static int FIXTAR_TIMEOUT = FACILITY_FIXTAR + (-37*256);

    /**
     * Failed camac response to function code.
     */
    public final static int FIXTAR_NO_Q = FACILITY_FIXTAR + (-38*256);

    /**
     * The length and offset combination requested is invalid.
     */
    public final static int FIXTAR_REQSIZ = FACILITY_FIXTAR + (-39*256);

    /**
     * Some or all adds returned bad status.
     */
    public final static int FIXTAR_BADADDS = FACILITY_FIXTAR + (-40*256);

    /**
     * No such device.
     */
    public final static int FIXTAR_NODEVICE = FACILITY_FIXTAR + (-41*256);

    /**
     * Parity error.
     */
    public final static int FIXTAR_PARITY = FACILITY_FIXTAR + (-42*256);

    /**
     * ARCnet Module Stale Data.
     */
    public final static int FIXTAR_STLDATA = FACILITY_FIXTAR + (-43*256);

    /**
     * No privileges granted to access this device and property.
     */
    public final static int FIXTAR_NOPRIVILEGE = FACILITY_FIXTAR + (-44*256);

    /**
     * ARCnet datapool is locked.
     */
    public final static int FIXTAR_DPLOCKD = FACILITY_FIXTAR + (-45*256);

    /**
     * Property not implemented.
     */
    public final static int FIXTAR_PRPUNIMP = FACILITY_FIXTAR + (-46*256);

    /**
     * Camac serial link driver hung up.
     */
    public final static int FIXTAR_VSLDTMO = FACILITY_FIXTAR + (-47*256);

    /**
     * Datapool nil entry.
     */
    public final static int FIXTAR_NILENTRY = FACILITY_FIXTAR + (-48*256);

    /**
     * DOWNLD facility
     */
    public final static int FACILITY_DOWNLD = 63;
    public final static int DOWNLD_OK = 0;
    public final static int DOWNLD_SUCCESS = 0;

    /**
     * Illegal facility typecode in message header.  The typecode found in the
     * incoming message is not supported.
     */
    public final static int DOWNLD_ILLEGAL_FACTC = FACILITY_DOWNLD + (-1*256);

    /**
     * Invalid packet sequence. While processing data packets within a
     * datagram, the first one should be delete, SSDR, or name. Anything else
     * is invalid.
     */
    public final static int DOWNLD_INV_PKT_SEQ = FACILITY_DOWNLD + (-2*256);

    /**
     * Invalid packet type. While processing additional data packets within a
     * datagram beyond the first one, only DELETE, NAME, TEXT, and PDB packets
     * are expected.
     */
    public final static int DOWNLD_INV_PKT_TYP = FACILITY_DOWNLD + (-3*256);

    /**
     * Invalid SSDR format. When processing the SSDR packet, the first word
     * must be the length in 16-bit words, the second word must be $444C
     * ('DL'), and the third word must be $000A, the length of the field that
     * includes the SSDN-type information that must follow.
     */
    public final static int DOWNLD_INV_SSDR = FACILITY_DOWNLD + (-4*256);

    /**
     * Invalid c2 constant in PDB. A PDB used a second constant = 0.0. The
     * linear engineering units conversion formula divides by this constant.
     */
    public final static int DOWNLD_INV_C2_VAL = FACILITY_DOWNLD + (-5*256);

    /**
     * Invalid common transform index. Currently, only transform index 2 is
     * supported.
     */
    public final static int DOWNLD_INV_COM_INX = FACILITY_DOWNLD + (-6*256);

    /**
     * Invalid primary transform index. Currently, only transform index 2 is
     * supported.
     */
    public final static int DOWNLD_INV_PRI_INX = FACILITY_DOWNLD + (-7*256);

    /**
     * Invalid property index for PDB. Property indices handled by DOWNLD are
     * NAME, TEXT, PDB, and SSDR.
     */
    public final static int DOWNLD_INV_PROP_INX = FACILITY_DOWNLD + (-8*256);

    /**
     * Invalid property length. Property NAME is 8 characters. Property TEXT is
     * 24 characters.
     */
    public final static int DOWNLD_INV_PROP_LNG = FACILITY_DOWNLD + (-9*256);

    /**
     * Invalid field type. Within the SSDR, current fields supported are (1)
     * analog control field, (2) associated status/control fields, (3)
     * conversion type field, and (4) family field.
     */
    public final static int DOWNLD_INV_FLD_TYP = FACILITY_DOWNLD + (-10*256);

    /**
     * Invalid field length. A valid field in the SSDR did not have the correct
     * length.
     */
    public final static int DOWNLD_INV_FLD_LNG = FACILITY_DOWNLD + (-11*256);

    /**
     * No memory to allocate forwarded message. No memory available to allocate
     * structure for support of server-forwarded DOWNLD message.
     */
    public final static int DOWNLD_SERV_NO_MEMORY = FACILITY_DOWNLD + (-12*256);

    /**
     * No room available in server forwarding table. Server node has room for 8
     * active entries. One is normally expected to be enough.
     */
    public final static int DOWNLD_SERV_TBL_FULL = FACILITY_DOWNLD + (-13*256);

    /**
     * Failed to convert target node number to a pseudo node number for UDP.
     * Maybe the ARP table is full?
     */
    public final static int DOWNLD_SERV_IP_TARG = FACILITY_DOWNLD + (-14*256);

    /**
     * Failed to get a valid msgId from NewId function. Too many active
     * transactions.
     */
    public final static int DOWNLD_SERV_MSG_ID = FACILITY_DOWNLD + (-15*256);

    /**
     * Server time-out. Server failed all tries to get response from target
     * node.
     */
    public final static int DOWNLD_SERV_TIME_OUT = FACILITY_DOWNLD + (-16*256);

    /**
     * Too many associated status/control bits. No more than two associated
     * digital status/control fields may be specified in an SSDR.
     */
    public final static int DOWNLD_TOO_MANY_ASSOC_BITS = FACILITY_DOWNLD + (-17*256);

    /**
     * Request received for node# that is not this node. Communication protocol
     * problem.
     */
    public final static int DOWNLD_BAD_NODE = FACILITY_DOWNLD + (-18*256);

    /**
     * Incompatible high order bytes of two associated status/controls bits.
     */
    public final static int DOWNLD_INCOMPAT_ASSOC_BITS = FACILITY_DOWNLD + (-19*256);

    /**
     * Invalid floating point constant in PDB.
     */
    public final static int DOWNLD_INVALID_FP_CONST = FACILITY_DOWNLD + (-20*256);

    /**
     * Wrong number of constants in PDB.
     */
    public final static int DOWNLD_WRONG_NUM_CONSTANTS = FACILITY_DOWNLD + (-21*256);

    /**
     * NETAPI facility
     */
    public final static int FACILITY_NETAPI = 64;
    public final static int NETAPI_OK = 0;
    public final static int NETAPI_SUCCESS = 0;

    /**
     * Network binding is already in effect. An attempt was made to create a
     * network binding when this had already been done.
     */
    public final static int NETAPI_BINDING_ALREADY = FACILITY_NETAPI + (-1*256);

    /**
     * No network binding in effect.  An attempt was made to read an incoming
     * message when no binding had been performed.
     */
    public final static int NETAPI_NO_BINDING = FACILITY_NETAPI + (-2*256);

    /**
     * Failure to bind the network socket.
     */
    public final static int NETAPI_BIND_FAILURE = FACILITY_NETAPI + (-3*256);

    /**
     * Failure to create a network socket.
     */
    public final static int NETAPI_SOCKET_FAILURE = FACILITY_NETAPI + (-4*256);

    /**
     * Failure to ASSIGN a channel which is required for auto binding.
     */
    public final static int NETAPI_CHANNEL_FAILURE = FACILITY_NETAPI + (-5*256);

    /**
     * The IP connection was closed for some unknown reason.
     */
    public final static int NETAPI_CONNECTION_LOST = FACILITY_NETAPI + (-6*256);

    /**
     * Failure from socket_ioctl function.  This network function performs a
     * variety of network functions, including manipulation of socket
     * characteristics.  One common use is to control nonblocking I/O on a
     * socket.
     */
    public final static int NETAPI_IOCTL_FAILURE = FACILITY_NETAPI + (-7*256);

    /**
     * Blocking I/O is not in effect.  Blocking I/O is required for certain
     * NETAPI functions, including readUsm_tmo.
     */
    public final static int NETAPI_NO_BLOCKING = FACILITY_NETAPI + (-8*256);

    /**
     * No port number or service name provided. Some NETAPI functions require
     * either a port or service name to be specified in their parameter list.
     */
    public final static int NETAPI_NO_PORT = FACILITY_NETAPI + (-9*256);

    /**
     * Cannot translate the service name.  A service name cannot be translated
     * to a port number using the getservbyname function.
     */
    public final static int NETAPI_BAD_SERVICE = FACILITY_NETAPI + (-10*256);

    /**
     * No destination hostname or node number provided.  Some NETAPI functions
     * require either a destination hostname or node address to be specified in
     * their parameter list.
     */
    public final static int NETAPI_NO_DESTINATION = FACILITY_NETAPI + (-11*256);

    /**
     * Cannot translate the hostname.  A hostname cannot be translated to a
     * node address using the gethostbyname function.
     */
    public final static int NETAPI_BAD_HOSTNAME = FACILITY_NETAPI + (-12*256);

    /**
     * No message buffer provided.  Some NETAPI functions require a message
     * buffer having a length which is greater than zero.
     */
    public final static int NETAPI_NO_BUFFER = FACILITY_NETAPI + (-13*256);

    /**
     * No input message available.  If non-blocking I/O is in effect, this
     * error will be returned if no incoming message is available.  This error
     * will also be returned by readUsm_tmo if no incoming message is available
     * within the time limit provided.
     */
    public final static int NETAPI_NO_MESSAGE = FACILITY_NETAPI + (-14*256);

    /**
     * General receive message error.  More information about this error will
     * be available in the LOG file.
     */
    public final static int NETAPI_RECV_ERROR = FACILITY_NETAPI + (-15*256);

    /**
     * General transmit message error.  More information about this error will
     * be available in the LOG file.
     */
    public final static int NETAPI_XMIT_ERROR = FACILITY_NETAPI + (-16*256);

    /**
     * Bad version# in NETAPI header.
     */
    public final static int NETAPI_BAD_VER = FACILITY_NETAPI + (-21*256);

    /**
     * Bad NETAPI header length.
     */
    public final static int NETAPI_BAD_HDR_LEN = FACILITY_NETAPI + (-22*256);

    /**
     * Bad NETAPI header type code if neither usm (1) nor multicast (2).
     */
    public final static int NETAPI_BAD_HDR_TC = FACILITY_NETAPI + (-23*256);

    /**
     * Bad facility signature in NETAPI header. Must be 'DOWNLD  '.
     */
    public final static int NETAPI_BAD_FAC_SIG = FACILITY_NETAPI + (-24*256);

    /**
     * Bad size of request. Message received exceeded buffer size.
     */
    public final static int NETAPI_BAD_SIZE = FACILITY_NETAPI + (-25*256);

    /**
     * DAE_BRDG facility
     */
    public final static int FACILITY_DAE_BRDG = 65;
    public final static int DAE_BRDG_OK = 0;
    public final static int DAE_BRDG_SUCCESS = 0;

    /**
     * The request buffer is too small.  The request header minimum length is
     * defined in BridgeReplier as BRIDGE_REQUEST_HEADER_LENGTH.
     */
    public final static int DAE_BRDG_TRUNCREQ = FACILITY_DAE_BRDG + (-1*256);

    /**
     * The request contains zero elements.  An example is a service node
     * request specifying a list of nodes, and the list contains no elements.
     * Already executed run down.
     */
    public final static int DAE_BRDG_EMPTY = FACILITY_DAE_BRDG + (-2*256);

    /**
     * The request declares that it contains more elements than are present in
     * the request buffer.
     */
    public final static int DAE_BRDG_SHORT = FACILITY_DAE_BRDG + (-3*256);

    /**
     * The request typecode or subtypecode is not supported.  The DAE terminal
     * output will contain additional information.
     */
    public final static int DAE_BRDG_UNAVAIL = FACILITY_DAE_BRDG + (-4*256);

    /**
     * The DaqJob start failed.  The DAE terminal output will contain
     * additional information.
     */
    public final static int DAE_BRDG_JOBFAIL = FACILITY_DAE_BRDG + (-5*256);

    /**
     * DAE facility
     */
    public final static int FACILITY_DAE = 66;
    public final static int DAE_OK = 0;
    public final static int DAE_SUCCESS = 0;

    /**
     * Alternate scaling is required.  For a Java program, if a disposition
     * does not implement SettingObjectCallback, and a device's reading or
     * setting scales to a String instead of a double, this error is returned.
     */
    public final static int DAE_ALT_SCALING_REQD = FACILITY_DAE + (7*256);

    /**
     * Update in progress and not finished.
     */
    public final static int DAE_OAC_UPDATING = FACILITY_DAE + (6*256);

    /**
     * Cache BPM scaling return.
     */
    public final static int DAE_BPM_ABORT = FACILITY_DAE + (5*256);

    /**
     * Cache BPM scaling return.
     */
    public final static int DAE_BPM_ALARM = FACILITY_DAE + (4*256);

    /**
     * The setting value was null.
     */
    public final static int DAE_NULL_SETTING = FACILITY_DAE + (3*256);

    /**
     * The setting was superceded by another queued setting.
     */
    public final static int DAE_SETTING_SUPERCEDED = FACILITY_DAE + (2*256);

    /**
     * CompareSources' ReceiveData received null data without an error return.
     */
    public final static int DAE_COMPARE_NODATA = FACILITY_DAE + (-1*256);

    /**
     * CompareSources was unable to unscale the data.
     */
    public final static int DAE_COMPARE_UNSCALE_FAIL = FACILITY_DAE + (-2*256);

    /**
     * CompareSources was unable to scale the data.
     */
    public final static int DAE_COMPARE_NOSCALE = FACILITY_DAE + (-3*256);

    /**
     * DownloadSource could not acquire the data from the setting's database.
     * A reading property is downloaded from a database setting record.  A
     * basic status is downloaded from the database basic control record.  If
     * the 'DB Setting' field indicates there is no record (DBM_NOREC), then a
     * record should be added for the appropriate property.
     */
    public final static int DAE_DOWNLOAD_NODATA = FACILITY_DAE + (-4*256);

    /**
     * Either a settings download still in progress OR the OAC failed to
     * complete download of settings, probably due to a communications failure
     * with the remote damper card and/or the OAC being out of sync with the
     * damper. Reset the damper, reset the OAC, and/or restart the DAE, in that
     * order.
     */
    public final static int DAE_DOWNLOAD_EXCEPTION = FACILITY_DAE + (-5*256);

    /**
     * SavedDataSource could not open the file header for this request.
     */
    public final static int DAE_SAVE_HEADER_NOTFOUND = FACILITY_DAE + (-6*256);

    /**
     * SavedDataSource was missing a segment of database data.
     */
    public final static int DAE_SAVE_INCOMPLETE_DATA = FACILITY_DAE + (-7*256);

    /**
     * SavedDataSource caught an exception while acquiring data.  The DAE
     * terminal has additional information.
     */
    public final static int DAE_SAVE_GET_EXCEPTION = FACILITY_DAE + (-8*256);

    /**
     * A snapshot reply returned success with no addtional data.
     */
    public final static int DAE_SNAP_REPLY_TRUNCATED = FACILITY_DAE + (-9*256);

    /**
     * A snapshot request has no collection events specified.
     */
    public final static int DAE_SNAP_NO_EVENTS = FACILITY_DAE + (-10*256);

    /**
     * FastTimePlot does not support group event codes at this time.
     */
    public final static int DAE_FTP_GROUP_UNSUPPORTED = FACILITY_DAE + (-11*256);

    /**
     * The ConsolidationScheduler is not the current consolidator of this node.
     */
    public final static int DAE_CONSOLIDATION_NOT_CONSOLIDATOR = FACILITY_DAE + (-12*256);

    /**
     * The ConsolidationScheduler caught an exception when creating a DataEvent
     * from the event string.  The DAE terminal has additional information.
     */
    public final static int DAE_CONSOLIDATION_EVENT_EXCEPTION = FACILITY_DAE + (-13*256);

    /**
     * The ConsolidationScheduler was unable to locate a data pool for this
     * node.  The DAE terminal has additional information.
     */
    public final static int DAE_CONSOLIDATION_NO_POOL = FACILITY_DAE + (-14*256);

    /**
     * The ConsolidationScheduler does not support this typecode.
     */
    public final static int DAE_CONSOLIDATION_UNAVAIL = FACILITY_DAE + (-15*256);

    /**
     * The Open Access Client for this device is not available.
     */
    public final static int DAE_OAC_UNAVAIL = FACILITY_DAE + (-16*256);

    /**
     * The device and property was not found in the Open Access Client data
     * repository.
     */
    public final static int DAE_OAC_NOT_IN_REPOSITORY = FACILITY_DAE + (-17*256);

    /**
     * The requested length is invalid.
     */
    public final static int DAE_OAC_INVALID_LENGTH = FACILITY_DAE + (-18*256);

    /**
     * The requested typecode is invalid.
     */
    public final static int DAE_ALARM_INVALID_TYPECODE = FACILITY_DAE + (-19*256);

    /**
     * A local engine must not request data through this path.
     */
    public final static int DAE_RETDAT_RECURSIVE = FACILITY_DAE + (-20*256);

    /**
     * A local engine must not request data through this path.
     */
    public final static int DAE_SETDAT_RECURSIVE = FACILITY_DAE + (-21*256);

    /**
     * A local engine must not request data through this path.
     */
    public final static int DAE_POOLER_RECURSIVE = FACILITY_DAE + (-22*256);

    /**
     * The requested length is too short.
     */
    public final static int DAE_RETDAT_TRUNCATED = FACILITY_DAE + (-23*256);

    /**
     * The OAC is not the owner of this device.
     */
    public final static int DAE_OAC_NOT_OWNER = FACILITY_DAE + (-24*256);

    /**
     * The setting value was null.
     */
    public final static int DAE_SETTING_NULL = FACILITY_DAE + (-25*256);

    /**
     * The setting data is invalid.
     */
    public final static int DAE_SETTING_INVALID = FACILITY_DAE + (-26*256);

    /**
     * Setting privilege is not granted.
     */
    public final static int DAE_SETTING_PRIVILEGE = FACILITY_DAE + (-27*256);

    /**
     * Setting not queued on error.
     */
    public final static int DAE_SETTING_NOT_QUEUED = FACILITY_DAE + (-28*256);

    /**
     * Setting knob index is invalid.
     */
    public final static int DAE_SETTING_NO_SUCH_KNOB = FACILITY_DAE + (-29*256);

    /**
     * Setting no such pool.
     */
    public final static int DAE_SETTING_NO_POOL = FACILITY_DAE + (-30*256);

    /**
     * A local engine must not request data through this path.
     */
    public final static int DAE_FTPMAN_RECURSIVE = FACILITY_DAE + (-31*256);

    /**
     * A local engine must not request data through this path.
     */
    public final static int DAE_LMBRJK_RECURSIVE = FACILITY_DAE + (-32*256);

    /**
     * Request frame is too short.
     */
    public final static int DAE_LMBRJK_TRUNCATED = FACILITY_DAE + (-33*256);

    /**
     * Request not supported in Java data logger.
     */
    public final static int DAE_LMBRJK_SUPPORT = FACILITY_DAE + (-34*256);

    /**
     * Still initializing, try again later.
     */
    public final static int DAE_LMBRJK_NOT_READY = FACILITY_DAE + (-35*256);

    /**
     * Retrieval request is duplicate and out of order.
     */
    public final static int DAE_LMBRJK_DUPLICATE_REQUEST = FACILITY_DAE + (-36*256);

    /**
     * Retrieval request is out of order.
     */
    public final static int DAE_LMBRJK_ORDER = FACILITY_DAE + (-37*256);

    /**
     * Snapshot was tardy and returned no points.
     */
    public final static int DAE_TARDY_SNAP_ZIP = FACILITY_DAE + (-38*256);

    /**
     * BPM scaling expects USMs only.
     */
    public final static int DAE_BPM_SCALING = FACILITY_DAE + (-39*256);

    /**
     * Cache BPM scaling expects USMs only.
     */
    public final static int DAE_BPM_CACHE = FACILITY_DAE + (-40*256);

    /**
     * BPM scaling return invalid error code.
     */
    public final static int DAE_BPM_INVALID = FACILITY_DAE + (-41*256);

    /**
     * BPM scaling return an error code.
     */
    public final static int DAE_BPM_ERROR = FACILITY_DAE + (-44*256);

    /**
     * IPADC OAC socket error.
     */
    public final static int DAE_IPADC_ERROR = FACILITY_DAE + (-45*256);

    /**
     * BUGS ACNET handle truncated request.
     */
    public final static int DAE_BUGS_TRUNC = FACILITY_DAE + (-46*256);

    /**
     * BUGS ACNET handle bad typecode.
     */
    public final static int DAE_BUGS_TC = FACILITY_DAE + (-47*256);

    /**
     * FTP or SNAP bad reply length.
     */
    public final static int DAE_FTP_REPLY_LENGTH = FACILITY_DAE + (-48*256);

    /**
     * BigSave is off, G:BIGSAV.
     */
    public final static int DAE_BIG_SAVE_OFF = FACILITY_DAE + (-49*256);

    /**
     * Positive error and no data.
     */
    public final static int DAE_CONSOLIDATION_PLUS_ERROR = FACILITY_DAE + (-50*256);

    /**
     * The device database has changed.
     */
    public final static int DAE_DATABASE_CHANGE = FACILITY_DAE + (-51*256);

    /**
     * The one shot pool failed to complete.
     */
    public final static int DAE_ONESHOT_INCOMPLETE = FACILITY_DAE + (-52*256);

    /**
     * Generic setting error, see XMLRPC handler.
     */
    public final static int DAE_GENERIC_SETTING_ERROR = FACILITY_DAE + (-53*256);

    /**
     * The front end is obsolete or out of service.
     */
    public final static int DAE_OUT_OF_SERVICE = FACILITY_DAE + (-54*256);

    /**
     * Awaiting synchronized collection.  According to Kevin Cahill, this error
     * is unique to Glenn Johnson's and Dennis Nicklaus' Java OACs.
     */
    public final static int DAE_SYNCH_PENDING = FACILITY_DAE + (-55*256);

    /**
     * Error parsing device request.
     */
    public final static int DAE_PARSE_SDA = FACILITY_DAE + (-56*256);

    /**
     * This node/account combination does not have setting privilege.
     */
    public final static int DAE_PRIV_NODE_ACCOUNT = FACILITY_DAE + (-57*256);

    /**
     * This node does not have setting privilege for this device.
     */
    public final static int DAE_PRIV_NODE_DEVICE = FACILITY_DAE + (-58*256);

    /**
     * This account does not have setting privilege for this device.
     */
    public final static int DAE_PRIV_ACCOUNT_DEVICE = FACILITY_DAE + (-59*256);

    /**
     * Value scaled to NaN.
     */
    public final static int DAE_NOT_A_NUMBER = FACILITY_DAE + (-60*256);

    /**
     * Value scaled as infiinite.
     */
    public final static int DAE_INFINITE = FACILITY_DAE + (-61*256);

    /**
     * No client data exists in logger.
     */
    public final static int DAE_NO_CLIENT = FACILITY_DAE + (-62*256);

    /**
     * Exception reading or setting GPIB data.
     */
    public final static int DAE_GPIB_EXCEPTION = FACILITY_DAE + (-63*256);

    /**
     * The data logger has no points to return.
     */
    public final static int DAE_LJ_NO_DATA = FACILITY_DAE + (-64*256);

    /**
     * The data returned from the OPC server is not valid.
     */
    public final static int DAE_OPC_BAD_DATA = FACILITY_DAE + (-65*256);

    /**
     * The OPC server is not responding.
     */
    public final static int DAE_OPC_SERVER_UNAVAIL = FACILITY_DAE + (-66*256);

    /**
     * The data from NOVA PW server is not valid.
     */
    public final static int DAE_NOVA_PW_BAD_DATA = FACILITY_DAE + (-67*256);

    /**
     * The NOVA Power server is not responding.
     */
    public final static int DAE_NOVA_PW_UNAVAIL = FACILITY_DAE + (-68*256);

    /**
     * The data from NOVA Siemens server is not valid.
     */
    public final static int DAE_NOVA_SIEMENS_BAD_DATA = FACILITY_DAE + (-69*256);

    /**
     * The NOVA Siemens server is not responding.
     */
    public final static int DAE_NOVA_SIEMENS_UNAVAIL = FACILITY_DAE + (-70*256);

    /**
     * The data from NOVA Phidgt server is not valid.
     */
    public final static int DAE_NOVA_PHIDGT_BAD_DATA = FACILITY_DAE + (-71*256);

    /**
     * The NOVA Phidgt server is not responding.
     */
    public final static int DAE_NOVA_PHIDGT_UNAVAIL = FACILITY_DAE + (-72*256);

    /**
     * This service does not support the user's request.
     */
    public final static int DAE_NOT_SUPPORTED = FACILITY_DAE + (-73*256);

    /**
     * LABVIEW facility
     */
    public final static int FACILITY_LABVIEW = 67;
    public final static int LABVIEW_OK = 0;
    public final static int LABVIEW_SUCCESS = 0;

    /**
     * The requested front end doesn't support this device.
     */
    public final static int LABVIEW_INVALID_DEVICE = FACILITY_LABVIEW + (-1*256);

    /**
     * An invalid offset was requested.  Most likely this is a database entry
     * problem.
     */
    public final static int LABVIEW_BAD_OFFSET = FACILITY_LABVIEW + (-2*256);

    /**
     * An invalid length was requested.  Most likely this is a database entry
     * problem.
     */
    public final static int LABVIEW_BAD_LENGTH = FACILITY_LABVIEW + (-3*256);

    /**
     * An invalid FTD was requested.  Periodic requests must be in the range
     * from 15 to .001 Hz.
     */
    public final static int LABVIEW_BAD_FTD = FACILITY_LABVIEW + (-4*256);

    /**
     * An unrecognizable or unsupported request was made.
     */
    public final static int LABVIEW_INVALID_REQUEST = FACILITY_LABVIEW + (-5*256);

    /**
     * All requested devices are in error.
     */
    public final static int LABVIEW_BAD_REQUEST = FACILITY_LABVIEW + (-6*256);

    /**
     * Your request was not found.  Typically this error results from
     * attempting to cancel a request that the front end doesn't know about.
     */
    public final static int LABVIEW_NO_SUCH_REQUEST = FACILITY_LABVIEW + (-7*256);

    /**
     * Too many RETDAT requests are active.  The maximum number of active
     * RETDAT requests is 50.
     */
    public final static int LABVIEW_TOO_MANY_REQUESTS = FACILITY_LABVIEW + (-8*256);

    /**
     * The front end doesn't support the requested clock event.
     */
    public final static int LABVIEW_UNSUPPORTED_EVENT = FACILITY_LABVIEW + (-9*256);

    /**
     * An invalid offset/length combination was requested.  Most likely this is
     * a database entry problem.
     */
    public final static int LABVIEW_BAD_OFFLEN = FACILITY_LABVIEW + (-10*256);

    /**
     * BPM facility
     */
    public final static int FACILITY_BPM = 68;
    public final static int BPM_OK = 0;
    public final static int BPM_SUCCESS = 0;

    /**
     * Armed: The arm event has been received and the front end is configuring
     * the I/O subsystems for the measurement.
     */
    public final static int BPM_ARMED = FACILITY_BPM + (127*256);

    /**
     * AwaitingTrigger: The arm event has been received and the front end is
     * waiting for the specified trigger event.
     */
    public final static int BPM_AWAITING_TRIGGER = FACILITY_BPM + (126*256);

    /**
     * Triggered: The trigger event has been received and the front end is
     * preparing for data readout.
     */
    public final static int BPM_TRIGGERED = FACILITY_BPM + (125*256);

    /**
     * ReadingData: The front end is reading position data collected at the
     * last trigger.
     */
    public final static int BPM_READING_DATA = FACILITY_BPM + (124*256);

    /**
     * ReadingCalibration: The front end is reading calibration data collected
     * after the last trigger.
     */
    public final static int BPM_READING_CALIBRATION = FACILITY_BPM + (123*256);

    /**
     * MeasurementActive: The repetitive (background) measurement is active
     */
    public final static int BPM_MEASUREMENT_ACTIVE = FACILITY_BPM + (122*256);

    /**
     * Disabled: Measurement was disabled by user with an
     * AcquisitionSpecification.
     */
    public final static int BPM_DISABLED = FACILITY_BPM + (121*256);

    /**
     * Preempted: Measurement has been preempted by another measurement with
     * different arm/trigger conditions.  It is also possible for a measurement
     * to be preempted by an identical measurement if the original measurement
     * is armed but no trigger is received before the same arm event occures
     * again.
     */
    public final static int BPM_PREEMPTED = FACILITY_BPM + (120*256);

    /**
     * MeasurementArmWillMask: This measurement will mask another measurement
     * with the same arm event.  The arm event specified in this Acquisition
     * Specification is already used by another measurement with a higher event
     * index.  Event indices range from zero (Interactive) to 15 with the
     * higher indices having lower priority.  Therefore this measurement will
     * reveive arm events and the other one will effectively be masked until
     * this measurement is disabled.
     */
    public final static int BPM_ARM_WILL_MASK = FACILITY_BPM + (111*256);

    /**
     * MeasurementArmIsMasked: This measurement will be masked by another
     * measurement with the same arm event.  The arm event specified in this
     * Acquisition Specification is already used by another measurement with a
     * lower event index.  Event indices range from zero (Interactive) to 15
     * with the higher indices having lower priority.  Therefore the other
     * measurement will receive arm events and this one will effectively be
     * masked until the other measurement is disabled.
     */
    public final static int BPM_ARM_IS_MASKED = FACILITY_BPM + (110*256);

    /**
     * AdcStatus_79: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_79 = FACILITY_BPM + (79*256);

    /**
     * AdcStatus_78: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_78 = FACILITY_BPM + (78*256);

    /**
     * AdcStatus_77: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_77 = FACILITY_BPM + (77*256);

    /**
     * AdcStatus_76: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_76 = FACILITY_BPM + (76*256);

    /**
     * AdcStatus_75: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_75 = FACILITY_BPM + (75*256);

    /**
     * AdcStatus_74: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_74 = FACILITY_BPM + (74*256);

    /**
     * AdcStatus_73: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_73 = FACILITY_BPM + (73*256);

    /**
     * AdcStatus_72: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_72 = FACILITY_BPM + (72*256);

    /**
     * AdcStatus_71: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_71 = FACILITY_BPM + (71*256);

    /**
     * AdcStatus_70: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_70 = FACILITY_BPM + (70*256);

    /**
     * AdcStatus_69: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_69 = FACILITY_BPM + (69*256);

    /**
     * AdcStatus_68: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_68 = FACILITY_BPM + (68*256);

    /**
     * AdcStatus_67: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_67 = FACILITY_BPM + (67*256);

    /**
     * AdcStatus_66: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_66 = FACILITY_BPM + (66*256);

    /**
     * AdcStatus_65: Echotek ADC I/O driver status - undefined
     */
    public final static int BPM_ADC_STATUS_65 = FACILITY_BPM + (65*256);

    /**
     * NoDataFound: Echotek ADC I/O driver status - The BPM did not find any
     * beam on this measurement.
     */
    public final static int BPM_NO_DATA_FOUND = FACILITY_BPM + (64*256);

    /**
     * DiagnosticMode: This data is unavailable because the system is in
     * diagnostic mode.  Diagnostic mode is almost always entered through use
     * of the BPM Engineering/Diagnostic application.
     */
    public final static int BPM_DIAGNOSTIC_MODE = FACILITY_BPM + (5*256);

    /**
     * ReadoutBusy: The requested ReadoutSpecification and its associated type
     * of data are busy servicing another user's request for data.  Wait a few
     * ticks, and try again.
     */
    public final static int BPM_READOUT_BUSY = FACILITY_BPM + (4*256);

    /**
     * DataUnavailable: The requested measurement data has not been collected.
     * This usually means that the arm and/or trigger conditions specified for
     * the measurement have not yet been met.  Perhaps the requested number of
     * samples has not yet been acquired.
     */
    public final static int BPM_DATA_UNAVAILABLE = FACILITY_BPM + (3*256);

    /**
     * WaitingForDownload: The front end node can't make measurements because
     * it has not yet been configured by the parameter download system (SLAM)
     * after the last reboot.
     */
    public final static int BPM_WAITING_FOR_DOWNLOAD = FACILITY_BPM + (2*256);

    /**
     * Initialization: The requested measurement data has not been collected.
     * This usually means that the arm and/or trigger conditions specified for
     * the measurement have not been met since the last time the BPM front end
     * was rebooted.
     */
    public final static int BPM_INITIALIZATION = FACILITY_BPM + (1*256);

    /**
     * This code should not be returned to ACNET -- inform front end keeper!
     */
    public final static int BPM_GENERIC_ERROR = FACILITY_BPM + (-1*256);

    /**
     * InitializationError: There was some sort of error during the front end
     * boot process.  See this node's initialization status device m:xxxIST for
     * an error code.
     */
    public final static int BPM_INITIALIZATION_ERROR = FACILITY_BPM + (-2*256);

    /**
     * ReadoutProtocolError: The ReadoutSpecification for this data type has
     * timed out or was not properly set prior to this attempt to read
     * measurement data.
     */
    public final static int BPM_READOUT_PROTOCOL_ERROR = FACILITY_BPM + (-3*256);

    /**
     * NoSuchChannel: The requested channel is not supported by this front end.
     */
    public final static int BPM_NO_SUCH_CHANNEL = FACILITY_BPM + (-4*256);

    /**
     * NoSuchData: The requested data is not supported by this front end.
     */
    public final static int BPM_NO_SUCH_DATA = FACILITY_BPM + (-5*256);

    /**
     * RequestedDataNotAcquired: You are asking for values that cannot be
     * determined from the event data that you have specified.  For example you
     * may be asking for individual bunch positions from event data that was
     * collected with an ensemble filter.
     */
    public final static int BPM_REQDATA_NOT_ACQUIRED = FACILITY_BPM + (-6*256);

    /**
     * ParameterNotSettable: You have tried to set a parameter that has been
     * marked as not settable by the front end.  This usually means that the
     * value for this parameter (or element of a parameter array device) is
     * initialized by the front end's startup script, esentially making the
     * value hard coded.
     */
    public final static int BPM_PARAM_NOT_SETTABLE = FACILITY_BPM + (-9*256);

    /**
     * no longer used - reserved
     */
    public final static int BPM_ARM_EVENT_IN_USE = FACILITY_BPM + (-10*256);

    /**
     * TriggerEventNotSupported: The specified trigger event is not supported
     * by this measurement type.
     */
    public final static int BPM_TRIG_EVT_NO_SUPPORT = FACILITY_BPM + (-11*256);

    /**
     * ReadoutProtocolError: The ReadoutSpecification for this data type has
     * timed out or was not properly set prior to this attempt to read
     * measurement data.
     */
    public final static int BPM_READOUT_PROTOCOL_ERR = FACILITY_BPM + (-32*256);

    /**
     * BadCalSpecControl: The AOnly/kAGreaterThanB/kAEqualB/kALessThanB/BOnly
     * field of the NuMI CalibrationSpecification is in error.  The
     * kAGreaterThanB/kAEqualB/kALessThanB field of the Rapid Transfer
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_CONTROL = FACILITY_BPM + (-49*256);

    /**
     * BadCalSpecMode: The continuous/pulse field of the
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_MODE = FACILITY_BPM + (-50*256);

    /**
     * BadCalSpecFrequency: The 53MHz/2.5MHz frequency field of the
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_FREQUENCY = FACILITY_BPM + (-51*256);

    /**
     * BadCalSpecWaveform: The waveform select field of the
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_WAVEFORM = FACILITY_BPM + (-52*256);

    /**
     * BadCalSpecBalance: The waveform balance field of the
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_BALANCE = FACILITY_BPM + (-53*256);

    /**
     * BadCalSpecAmplitude: The amplitude field of the CalibrationSpecification
     * is in error.
     */
    public final static int BPM_CALSPEC_AMPLITUDE = FACILITY_BPM + (-54*256);

    /**
     * BadCalSpecMustBeZero: The 'must be zero' field of the
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_MUSTBEZERO = FACILITY_BPM + (-55*256);

    /**
     * BadCalSpecCalSystemType: The calibration system type field of the
     * CalibrationSpecification is in error.
     */
    public final static int BPM_CALSPEC_CALSYSTYPE = FACILITY_BPM + (-56*256);

    /**
     * BadDiaSpecMustBeZero: The 'must be zero' field of the
     * DiagnosticSpecification is in error.
     */
    public final static int BPM_DIASPEC_MUSTBEZERO = FACILITY_BPM + (-57*256);

    /**
     * BadDiaSpecEnable: The enable field of the DiagnosticSpecification is in
     * error.
     */
    public final static int BPM_DIASPEC_ENABLE = FACILITY_BPM + (-58*256);

    /**
     * BadDiaSpecChannelA: The channel A field of the DiagnosticSpecification
     * is in error.
     */
    public final static int BPM_DIASPEC_CHANNELA = FACILITY_BPM + (-59*256);

    /**
     * BadDiaSpecChannelB: The channel B field of the DiagnosticSpecification
     * is in error.
     */
    public final static int BPM_DIASPEC_CHANNELB = FACILITY_BPM + (-60*256);

    /**
     * BadRdoSpecChannel: The channel field of the ReadoutSpecification is in
     * error.
     */
    public final static int BPM_RDOSPEC_CHANNEL = FACILITY_BPM + (-61*256);

    /**
     * BadRdoSpecBeginPlusNumTurns: The sum of the begin turn and number of
     * turns fields of the ReadoutSpecification is in error.
     */
    public final static int BPM_RDOSPEC_BEGINNUMTURN = FACILITY_BPM + (-62*256);

    /**
     * BadRdoSpecNumTurns: The number of turns field of the
     * ReadoutSpecification is in error.
     */
    public final static int BPM_RDOSPEC_NUMTURNS = FACILITY_BPM + (-63*256);

    /**
     * BadRdoSpecBeginTurn: The begin turn field of the ReadoutSpecification is
     * in error.
     */
    public final static int BPM_RDOSPEC_BEGINTURN = FACILITY_BPM + (-64*256);

    /**
     * BadRdoSpecDataType: The data type field of the ReadoutSpecification is
     * in error.
     */
    public final static int BPM_RDOSPEC_DATATYPE = FACILITY_BPM + (-65*256);

    /**
     * BadRdoSpecEventIndex: The event index field of the ReadoutSpecification
     * is in error.
     */
    public final static int BPM_RDOSPEC_EVENTINDEX = FACILITY_BPM + (-66*256);

    /**
     * BadAcqSpecMeasurementTrigger: The AcquisitionSpecification contains a
     * request to make a repetitive measurement on the 0xC0 or 0xAA revolution
     * marker.  What are you -- Nuts?  This is asking the front end to take a
     * 'background' measurement on every revolution!
     */
    public final static int BPM_ACQSPEC_MEASURETRIG = FACILITY_BPM + (-67*256);

    /**
     * BadAcqSpecTimeout: The timeout field of the AcquisitionSpecification is
     * in error.  Try a value from 1 second to 5 minutes.
     */
    public final static int BPM_ACQSPEC_TIMEOUT = FACILITY_BPM + (-68*256);

    /**
     * BadAcqSpecIntensityThreshold: The intensity threshold field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_INTTHRESHOLD = FACILITY_BPM + (-69*256);

    /**
     * BadAcqSpecGlobalDelay: The global delay (RF buckets) field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_GLOBALDELAY = FACILITY_BPM + (-70*256);

    /**
     * BadAcqSpecTriggerDelay: The trigger delay (turns) field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_TRIGGERDELAY = FACILITY_BPM + (-71*256);

    /**
     * BadAcqSpecTriggerFrequency: The trigger frequency (Hertz) field of the
     * AcquisitionSpecification is in error.  Try a value from 2 to 100 Hz
     * (some systems, like the NuMI orbit verifier, can go higher).
     */
    public final static int BPM_ACQSPEC_TRIGGERFREQ = FACILITY_BPM + (-72*256);

    /**
     * BadAcqSpecPreTriggerEnable: The pretrigger enable field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_PRETRIGENABL = FACILITY_BPM + (-73*256);

    /**
     * BadAcqSpecTriggerEvent: The trigger event field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_TRIGGEREVENT = FACILITY_BPM + (-74*256);

    /**
     * BadAcqSpecArmEvent: The arm event field of the AcquisitionSpecification
     * is in error.
     */
    public final static int BPM_ACQSPEC_ARMEVENT = FACILITY_BPM + (-75*256);

    /**
     * BadAcqSpecMeasurementType: The measurement type field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_MEASURETYPE = FACILITY_BPM + (-76*256);

    /**
     * BadAcqSpecBeamType: The beam type field of the AcquisitionSpecification
     * is in error.
     */
    public final static int BPM_ACQSPEC_BEAMTYPE = FACILITY_BPM + (-77*256);

    /**
     * BadAcqSpecBeamMode: The beam mode field of the AcquisitionSpecification
     * is in error.
     */
    public final static int BPM_ACQSPEC_BEAMMODE = FACILITY_BPM + (-78*256);

    /**
     * BadAcqSpecMeasurement: The measurement field of the
     * AcquisitionSpecification is in error.
     */
    public final static int BPM_ACQSPEC_MEASUREMENT = FACILITY_BPM + (-79*256);

    /**
     * kBadAcqSpecSpecAttributes: The specification attributes field of the
     * AcquisitionSpecification is in error.  ### Currently this field must be
     * set to zero. ###
     */
    public final static int BPM_ACQSPEC_ENABLE = FACILITY_BPM + (-80*256);

    /**
     * The prearm phase of the measurement timed out.  This means that none of
     * the measurements that this prearm has enabled has occurred.  This could
     * be because the arm or trigger conditions in the relevant
     * AcquisitionSpecifications are incorrect.
     */
    public final static int BPM_PREARM_TIMEOUT = FACILITY_BPM + (-91*256);

    /**
     * The arm event was unable to start the appropriate measurement task.
     */
    public final static int BPM_ARM_FAILURE = FACILITY_BPM + (-92*256);

    /**
     * The trigger event did not come along within the measurement timeout
     * period.
     */
    public final static int BPM_TRIGGER_TIMEOUT = FACILITY_BPM + (-93*256);

    /**
     * UcdConfigurationError: The TClk timing subsystem status indicated a
     * problem while configuring the measurement.
     */
    public final static int BPM_UCD_CONFIG_ERROR = FACILITY_BPM + (-94*256);

    /**
     * TsgConfigurationError: The BSync timing subsystem status indicated a
     * problem while configuring the measurement.
     */
    public final static int BPM_TSG_CONFIG_ERROR = FACILITY_BPM + (-95*256);

    /**
     * AdcConfigurationError: The analog input subsystem status indicated a
     * problem while configuring the measurement.
     */
    public final static int BPM_ADC_CONFIG_ERROR = FACILITY_BPM + (-96*256);

    /**
     * TsgError_97: Controls Timing Signal Generator I/O driver error.
     */
    public final static int BPM_TSG_ERROR_97 = FACILITY_BPM + (-97*256);

    /**
     * TsgError_98: Controls Timing Signal Generator I/O driver error.
     */
    public final static int BPM_TSG_ERROR_98 = FACILITY_BPM + (-98*256);

    /**
     * BsyncError: There is someting wrong with the Bsync clock decoder on the
     * Timing Signal Generator.
     */
    public final static int BPM_BSYNC_ERROR = FACILITY_BPM + (-99*256);

    /**
     * MdatError: There is someting wrong with the MDAT clock decoder on the
     * Timing Signal Generator.
     */
    public final static int BPM_MDAT_ERROR = FACILITY_BPM + (-100*256);

    /**
     * TurnCounterError: There is someting wrong with the Bsync turn counter on
     * the Timing Signal Generator.
     */
    public final static int BPM_TURN_COUNTER_ERROR = FACILITY_BPM + (-101*256);

    /**
     * 53MHzError: The 53 MHz clock is missing on the Timing Signal Generator.
     */
    public final static int BPM_53MHZ_ERROR = FACILITY_BPM + (-102*256);

    /**
     * AcquisitionCountOverflow: The number of turns is too large.
     */
    public final static int BPM_ACQ_COUNT_OVERFLOW = FACILITY_BPM + (-103*256);

    /**
     * AcquisitionDelayOverflow: The sum of all acquisition delay terms is too
     * large.
     */
    public final static int BPM_ACQ_DELAY_OVERFLOW = FACILITY_BPM + (-104*256);

    /**
     * NoMdatMessage: The required MDAT message was not detected.
     */
    public final static int BPM_NO_MDAT_MESSAGE = FACILITY_BPM + (-105*256);

    /**
     * NoBsyncTurn: The Bsync clock turn marker was not detected.
     */
    public final static int BPM_NO_BSYNC_TURN = FACILITY_BPM + (-106*256);

    /**
     * IllegalBeamType: BeamType was not InjectExtract, Hot, HotHead, HotTail,
     * Cold, ColdHead, or ColdTail.
     */
    public final static int BPM_ILLEGAL_BEAM_TYPE = FACILITY_BPM + (-107*256);

    /**
     * IllegalBeamMode: BeamMode was not proton, antiproton or calibration.
     */
    public final static int BPM_ILLEGAL_BEAM_MODE = FACILITY_BPM + (-108*256);

    /**
     * IllegalMode: Mode was not initialization, flash or turn-by-turn.
     */
    public final static int BPM_ILLEGAL_MODE = FACILITY_BPM + (-109*256);

    /**
     * MissingTsgMaster: The master TSG module is missing or not responding.
     */
    public final static int BPM_MISSING_TSG_MASTER = FACILITY_BPM + (-110*256);

    /**
     * MissingTsg: TSG module A is missing or not responding.
     */
    public final static int BPM_MISSING_TSG = FACILITY_BPM + (-111*256);

    /**
     * TsgError: This code should not be returned to ACNET -- inform front end
     * keeper!
     */
    public final static int BPM_TSG_ERROR = FACILITY_BPM + (-112*256);

    /**
     * AdcError_113: Echotek ADC I/O driver error - undefined
     */
    public final static int BPM_ADC_ERROR_113 = FACILITY_BPM + (-113*256);

    /**
     * AdcError_114: Echotek ADC I/O driver error - undefined
     */
    public final static int BPM_ADC_ERROR_114 = FACILITY_BPM + (-114*256);

    /**
     * AdcError_115: Echotek ADC I/O driver error - undefined
     */
    public final static int BPM_ADC_ERROR_115 = FACILITY_BPM + (-115*256);

    /**
     * DmaBadInt: Echotek ADC I/O driver error
     */
    public final static int BPM_DMA_BAD_INT = FACILITY_BPM + (-116*256);

    /**
     * NoDataFound: Echotek ADC I/O driver status - this is not an error. The
     * BPM simply did not find any beam on this measurement.
     */
    public final static int BPM_ADC_ERROR_117 = FACILITY_BPM + (-117*256);

    /**
     * NoDataBuffer: Echotek ADC I/O driver error
     */
    public final static int BPM_NO_DATA_BUFFER = FACILITY_BPM + (-118*256);

    /**
     * BadBoard: Echotek ADC I/O driver error
     */
    public final static int BPM_BAD_BOARD = FACILITY_BPM + (-119*256);

    /**
     * SamplesPerTurn: Echotek ADC I/O driver error
     */
    public final static int BPM_SAMPLES_PER_TURN = FACILITY_BPM + (-120*256);

    /**
     * CollectionTmo: Echotek ADC I/O driver error
     */
    public final static int BPM_COLLECTION_TMO = FACILITY_BPM + (-121*256);

    /**
     * DmaFailed: Echotek ADC I/O driver error
     */
    public final static int BPM_DMA_FAILED = FACILITY_BPM + (-122*256);

    /**
     * TooManySamples: Echotek ADC I/O driver error
     */
    public final static int BPM_TOO_MANY_SAMPLES = FACILITY_BPM + (-123*256);

    /**
     * Aborted: Echotek ADC I/O driver error
     */
    public final static int BPM_ABORTED = FACILITY_BPM + (-124*256);

    /**
     * DataInvalid: Echotek ADC I/O driver error
     */
    public final static int BPM_DATA_INVALID = FACILITY_BPM + (-125*256);

    /**
     * UnsupportedMode: Echotek ADC I/O driver error
     */
    public final static int BPM_UNSUPPORTED_MODE = FACILITY_BPM + (-126*256);

    /**
     * WrongMode: Echotek ADC I/O driver error
     */
    public final static int BPM_WRONG_MODE = FACILITY_BPM + (-127*256);

    /**
     * AdcError: Echotek ADC I/O driver error
     */
    public final static int BPM_ADC_ERROR = FACILITY_BPM + (-128*256);

    /**
     * DMQ facility
     */
    public final static int FACILITY_DMQ = 72;
    public final static int DMQ_OK = 0;
    public final static int DMQ_SUCCESS = 0;

    /**
     * Request is pending.  Your request has been successfully sent to a front
     * end.  No data has come back yet from that request.
     */
    public final static int DMQ_PEND = FACILITY_DMQ + (1*256);

    /**
     * Invalid data type encountered.
     */
    public final static int DMQ_INVALID_DATA_TYPE = FACILITY_DMQ + (-93*256);

    /**
     * Settings are currently disabled.
     */
    public final static int DMQ_SETTINGS_DISABLED = FACILITY_DMQ + (-94*256);

    /**
     * An internal server error has occurred.
     */
    public final static int DMQ_INTERNAL_SERVER_ERROR = FACILITY_DMQ + (-95*256);

    /**
     * Channel is not ready.
     */
    public final static int DMQ_CHANNEL_NOT_READY = FACILITY_DMQ + (-96*256);

    /**
     * A duplicate job request was made.
     */
    public final static int DMQ_DUPLICATE_JOB = FACILITY_DMQ + (-97*256);

    /**
     * An invalid request was made.
     */
    public final static int DMQ_INVALID_REQUEST = FACILITY_DMQ + (-98*256);

    /**
     * A security violation occurred.
     */
    public final static int DMQ_SECURITY_VIOLATION = FACILITY_DMQ + (-99*256);
}
